<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  
  
  
  <meta name="description" content="穷则独善其身">
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <title>
    vue3-diff |
    
    zeus の blog</title>
  
  <link rel="shortcut icon" href="/zeus.ico">
  
  
<link rel="stylesheet" href="/css/style.css">

  
  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<script src="/js/pace.min.js"></script>

<meta name="generator" content="Hexo 7.2.0"></head>

<body>
  <main class="content">
    <section class="outer">
  <article id="post-vue3-diff" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
      

<h1 class="article-title" itemprop="name">
  vue3-diff
</h1>



    </header>
    

    
    <div class="article-meta">
      <a href="/2023/10/04/vue3-diff/" class="article-date">
  <time datetime="2023-10-04T10:40:25.000Z" itemprop="datePublished">2023-10-04</time>
</a>
      
    </div>
    

    
    
<div class="tocbot"></div>

    

    <div class="article-entry" itemprop="articleBody">
      
      
      
      <p>Vue3 diff 算法与 Vue2 相比，最大的不同就是<strong>不再使用双端比较算法</strong>，而是<strong>使用最长递增子序列算法</strong>。</p>
<blockquote>
<p>最长递增子序列（Longest Increasing Subsequence，LIS）问题，是算法中经典的动态规划问题。</p>
</blockquote>
<span id="more"></span>

<p>在 Vue 3.x 版本中，编译时做了不少优化，为 <code>patch</code> 函数提供了便利。</p>
<h3 id="核心算法"><a href="#核心算法" class="headerlink" title="核心算法"></a>核心算法</h3><p><strong>其中核心算法函数为 <code>patchKeyedChildren</code> 函数</strong>，源码位于 <code>packages/runtime-core/src/renderer.ts</code>。</p>
<p><font color="red"><strong>该函数分为 5 步，第 5 步又细分为 3 小步（复杂且关键），其中也包含了最长递增子序列的算法。</strong></font></p>
<blockquote>
<p>前言：需要区分与 Vue2 不同的维护变量</p>
</blockquote>
<p>（希望第 2 遍看，只需要看图片和右侧标题，不需要看文字。）</p>
<h4 id="同步头部节点"><a href="#同步头部节点" class="headerlink" title="同步头部节点"></a>同步头部节点</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">patchKeyedChildren</span> = (<span class="params">c1, c2, container, parentAnchor, parentComponent, parentSuspense, isSVG, optimized</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span></span><br><span class="line">  <span class="keyword">const</span> l2 = c2.<span class="property">length</span></span><br><span class="line">  <span class="comment">// 旧子节点的尾部索引</span></span><br><span class="line">  <span class="keyword">let</span> e1 = c1.<span class="property">length</span> - <span class="number">1</span></span><br><span class="line">  <span class="comment">// 新子节点的尾部索引</span></span><br><span class="line">  <span class="keyword">let</span> e2 = l2 - <span class="number">1</span></span><br><span class="line">  <span class="comment">// 1. 从头部开始同步</span></span><br><span class="line">  <span class="comment">// i = 0, e1 = 3, e2 = 4</span></span><br><span class="line">  <span class="comment">// (a b) c d</span></span><br><span class="line">  <span class="comment">// (a b) e c d</span></span><br><span class="line">  <span class="keyword">while</span> (i &lt;= e1 &amp;&amp; i &lt;= e2) &#123;</span><br><span class="line">    <span class="keyword">const</span> n1 = c1[i]</span><br><span class="line">    <span class="keyword">const</span> n2 = c2[i]</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isSameVNodeType</span>(n1, n2)) &#123;</span><br><span class="line">      <span class="comment">// 相同的节点，递归执行 patch 更新节点</span></span><br><span class="line">      <span class="title function_">patch</span>(n1, n2, container, parentAnchor, parentComponent, parentSuspense, isSVG, optimized)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">    i++</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>diff 过程中需要维护的几个变量：<strong>头部的索引 i（可以理解为新旧节点公共的首部索引）、旧子节点的尾部索引 e1和新子节点的尾部索引 e2</strong>。</p>
<p>同步头部节点就是从头部开始，依次对比新节点和旧节点，如果它们相同的则执行 patch 更新节点；如果不同或者索引 i 大于索引 e1 或者 e2，则同步过程结束。</p>
<p><img src="/images/diff-vue-react/1716197845396.png" alt="1716197845396"></p>
<p>完成头部节点同步后：i 是 2，e1 是 3，e2 是 4。</p>
<h4 id="同步尾部节点"><a href="#同步尾部节点" class="headerlink" title="同步尾部节点"></a>同步尾部节点</h4><p>接着从尾部开始 <strong>同步尾部节点</strong> ，实现代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">patchKeyedChildren</span> = (<span class="params">c1, c2, container, parentAnchor, parentComponent, parentSuspense, isSVG, optimized</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span></span><br><span class="line">  <span class="keyword">const</span> l2 = c2.<span class="property">length</span></span><br><span class="line">  <span class="comment">// 旧子节点的尾部索引</span></span><br><span class="line">  <span class="keyword">let</span> e1 = c1.<span class="property">length</span> - <span class="number">1</span></span><br><span class="line">  <span class="comment">// 新子节点的尾部索引</span></span><br><span class="line">  <span class="keyword">let</span> e2 = l2 - <span class="number">1</span></span><br><span class="line">  <span class="comment">// 1. 从头部开始同步</span></span><br><span class="line">  <span class="comment">// i = 0, e1 = 3, e2 = 4</span></span><br><span class="line">  <span class="comment">// (a b) c d</span></span><br><span class="line">  <span class="comment">// (a b) e c d</span></span><br><span class="line">  <span class="comment">// 2. 从尾部开始同步</span></span><br><span class="line">  <span class="comment">// i = 2, e1 = 3, e2 = 4</span></span><br><span class="line">  <span class="comment">// (a b) (c d)</span></span><br><span class="line">  <span class="comment">// (a b) e (c d)</span></span><br><span class="line">  <span class="keyword">while</span> (i &lt;= e1 &amp;&amp; i &lt;= e2) &#123;</span><br><span class="line">    <span class="keyword">const</span> n1 = c1[e1]</span><br><span class="line">    <span class="keyword">const</span> n2 = c2[e2]</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isSameVNodeType</span>(n1, n2)) &#123;</span><br><span class="line">      <span class="title function_">patch</span>(n1, n2, container, parentAnchor, parentComponent, parentSuspense, isSVG, optimized)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">    e1--</span><br><span class="line">    e2--</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同步尾部节点就是从尾部开始，依次对比新节点和旧节点，如果相同的则执行 patch 更新节点；如果不同或者索引 i 大于索引 e1 或者 e2，则同步过程结束。</p>
<p><img src="/images/diff-vue-react/1716198093362.png" alt="1716198093362"></p>
<p>可以看到，完成尾部节点同步后：i 是 2，e1 是 1，e2 是 2。</p>
<p><font color="red"><strong>中途总结：前面 2 步非常容易理解，就是先去头去尾，剩下新旧节点的中间部分。</strong></font></p>
<p>接下来只有 3 种情况要处理：</p>
<ul>
<li><strong>旧子节点都没有了</strong>，新子节点只有剩余要添加的新节点；</li>
<li><strong>新子节点都没有了</strong>，旧子节点有剩余要删除的多余节点；</li>
<li><strong>新子节点和旧子节点都同时还有剩余节点</strong>，未知子序列。</li>
</ul>
<h4 id="仅剩余新子节点-添加新的节点"><a href="#仅剩余新子节点-添加新的节点" class="headerlink" title="仅剩余新子节点-添加新的节点"></a>仅剩余新子节点-添加新的节点</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">patchKeyedChildren</span> = (<span class="params">c1, c2, container, parentAnchor, parentComponent, parentSuspense, isSVG, optimized</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span></span><br><span class="line">  <span class="keyword">const</span> l2 = c2.<span class="property">length</span></span><br><span class="line">  <span class="comment">// 旧子节点的尾部索引</span></span><br><span class="line">  <span class="keyword">let</span> e1 = c1.<span class="property">length</span> - <span class="number">1</span></span><br><span class="line">  <span class="comment">// 新子节点的尾部索引</span></span><br><span class="line">  <span class="keyword">let</span> e2 = l2 - <span class="number">1</span></span><br><span class="line">  <span class="comment">// 1. 从头部开始同步</span></span><br><span class="line">  <span class="comment">// i = 0, e1 = 3, e2 = 4</span></span><br><span class="line">  <span class="comment">// (a b) c d</span></span><br><span class="line">  <span class="comment">// (a b) e c d</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// 2. 从尾部开始同步</span></span><br><span class="line">  <span class="comment">// i = 2, e1 = 3, e2 = 4</span></span><br><span class="line">  <span class="comment">// (a b) (c d)</span></span><br><span class="line">  <span class="comment">// (a b) e (c d)</span></span><br><span class="line">  <span class="comment">// 3. 挂载剩余的新节点</span></span><br><span class="line">  <span class="comment">// i = 2, e1 = 1, e2 = 2</span></span><br><span class="line">  <span class="keyword">if</span> (i &gt; e1) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt;= e2) &#123;</span><br><span class="line">      <span class="keyword">const</span> nextPos = e2 + <span class="number">1</span></span><br><span class="line">      <span class="keyword">const</span> anchor = nextPos &lt; l2 ? c2[nextPos].<span class="property">el</span> : parentAnchor</span><br><span class="line">      <span class="keyword">while</span> (i &lt;= e2) &#123;</span><br><span class="line">        <span class="comment">// 挂载新节点</span></span><br><span class="line">        <span class="title function_">patch</span>(<span class="literal">null</span>, c2[i], container, anchor, parentComponent, parentSuspense, isSVG)</span><br><span class="line">     	  i++</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果索引 i 大于尾部索引 e1（旧子节点都没有了）且 i 小于 e2（新子节点都还有剩余），那么从索引 i 开始到索引 e2 之间，<strong>我们直接挂载新子树这部分的节点</strong>。</p>
<p><img src="/images/diff-vue-react/1716198948270.png" alt="1716198948270"></p>
<p>添加完 e 节点后，旧子节点的 DOM 和新子节点对应的 vnode 映射一致，也就完成了更新。</p>
<h4 id="仅剩余旧子节点-删除多余节点"><a href="#仅剩余旧子节点-删除多余节点" class="headerlink" title="仅剩余旧子节点-删除多余节点"></a>仅剩余旧子节点-删除多余节点</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">patchKeyedChildren</span> = (<span class="params">c1, c2, container, parentAnchor, parentComponent, parentSuspense, isSVG, optimized</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span></span><br><span class="line">  <span class="keyword">const</span> l2 = c2.<span class="property">length</span></span><br><span class="line">  <span class="comment">// 旧子节点的尾部索引</span></span><br><span class="line">  <span class="keyword">let</span> e1 = c1.<span class="property">length</span> - <span class="number">1</span></span><br><span class="line">  <span class="comment">// 新子节点的尾部索引</span></span><br><span class="line">  <span class="keyword">let</span> e2 = l2 - <span class="number">1</span></span><br><span class="line">  <span class="comment">// 1. 从头部开始同步</span></span><br><span class="line">  <span class="comment">// i = 0, e1 = 4, e2 = 3</span></span><br><span class="line">  <span class="comment">// (a b) c d e</span></span><br><span class="line">  <span class="comment">// (a b) d e</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// 2. 从尾部开始同步</span></span><br><span class="line">  <span class="comment">// i = 2, e1 = 4, e2 = 3</span></span><br><span class="line">  <span class="comment">// (a b) c (d e)</span></span><br><span class="line">  <span class="comment">// (a b) (d e)</span></span><br><span class="line">  <span class="comment">// 3. 普通序列挂载剩余的新节点</span></span><br><span class="line">  <span class="comment">// i = 2, e1 = 2, e2 = 1</span></span><br><span class="line">  <span class="comment">// 不满足</span></span><br><span class="line">  <span class="keyword">if</span> (i &gt; e1) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 4. 普通序列删除多余的旧节点</span></span><br><span class="line">  <span class="comment">// i = 2, e1 = 2, e2 = 1</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (i &gt; e2) &#123;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= e1) &#123;</span><br><span class="line">      <span class="comment">// 删除节点</span></span><br><span class="line">      <span class="title function_">unmount</span>(c1[i], parentComponent, parentSuspense, <span class="literal">true</span>)</span><br><span class="line">      i++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果索引 i 大于尾部索引 e2（新子节点都没有了且旧子节点都还有剩余），那么从索引 i 开始到索引 e1 之间，<strong>我们直接删除旧子树这部分的节点</strong>。</p>
<p><img src="/images/diff-vue-react/1716199296806.png" alt="1716199296806"></p>
<p>删除完 c 节点后，旧子节点的 DOM 和新子节点对应的 vnode 映射一致，也就完成了更新。</p>
<p><font color="red"><strong>中途总结：3 和 4 步的前提是基于新子节点或旧子节点有一方已经没有了（临近边界值情况下），直接挂载或卸载剩余节点。</strong> </font></p>
<p>但是呢，如果两者都有剩余子序列，就需要进行最后一步了。</p>
<h4 id="处理未知子序列"><a href="#处理未知子序列" class="headerlink" title="处理未知子序列"></a>处理未知子序列</h4><p>假设遇到这种情况：</p>
<p><img src="/images/diff-vue-react/1716199809171.png" alt="1716199809171"></p>
<h5 id="正序遍历新子序列-建立索引图"><a href="#正序遍历新子序列-建立索引图" class="headerlink" title="正序遍历新子序列-建立索引图"></a>正序遍历新子序列-建立索引图</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">patchKeyedChildren</span> = (<span class="params">c1, c2, container, parentAnchor, parentComponent, parentSuspense, isSVG, optimized</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span></span><br><span class="line">  <span class="keyword">const</span> l2 = c2.<span class="property">length</span></span><br><span class="line">  <span class="comment">// 旧子节点的尾部索引</span></span><br><span class="line">  <span class="keyword">let</span> e1 = c1.<span class="property">length</span> - <span class="number">1</span></span><br><span class="line">  <span class="comment">// 新子节点的尾部索引</span></span><br><span class="line">  <span class="keyword">let</span> e2 = l2 - <span class="number">1</span></span><br><span class="line">  <span class="comment">// 1. 从头部开始同步</span></span><br><span class="line">  <span class="comment">// i = 0, e1 = 7, e2 = 7</span></span><br><span class="line">  <span class="comment">// (a b) c d e f g h</span></span><br><span class="line">  <span class="comment">// (a b) e c d i g h</span></span><br><span class="line">  <span class="comment">// 2. 从尾部开始同步</span></span><br><span class="line">  <span class="comment">// i = 2, e1 = 7, e2 = 7</span></span><br><span class="line">  <span class="comment">// (a b) c d e f (g h)</span></span><br><span class="line">  <span class="comment">// (a b) e c d i (g h)</span></span><br><span class="line">  <span class="comment">// 3. 普通序列挂载剩余的新节点， 不满足</span></span><br><span class="line">  <span class="comment">// 4. 普通序列删除多余的旧节点，不满足</span></span><br><span class="line">  <span class="comment">// i = 2, e1 = 4, e2 = 5</span></span><br><span class="line">  <span class="comment">// 旧子序列开始索引，从 i 开始记录</span></span><br><span class="line">  <span class="keyword">const</span> s1 = i</span><br><span class="line">  <span class="comment">// 新子序列开始索引，从 i 开始记录</span></span><br><span class="line">  <span class="keyword">const</span> s2 = i <span class="comment">//</span></span><br><span class="line">  <span class="comment">// 5.1 根据 key 建立新子序列的索引图</span></span><br><span class="line">  <span class="keyword">const</span> keyToNewIndexMap = <span class="keyword">new</span> <span class="title class_">Map</span>()</span><br><span class="line">  <span class="keyword">for</span> (i = s2; i &lt;= e2; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> nextChild = c2[i]</span><br><span class="line">    keyToNewIndexMap.<span class="title function_">set</span>(nextChild.<span class="property">key</span>, i)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>新旧子序列是从 i 开始的，所以我们先用 s1、s2 分别作为新旧子序列的开始索引，接着建立一个 keyToNewIndexMap 的 Map&lt;key, index&gt; 结构，遍历新子序列，把节点的 key 和 index 添加到这个 Map 中，注意我们这里假设所有节点都是有 key 标识的。</p>
<p>keyToNewIndexMap 存储的就是新子序列中每个节点在新子序列中的索引，我们来看一下示例处理后的结果，如下图所示：</p>
<p><img src="/images/diff-vue-react/1716200036280.png" alt="1716200036280"></p>
<h5 id="正序遍历旧子序列-更新和移除旧节点"><a href="#正序遍历旧子序列-更新和移除旧节点" class="headerlink" title="正序遍历旧子序列-更新和移除旧节点"></a>正序遍历旧子序列-更新和移除旧节点</h5><p><strong>接下来，我们就需要遍历旧子序列，有相同的节点就通过 patch 更新，并且移除那些不在新子序列中的节点，同时找出是否有需要移动的节点，</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">patchKeyedChildren</span> = (<span class="params">c1, c2, container, parentAnchor, parentComponent, parentSuspense, isSVG, optimized</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span></span><br><span class="line">  <span class="keyword">const</span> l2 = c2.<span class="property">length</span></span><br><span class="line">  <span class="comment">// 旧子节点的尾部索引</span></span><br><span class="line">  <span class="keyword">let</span> e1 = c1.<span class="property">length</span> - <span class="number">1</span></span><br><span class="line">  <span class="comment">// 新子节点的尾部索引</span></span><br><span class="line">  <span class="keyword">let</span> e2 = l2 - <span class="number">1</span></span><br><span class="line">  <span class="comment">// 1. 从头部开始同步</span></span><br><span class="line">  <span class="comment">// i = 0, e1 = 7, e2 = 7</span></span><br><span class="line">  <span class="comment">// (a b) c d e f g h</span></span><br><span class="line">  <span class="comment">// (a b) e c d i g h</span></span><br><span class="line">  <span class="comment">// 2. 从尾部开始同步</span></span><br><span class="line">  <span class="comment">// i = 2, e1 = 7, e2 = 7</span></span><br><span class="line">  <span class="comment">// (a b) c d e f (g h)</span></span><br><span class="line">  <span class="comment">// (a b) e c d i (g h)</span></span><br><span class="line">  <span class="comment">// 3. 普通序列挂载剩余的新节点，不满足</span></span><br><span class="line">  <span class="comment">// 4. 普通序列删除多余的旧节点，不满足</span></span><br><span class="line">  <span class="comment">// i = 2, e1 = 4, e2 = 5</span></span><br><span class="line">  <span class="comment">// 旧子序列开始索引，从 i 开始记录</span></span><br><span class="line">  <span class="keyword">const</span> s1 = i</span><br><span class="line">  <span class="comment">// 新子序列始索引，从 i 开始记录</span></span><br><span class="line">  <span class="keyword">const</span> s2 = i</span><br><span class="line">  <span class="comment">// 5.1 根据 key 建立新子序列的索引图</span></span><br><span class="line">  <span class="comment">// 5.2 正序遍历旧子序列，找到匹配的节点更新，删除不在新子序列中的节点，判断是否有移动节点</span></span><br><span class="line">  <span class="comment">// 新子序列已更新节点的数量</span></span><br><span class="line">  <span class="keyword">let</span> patched = <span class="number">0</span></span><br><span class="line">  <span class="comment">// 新子序列待更新节点的数量，等于新子序列的长度</span></span><br><span class="line">  <span class="keyword">const</span> toBePatched = e2 - s2 + <span class="number">1</span></span><br><span class="line">  <span class="comment">// 是否存在要移动的节点</span></span><br><span class="line">  <span class="keyword">let</span> moved = <span class="literal">false</span></span><br><span class="line">  <span class="comment">// 用于跟踪判断是否有节点移动</span></span><br><span class="line">  <span class="keyword">let</span> maxNewIndexSoFar = <span class="number">0</span></span><br><span class="line">  <span class="comment">// 这个数组存储新子序列中的元素在旧子序列节点的索引，用于确定最长递增子序列</span></span><br><span class="line">  <span class="keyword">const</span> newIndexToOldIndexMap = <span class="keyword">new</span> <span class="title class_">Array</span>(toBePatched)</span><br><span class="line">  <span class="comment">// 初始化数组，每个元素的值都是 0</span></span><br><span class="line">  <span class="comment">// 0 是一个特殊的值，如果遍历完了仍有元素的值为 0，则说明这个新节点没有对应的旧节点</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; toBePatched; i++)</span><br><span class="line">    newIndexToOldIndexMap[i] = <span class="number">0</span></span><br><span class="line">  <span class="comment">// 正序遍历旧子序列</span></span><br><span class="line">  <span class="keyword">for</span> (i = s1; i &lt;= e1; i++) &#123;</span><br><span class="line">    <span class="comment">// 拿到每一个旧子序列节点</span></span><br><span class="line">    <span class="keyword">const</span> prevChild = c1[i]</span><br><span class="line">    <span class="keyword">if</span> (patched &gt;= toBePatched) &#123;</span><br><span class="line">      <span class="comment">// 所有新的子序列节点都已经更新，剩余的节点删除</span></span><br><span class="line">      <span class="title function_">unmount</span>(prevChild, parentComponent, parentSuspense, <span class="literal">true</span>)</span><br><span class="line">      <span class="keyword">continue</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 查找旧子序列中的节点在新子序列中的索引</span></span><br><span class="line">    <span class="keyword">let</span> newIndex = keyToNewIndexMap.<span class="title function_">get</span>(prevChild.<span class="property">key</span>)</span><br><span class="line">    <span class="keyword">if</span> (newIndex === <span class="literal">undefined</span>) &#123;</span><br><span class="line">      <span class="comment">// 找不到说明旧子序列已经不存在于新子序列中，则删除该节点</span></span><br><span class="line">      <span class="title function_">unmount</span>(prevChild, parentComponent, parentSuspense, <span class="literal">true</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 更新新子序列中的元素在旧子序列中的索引，这里加 1 偏移，是为了避免 i 为 0 的特殊情况，影响对后续最长递增子序列的求解</span></span><br><span class="line">      newIndexToOldIndexMap[newIndex - s2] = i + <span class="number">1</span></span><br><span class="line">      <span class="comment">// maxNewIndexSoFar 始终存储的是上次求值的 newIndex，如果不是一直递增，则说明有移动</span></span><br><span class="line">      <span class="keyword">if</span> (newIndex &gt;= maxNewIndexSoFar) &#123;</span><br><span class="line">        maxNewIndexSoFar = newIndex</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        moved = <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 更新新旧子序列中匹配的节点</span></span><br><span class="line">      <span class="title function_">patch</span>(prevChild, c2[newIndex], container, <span class="literal">null</span>, parentComponent, parentSuspense, isSVG, optimized)</span><br><span class="line">      patched++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>建立了一个 newIndexToOldIndexMap 的数组，来存储新子序列节点的索引和旧子序列节点的索引之间的映射关系，用于确定最长递增子序列，这个数组的长度为新子序列的长度，每个元素的初始值设为 0， 它是一个特殊的值，如果遍历完了仍有元素的值为 0，则说明遍历旧子序列的过程中没有处理过这个节点，这个节点是新添加的。</p>
<p>下面我们说说具体的操作过程：<strong>正序遍历旧子序列，根据前面建立的 keyToNewIndexMap 查找旧子序列中的节点在新子序列中的索引，如果找不到就说明新子序列中没有该节点，就删除它；如果找得到则将它在旧子序列中的索引更新到 newIndexToOldIndexMap 中。</strong></p>
<p>注意这里索引加了长度为 1 的偏移，是为了应对 i 为 0 的特殊情况，如果不这样处理就会影响后续求解最长递增子序列。</p>
<p>遍历过程中，我们用变量 maxNewIndexSoFar 跟踪判断节点是否移动，maxNewIndexSoFar 始终存储的是上次求值的 newIndex，一旦本次求值的 newIndex 小于 maxNewIndexSoFar，这说明顺序遍历旧子序列的节点在新子序列中的索引并不是一直递增的，<strong>也就说明存在移动的情况</strong>。</p>
<p>除此之外，这个过程中我们也会更新新旧子序列中匹配的节点，另外如果所有新的子序列节点都已经更新，而对旧子序列遍历还未结束，说明剩余的节点就是多余的，删除即可。</p>
<p><strong>至此，我们完成了新旧子序列节点的更新、多余旧节点的删除，并且建立了一个 newIndexToOldIndexMap 存储新子序列节点的索引和旧子序列节点的索引之间的映射关系，并确定是否有移动</strong>。</p>
<p><img src="/images/diff-vue-react/1716200275355.png" alt="1716200275355"></p>
<p>可以看到， c、d、e 节点被更新，f 节点被删除，newIndexToOldIndexMap 的值为 [5, 3, 4 ,0]，此时 moved 也为 true，也就是存在节点移动的情况。</p>
<h5 id="倒序遍历新子序列-移动和挂载新节点"><a href="#倒序遍历新子序列-移动和挂载新节点" class="headerlink" title="倒序遍历新子序列-移动和挂载新节点"></a>倒序遍历新子序列-移动和挂载新节点</h5><p>接下来，就到了处理未知子序列的最后一个流程，移动和挂载新节点，我们来看一下这部分逻辑的实现：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">patchKeyedChildren</span> = (<span class="params">c1, c2, container, parentAnchor, parentComponent, parentSuspense, isSVG, optimized</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span></span><br><span class="line">  <span class="keyword">const</span> l2 = c2.<span class="property">length</span></span><br><span class="line">  <span class="comment">// 旧子节点的尾部索引</span></span><br><span class="line">  <span class="keyword">let</span> e1 = c1.<span class="property">length</span> - <span class="number">1</span></span><br><span class="line">  <span class="comment">// 新子节点的尾部索引</span></span><br><span class="line">  <span class="keyword">let</span> e2 = l2 - <span class="number">1</span></span><br><span class="line">  <span class="comment">// 1. 从头部开始同步</span></span><br><span class="line">  <span class="comment">// i = 0, e1 = 6, e2 = 7</span></span><br><span class="line">  <span class="comment">// (a b) c d e f g</span></span><br><span class="line">  <span class="comment">// (a b) e c d h f g</span></span><br><span class="line">  <span class="comment">// 2. 从尾部开始同步</span></span><br><span class="line">  <span class="comment">// i = 2, e1 = 6, e2 = 7</span></span><br><span class="line">  <span class="comment">// (a b) c (d e)</span></span><br><span class="line">  <span class="comment">// (a b) (d e)</span></span><br><span class="line">  <span class="comment">// 3. 普通序列挂载剩余的新节点， 不满足</span></span><br><span class="line">  <span class="comment">// 4. 普通序列删除多余的节点，不满足</span></span><br><span class="line">  <span class="comment">// i = 2, e1 = 4, e2 = 5</span></span><br><span class="line">  <span class="comment">// 旧子节点开始索引，从 i 开始记录</span></span><br><span class="line">  <span class="keyword">const</span> s1 = i</span><br><span class="line">  <span class="comment">// 新子节点开始索引，从 i 开始记录</span></span><br><span class="line">  <span class="keyword">const</span> s2 = i <span class="comment">//</span></span><br><span class="line">  <span class="comment">// 5.1 根据 key 建立新子序列的索引图</span></span><br><span class="line">  <span class="comment">// 5.2 正序遍历旧子序列，找到匹配的节点更新，删除不在新子序列中的节点，判断是否有移动节点</span></span><br><span class="line">  <span class="comment">// 5.3 倒序的方式遍历新子序列，移动和挂载新节点</span></span><br><span class="line">  <span class="comment">// 仅当节点移动时生成最长递增子序列</span></span><br><span class="line">  <span class="keyword">const</span> increasingNewIndexSequence = moved</span><br><span class="line">    ? <span class="title function_">getSequence</span>(newIndexToOldIndexMap)</span><br><span class="line">    : <span class="variable constant_">EMPTY_ARR</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> j = increasingNewIndexSequence.<span class="property">length</span> - <span class="number">1</span></span><br><span class="line">  <span class="comment">// 倒序遍历以便我们可以使用最后更新的节点作为锚点</span></span><br><span class="line">  <span class="keyword">for</span> (i = toBePatched - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="keyword">const</span> nextIndex = s2 + i</span><br><span class="line">    <span class="keyword">const</span> nextChild = c2[nextIndex]</span><br><span class="line">    <span class="comment">// 锚点指向上一个更新的节点，如果 nextIndex 超过新子节点的长度，则指向 parentAnchor</span></span><br><span class="line">    <span class="keyword">const</span> anchor = nextIndex + <span class="number">1</span> &lt; l2 ? c2[nextIndex + <span class="number">1</span>].<span class="property">el</span> : parentAnchor</span><br><span class="line">    <span class="keyword">if</span> (newIndexToOldIndexMap[i] === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 挂载新的子节点</span></span><br><span class="line">      <span class="title function_">patch</span>(<span class="literal">null</span>, nextChild, container, anchor, parentComponent, parentSuspense, isSVG)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (moved) &#123;</span><br><span class="line">      <span class="comment">// 没有最长递增子序列（reverse 的场景）或者当前的节点索引不在最长递增子序列中，需要移动</span></span><br><span class="line">      <span class="keyword">if</span> (j &lt; <span class="number">0</span> || i !== increasingNewIndexSequence[j]) &#123;</span><br><span class="line">        <span class="title function_">move</span>(nextChild, container, anchor, <span class="number">2</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 倒序递增子序列</span></span><br><span class="line">        j--</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们前面已经判断了是否移动，<strong>如果 moved 为 true 就通过 getSequence(newIndexToOldIndexMap) 计算最长递增子序列</strong>，这部分算法我会放在后文详细介绍。</p>
<p>接着我们采用<strong>倒序的方式遍历新子序列，因为倒序遍历可以方便我们使用最后更新的节点作为锚点</strong>。在倒序的过程中，锚点指向上一个更新的节点，然后判断 newIndexToOldIndexMap[i] 是否为 0，如果是则表示这是新节点，就需要挂载它；接着判断是否存在节点移动的情况，如果存在的话则看节点的索引是不是在最长递增子序列中，如果在则倒序最长递增子序列，否则把它移动到锚点的前面。</p>
<p>为了便于你更直观地理解，我们用前面的例子展示一下这个过程，此时 toBePatched 的值为 4，j 的值为 1，最长递增子序列 increasingNewIndexSequence 的值是 [1, 2]。在倒序新子序列的过程中，首先遇到节点 i，发现它在 newIndexToOldIndexMap 中的值是 0，则说明它是新节点，我们需要挂载它；然后继续遍历遇到节点 d，因为 moved 为 true，且 d 的索引存在于最长递增子序列中，则执行 j– 倒序最长递增子序列，j 此时为 0；接着继续遍历遇到节点 c，它和 d 一样，索引也存在于最长递增子序列中，则执行 j–，j 此时为 -1；接着继续遍历遇到节点 e，此时 j 是 -1 并且 e 的索引也不在最长递增子序列中，所以做一次移动操作，把 e 节点移到上一个更新的节点，也就是 c 节点的前面。</p>
<p>新子序列倒序完成，即完成了新节点的插入和旧节点的移动操作，也就完成了整个核心 diff 算法对节点的更新。</p>
<p><img src="/images/diff-vue-react/1716200731849.png" alt="1716200731849"></p>
<p>可以看到新子序列中的新节点 i 被挂载，旧子序列中的节点 e 移动到了 c 节点前面，至此，我们就在已知旧子节点 DOM 结构和 vnode、新子节点 vnode 的情况下，求解出生成新子节点的 DOM 的更新、移动、删除、新增等系列操作，并且以一种较小成本的方式完成 DOM 更新。</p>
<p>我们知道了子节点更新调用的是 patch 方法， Vue.js 正是通过这种递归的方式完成了整个组件树的更新。</p>
<p><strong>总结：第五步的主要步骤</strong>：</p>
<ul>
<li>根据 key 建立新子序列的索引图</li>
<li>正序遍历旧子序列，找到匹配的节点更新，删除不在新子序列中的节点，判断是否有移动节点</li>
<li>倒序遍历新子序列，移动和挂载新节点</li>
</ul>
<h3 id="非核心算法"><a href="#非核心算法" class="headerlink" title="非核心算法"></a>非核心算法</h3><p><code>patchUnkeyedChildren</code> 是基于没有标记 key 的子节点 diff，我们来分析一下它的实现。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">patchUnkeyedChildren</span> = (<span class="params"></span></span><br><span class="line"><span class="params">  c1: VNode[],</span></span><br><span class="line"><span class="params">  c2: VNodeArrayChildren,</span></span><br><span class="line"><span class="params">  container: RendererElement,</span></span><br><span class="line"><span class="params">  anchor: RendererNode | <span class="literal">null</span>,</span></span><br><span class="line"><span class="params">  parentComponent: ComponentInternalInstance | <span class="literal">null</span>,</span></span><br><span class="line"><span class="params">  parentSuspense: SuspenseBoundary | <span class="literal">null</span>,</span></span><br><span class="line"><span class="params">  namespace: ElementNamespace,</span></span><br><span class="line"><span class="params">  slotScopeIds: string[] | <span class="literal">null</span>,</span></span><br><span class="line"><span class="params">  optimized: boolean,</span></span><br><span class="line"><span class="params"></span>) =&gt; &#123;</span><br><span class="line">  c1 = c1 || <span class="variable constant_">EMPTY_ARR</span></span><br><span class="line">  c2 = c2 || <span class="variable constant_">EMPTY_ARR</span></span><br><span class="line">  <span class="keyword">const</span> oldLength = c1.<span class="property">length</span></span><br><span class="line">  <span class="keyword">const</span> newLength = c2.<span class="property">length</span></span><br><span class="line">  <span class="keyword">const</span> commonLength = <span class="title class_">Math</span>.<span class="title function_">min</span>(oldLength, newLength)</span><br><span class="line">  <span class="keyword">let</span> i</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; commonLength; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> nextChild = (c2[i] = optimized</span><br><span class="line">      ? <span class="title function_">cloneIfMounted</span>(c2[i] <span class="keyword">as</span> <span class="title class_">VNode</span>)</span><br><span class="line">      : <span class="title function_">normalizeVNode</span>(c2[i]))</span><br><span class="line">    <span class="title function_">patch</span>(</span><br><span class="line">      c1[i],</span><br><span class="line">      nextChild,</span><br><span class="line">      container,</span><br><span class="line">      <span class="literal">null</span>,</span><br><span class="line">      parentComponent,</span><br><span class="line">      parentSuspense,</span><br><span class="line">      namespace,</span><br><span class="line">      slotScopeIds,</span><br><span class="line">      optimized,</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (oldLength &gt; newLength) &#123;</span><br><span class="line">    <span class="comment">// remove old</span></span><br><span class="line">    <span class="title function_">unmountChildren</span>(</span><br><span class="line">      c1,</span><br><span class="line">      parentComponent,</span><br><span class="line">      parentSuspense,</span><br><span class="line">      <span class="literal">true</span>,</span><br><span class="line">      <span class="literal">false</span>,</span><br><span class="line">      commonLength,</span><br><span class="line">    )</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// mount new</span></span><br><span class="line">    <span class="title function_">mountChildren</span>(</span><br><span class="line">      c2,</span><br><span class="line">      container,</span><br><span class="line">      anchor,</span><br><span class="line">      parentComponent,</span><br><span class="line">      parentSuspense,</span><br><span class="line">      namespace,</span><br><span class="line">      slotScopeIds,</span><br><span class="line">      optimized,</span><br><span class="line">      commonLength,</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现也是非常简单的，分三步：</p>
<ol>
<li>取最小公共长度，调用 patch 方法更新每个子节点；</li>
<li>删除旧子序列中多余的子节点；</li>
<li>挂载新子序列中新增的子节点。</li>
</ol>
<h3 id="番外篇"><a href="#番外篇" class="headerlink" title="番外篇"></a>番外篇</h3><h4 id="计算最长递增子序列"><a href="#计算最长递增子序列" class="headerlink" title="计算最长递增子序列"></a>计算最长递增子序列</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// https://en.wikipedia.org/wiki/Longest_increasing_subsequence</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getSequence</span>(<span class="params">arr: number[]</span>): number[] &#123;</span><br><span class="line">  <span class="keyword">const</span> p = arr.<span class="title function_">slice</span>()</span><br><span class="line">  <span class="keyword">const</span> result = [<span class="number">0</span>]</span><br><span class="line">  <span class="keyword">let</span> i, j, u, v, c</span><br><span class="line">  <span class="keyword">const</span> len = arr.<span class="property">length</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> arrI = arr[i]</span><br><span class="line">    <span class="keyword">if</span> (arrI !== <span class="number">0</span>) &#123;</span><br><span class="line">      j = result[result.<span class="property">length</span> - <span class="number">1</span>]</span><br><span class="line">      <span class="keyword">if</span> (arr[j] &lt; arrI) &#123;</span><br><span class="line">        <span class="comment">// 存储在 result 更新前的最后一个索引的值</span></span><br><span class="line">        p[i] = j</span><br><span class="line">        result.<span class="title function_">push</span>(i)</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">      &#125;</span><br><span class="line">      u = <span class="number">0</span></span><br><span class="line">      v = result.<span class="property">length</span> - <span class="number">1</span></span><br><span class="line">      <span class="comment">// 二分搜索，查找比 arrI 小的节点，更新 result 的值</span></span><br><span class="line">      <span class="keyword">while</span> (u &lt; v) &#123;</span><br><span class="line">        c = (u + v) &gt;&gt; <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> (arr[result[c]] &lt; arrI) &#123;</span><br><span class="line">          u = c + <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          v = c</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (arrI &lt; arr[result[u]]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (u &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          p[i] = result[u - <span class="number">1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">        result[u] = i</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  u = result.<span class="property">length</span></span><br><span class="line">  v = result[u - <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 回溯数组 p，找到最终的索引</span></span><br><span class="line">  <span class="keyword">while</span> (u-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    result[u] = v</span><br><span class="line">    v = p[v]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://zeuscoder.github.io/2023/10/04/vue3-diff/" data-id="clweu6lch0000tpc90brs23m5" class="article-share-link">
        分享
      </a>
      
    </footer>

  </div>

  
  
<nav class="article-nav">
  
  <a href="/2024/01/04/web-chrome-devtool/" class="article-nav-link">
    <strong class="article-nav-caption">前一篇</strong>
    <div class="article-nav-title">
      
      Web：前端提效工具集合
      
    </div>
  </a>
  
  
  <a href="/2023/10/02/vue2-diff/" class="article-nav-link">
    <strong class="article-nav-caption">后一篇</strong>
    <div class="article-nav-title">vue2-diff</div>
  </a>
  
</nav>

  

  
  
  
  

</article>
</section>
    <footer class="footer">
  <div class="outer">
    <div class="float-right">
      <ul class="list-inline">
  
  <li><i class="fe fe-smile-alt"></i> <span id="busuanzi_value_site_uv"></span></li>
  
  <li><i class="fe fe-bookmark"></i> <span id="busuanzi_value_page_pv"></span></li>
  
</ul>
    </div>
    <ul class="list-inline">
      <li>zeus の blog &copy; 2024</li>
      
        <li></li>
      
      <li>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></li>
      <li>theme  <a href="https://github.com/zhwangart/hexo-theme-ocean">Ocean</a></li>
    </ul>
  </div>
</footer>
  </main>
  <aside class="sidebar">
    <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/zeus.png" alt="zeus の blog"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/gallery">相册</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">关于</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link nav-item-search" title="搜索">
        <i class="fe fe-search"></i>
        搜索
      </a>
    </li>
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      <div class="totop" id="totop">
  <i class="fe fe-rocket"></i>
</div>
    </li>
    <li class="nav-item">
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="fe fe-feed"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
  </aside>
  
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/jquery.justifiedGallery.min.js"></script>


<script src="/js/lazyload.min.js"></script>


<script src="/js/busuanzi-2.3.pure.min.js"></script>



<script src="/js/wrapImage.js"></script>


<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/copybtn.js"></script>





<script src="/js/tocbot.min.js"></script>

<script>
  // Tocbot_v4.7.0  http://tscanlin.github.io/tocbot/
  tocbot.init({
    tocSelector: '.tocbot',
    contentSelector: '.article-entry',
    headingSelector: 'h1, h2, h3, h4, h5, h6',
    hasInnerContainers: true,
    scrollSmooth: true,
    positionFixedSelector: '.tocbot',
    positionFixedClass: 'is-position-fixed',
    fixedSidebarOffset: 'auto',
  });
</script>



<script src="/js/ocean.js"></script>

</body>

</html>