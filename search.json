[{"title":"SSE：基础用法","url":"/2024/03/20/sse-problem/","content":"\n\n使用 `chatgpt` 提问后，答案逐字返回出现，其中背后的原理就涉及 SSE 连接机制了。\n\n<!-- more -->\n\n### 基础用法\n\n![Can I Use](/images/sse-problem/sse-caniuse.png)\n\n#### 客户端\n\n除了 IE 浏览器不能用，基本无坑。使用方法简易，具体可参考 [MDN EventSource](https://developer.mozilla.org/zh-CN/docs/Web/API/EventSource)。\n\n```JavaScript\nconst evtSource = new EventSource(\"/sse\");\n\nevtSource.onmessage = (e) => {\n    console.log(`message: ${e.data}`);\n};\n```\n\n#### 服务端\n\n采用 express.js 实现一个 nodejs 后端服务：\n\n```JavaScript\nconst express = require('express');\nconst cors = require('cors');\n\nconst app = express();\nconst port = 3000;\n\napp.use(cors());\n\napp.get('/sse', (req, res) => {\n    res.set({\n        'Content-Type': 'text/event-stream',\n        'Connection': 'keep-alive',\n        'Cache-Control': 'no-cache, no-transform',\n        'X-Accel-Buffering': 'no'\n    });\n\n    res.flushHeaders();\n\n    setInterval(() => {\n        const data = {\n            message: `Current time is ${new Date().toLocaleTimeString()}`\n        };\n\n        res.write(`data: ${JSON.stringify(data)}\\n\\n`);\n    }, 1000);\n});\n\n\napp.listen(port, () => {\n  console.log(`Server started on port ${port}`);\n});\n```\n\n\n### 问题记录\n\n#### 浏览器接收后端数据延迟的问题\n\n背景：前端通过 `EventSource` 连接后端时，后端会立即响应并返回数据，且在服务器上也打印出日志，但是浏览器的接口状态一直处于 `pending` 且 `EventStream` 无任何数据响应。在等待几分钟（差不多5分钟）后，**浏览器才一次性接收到所有数据**。\n\n关键：是浏览器接收不到数据流，排除了后端连不上或者断开连接的可能。\n\n解决方法：\n\nHTTP 响应头需要添加以下字段：\n\n```Shell\nContent-Type: text/event-stream\nCache-Control: no-cache, no-transform\nConnection: keep-alive\nX-Accel-Buffering: no\n```\n\n- `Cache-Control` 中需要包含 `no-transform`，开发时，如果使用了 `create-react-app` 等工具来转发请求，数据流很可能被压缩（检查 proxy 的 compress 配置是否为 true），造成怎么也收不到响应。[issue](https://github.com/facebook/create-react-app/issues/1633)\n\n- `no-transform` 是开发环境中的遇到的问题，但是在生产环境仍然还存在问题。\n\n- 如果网站使用 `nginx` 做反向代理的，默认会对应用的响应做缓冲(buffering)，以至于应用返回的消息没有立马发出去。所以我们需要给http头加上一条 X`-Accel-Buffering: no `。[issue](https://serverfault.com/questions/801628/for-server-sent-events-sse-what-nginx-proxy-configuration-is-appropriate)\n\nNginx 配置：\n\n```Nginx\nserver {\n  proxy_buffering off;\n  proxy_cache off;\n  proxy_pass_header X-Accel-Buffering;\n}\n```\n\n排查过程不详述了，一句话总结，**防止对数据流进行压缩或缓存**。\n\n参考文章：\n\n[EventSource](https://developer.mozilla.org/zh-CN/docs/Web/API/EventSource)\n\n[Server-Sent Events 教程](https://www.ruanyifeng.com/blog/2017/05/server-sent_events.html)\n\n[server-side-events(SSE)开发指南（Node）](https://zhuanlan.zhihu.com/p/47099953)"},{"title":"WEB：一次偶然的依赖库安全问题","url":"/2024/01/29/safe-problem/","content":"背景：在大型企业部署应用后，多数会对系统进行安全扫描，至少需要处理高等级和中等级问题。\n\n<!-- more -->\n\n项目：该项目是基于 `vue-cli` 创建的 `vue2` 前端项目。\n\n问题：扫描结果中有多个依赖的版本过低，存在安全问题，**需要通过升级这些依赖的版本**，从而解决问题。\n\n解决思路：\n\n* 1：扫描的依赖都属于深层依赖，是来源于 `package-lock.json` 的，而不是 `package.json`，无法直接通过修改依赖版本。\n* 2：仔细发现扫描出来有问题的依赖都属于构建工具，都是跟 `webpack` 相关，**而通过验证后 `webpack5` 的相关版本都得到了升级**，且满足安全要求。\n* 3：项目本身是基于 `vue-cli` 创建的，webpack 也是包含在 `@vue/cli` 工具依赖库里面，**且只有最新版本 `@vue/cli` 5.0.8 版本才引用的是 `webpack5`**。\n* 4：本地升级 `@vue/cli` 工具版本，创建新项目，并移植 `package-lock.json` 的相关依赖。\n\n总结：通过升级 `@vue/cli` 最新版本，从而带动 `webpack` 升级为 `webpack5`，曲折地升级所有有问题的依赖版本。\n\nPS：这是一次比较取巧的方案，要是死磕 `package-lock.json` 也可能得不到什么比较好且方便的方案。\n"},{"title":"WEB：常见的安全问题","url":"/2024/01/09/security/","content":"本文涉及公司内部镜像安全问题。\n\n<!-- more -->\n\n### 镜像版本安全问题\n\n#### 问题分析\n\n根据 [DevOps：Docker 实操笔记](https://zeuscoder.github.io/2020/09/06/docker/) 一文中 [Vue-cli 项目部署 Dockerfile 实例](https://cli.vuejs.org/zh/guide/deployment.html#bitbucket-cloud)，前端项目会在构建镜像时分别用到了 `node` 和 `nginx` 镜像。\n\n由于不同安全手段的测试，低版本镜像往往会检测出劫持漏洞问题，**但仅需要升级对应的版本即可**。\n\n#### 本地推送 docker 镜像到内部仓库\n\n由于公司可能采用的是内部镜像仓库，往往需要手动推送合适的 docker 镜像到内部仓库。\n\n假设公司镜像仓库地址：registry.zeuscoder.com\n\n以推送不同版本 node 的 docker 镜像为例：\n\n```shell\n# 本地打开终端（确认本地已安装且开启 docker）：\ndocker login --username=[自己的账号] registry.zeuscoder.com\n \n# 输入密码：自己的密码\n \n# 从 dockerhub 拉取对应镜像：\ndocker push node:[镜像版本号]\n \n# 获取镜像 imageId：\ndocker images ｜ grep node:[镜像版本号]\n \n# 本地打 tag：\ndocker tag [ImageId]  registry.zeuscoder.com/library/node:[镜像版本号]\n \n# 推送到仓库：\ndocker push registry.zeuscoder.com/library/node:[镜像版本号]\n```\n"},{"title":"Web：前端提效工具集合","url":"/2024/01/04/web-chrome-devtool/","content":"工欲善其事，必先利其器。一款好的插件往往可以让你事半功倍。\n\n<!-- more -->\n\n## Chrome 插件\n\n| 插件                  | 功能                   |\n| :-------------------- | :--------------------- |\n| FEHelper              | Web 前端助手           |\n| EditCookie            | 操作 cookie 的插件     |\n| Vue DevTools          | Vue 开发工具，调试必备 |\n| React Developer Tools | React 开发工具         |\n| Axure RP              | 在线查看网页原型       |\n| AdBlock               | 广告屏蔽插件           |\n| Google翻译            |                        |\n| tampermonkey          |                        |\n| GoFullPage            | 网页截屏 长屏截图      |\n| 沉浸式翻译            | 很好用的网页翻译       |\n\n## VSCode 插件\n\n| 插件                | 功能                                             |\n| :------------------ | :----------------------------------------------- |\n| Vetur               | Vue 工具                                         |\n| Prettier            | 美化你的 JavaScript/TypeScript/CSS 代码          |\n| Trailing Spaces     | 高亮那些冗余的空格，可以快速删掉                 |\n| npm Intellisense    | 可以在导入语句自动补全npm模块名称                |\n| GitLens             |                                                  |\n| Git Project Manager |                                                  |\n| Git History         |                                                  |\n| Live Server         | 本地起 http server，避免加载本地资源跨越的的问题 |\n| codegeex            | AI 工具                                          |\n\n## npm 工具\n\n| 插件        | 功能                                       |\n| :---------- | :----------------------------------------- |\n| n           | Node.js version management                 |\n| nrm         | NPM registry manager                       |\n| http-server | 为静态资源启动服务                         |\n| depcheck    | 分析项目 package.json 中有哪些未使用的依赖 |\n\n## 资料网站\n\n| 插件                                        | 功能                                                                                                                                                                                                                                                                                                          |\n| :------------------------------------------ | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| https://docschina.org/                      | 中文官网集合                                                                                                                                                                                                                                                                                                  |\n| https://docschina.org/                      | Web前端导航                                                                                                                                                                                                                                                                                                   |\n| https://mock.mengxuegu.com/                 | 在线mock工具                                                                                                                                                                                                                                                                                                  |\n| http://bbs.laoleng.vip/reference/index.html | 为开发人员分享快速参考备忘清单【速查表】。这是英文版 Reference 的中文版本，目的是为了方便自己的技术栈查阅，如果您提供一个清单，我将抽空搬运，立即撸起来 :)。如果您发现此处的备忘单不合适，您可以通过提交 PR 来修复它或提供更好的备忘清单，只针对【中文】用户。以下是开源天使提供的一些备忘清单和快速参考 :)。 |\n"},{"title":"vue3-diff","url":"/2023/10/04/vue3-diff/","content":"Vue3 diff 算法与 Vue2 相比，最大的不同就是**不再使用双端比较算法**，而是**使用最长递增子序列算法**。\n\n> 最长递增子序列（Longest Increasing Subsequence，LIS）问题，是算法中经典的动态规划问题。\n\n<!-- more -->\n\n在 Vue 3.x 版本中，编译时做了不少优化，为 `patch` 函数提供了便利。\n\n### 核心算法\n\n**其中核心算法函数为 `patchKeyedChildren` 函数**，源码位于 `packages/runtime-core/src/renderer.ts`。\n\n<font color=red>**该函数分为 5 步，第 5 步又细分为 3 小步（复杂且关键），其中也包含了最长递增子序列的算法。**</font>\n\n> 前言：需要区分与 Vue2 不同的维护变量\n\n（希望第 2 遍看，只需要看图片和右侧标题，不需要看文字。）\n\n#### 同步头部节点\n\n```javascript\nconst patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, isSVG, optimized) => {\n  let i = 0\n  const l2 = c2.length\n  // 旧子节点的尾部索引\n  let e1 = c1.length - 1\n  // 新子节点的尾部索引\n  let e2 = l2 - 1\n  // 1. 从头部开始同步\n  // i = 0, e1 = 3, e2 = 4\n  // (a b) c d\n  // (a b) e c d\n  while (i <= e1 && i <= e2) {\n    const n1 = c1[i]\n    const n2 = c2[i]\n    if (isSameVNodeType(n1, n2)) {\n      // 相同的节点，递归执行 patch 更新节点\n      patch(n1, n2, container, parentAnchor, parentComponent, parentSuspense, isSVG, optimized)\n    }\n    else {\n      break\n    }\n    i++\n  }\n}\n\n```\n\ndiff 过程中需要维护的几个变量：**头部的索引 i（可以理解为新旧节点公共的首部索引）、旧子节点的尾部索引 e1和新子节点的尾部索引 e2**。\n\n同步头部节点就是从头部开始，依次对比新节点和旧节点，如果它们相同的则执行 patch 更新节点；如果不同或者索引 i 大于索引 e1 或者 e2，则同步过程结束。\n\n![1716197845396](/images/diff-vue-react/1716197845396.png)\n\n完成头部节点同步后：i 是 2，e1 是 3，e2 是 4。\n\n#### 同步尾部节点\n\n接着从尾部开始 **同步尾部节点** ，实现代码如下：\n\n```javascript\nconst patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, isSVG, optimized) => {\n  let i = 0\n  const l2 = c2.length\n  // 旧子节点的尾部索引\n  let e1 = c1.length - 1\n  // 新子节点的尾部索引\n  let e2 = l2 - 1\n  // 1. 从头部开始同步\n  // i = 0, e1 = 3, e2 = 4\n  // (a b) c d\n  // (a b) e c d\n  // 2. 从尾部开始同步\n  // i = 2, e1 = 3, e2 = 4\n  // (a b) (c d)\n  // (a b) e (c d)\n  while (i <= e1 && i <= e2) {\n    const n1 = c1[e1]\n    const n2 = c2[e2]\n    if (isSameVNodeType(n1, n2)) {\n      patch(n1, n2, container, parentAnchor, parentComponent, parentSuspense, isSVG, optimized)\n    }\n    else {\n      break\n    }\n    e1--\n    e2--\n  }\n}\n```\n\n同步尾部节点就是从尾部开始，依次对比新节点和旧节点，如果相同的则执行 patch 更新节点；如果不同或者索引 i 大于索引 e1 或者 e2，则同步过程结束。\n\n![1716198093362](/images/diff-vue-react/1716198093362.png)\n\n可以看到，完成尾部节点同步后：i 是 2，e1 是 1，e2 是 2。\n\n<font color=red>**中途总结：前面 2 步非常容易理解，就是先去头去尾，剩下新旧节点的中间部分。**</font>\n\n接下来只有 3 种情况要处理：\n\n* **旧子节点都没有了**，新子节点只有剩余要添加的新节点；\n* **新子节点都没有了**，旧子节点有剩余要删除的多余节点；\n* **新子节点和旧子节点都同时还有剩余节点**，未知子序列。\n\n#### 仅剩余新子节点-添加新的节点\n\n```javascript\nconst patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, isSVG, optimized) => {\n  let i = 0\n  const l2 = c2.length\n  // 旧子节点的尾部索引\n  let e1 = c1.length - 1\n  // 新子节点的尾部索引\n  let e2 = l2 - 1\n  // 1. 从头部开始同步\n  // i = 0, e1 = 3, e2 = 4\n  // (a b) c d\n  // (a b) e c d\n  // ...\n  // 2. 从尾部开始同步\n  // i = 2, e1 = 3, e2 = 4\n  // (a b) (c d)\n  // (a b) e (c d)\n  // 3. 挂载剩余的新节点\n  // i = 2, e1 = 1, e2 = 2\n  if (i > e1) {\n    if (i <= e2) {\n      const nextPos = e2 + 1\n      const anchor = nextPos < l2 ? c2[nextPos].el : parentAnchor\n      while (i <= e2) {\n        // 挂载新节点\n        patch(null, c2[i], container, anchor, parentComponent, parentSuspense, isSVG)\n     \t  i++\n      }\n    }\n  }\n}\n```\n\n如果索引 i 大于尾部索引 e1（旧子节点都没有了）且 i 小于 e2（新子节点都还有剩余），那么从索引 i 开始到索引 e2 之间，**我们直接挂载新子树这部分的节点**。\n\n![1716198948270](/images/diff-vue-react/1716198948270.png)\n\n添加完 e 节点后，旧子节点的 DOM 和新子节点对应的 vnode 映射一致，也就完成了更新。\n\n#### 仅剩余旧子节点-删除多余节点\n\n```javascript\nconst patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, isSVG, optimized) => {\n  let i = 0\n  const l2 = c2.length\n  // 旧子节点的尾部索引\n  let e1 = c1.length - 1\n  // 新子节点的尾部索引\n  let e2 = l2 - 1\n  // 1. 从头部开始同步\n  // i = 0, e1 = 4, e2 = 3\n  // (a b) c d e\n  // (a b) d e\n  // ...\n  // 2. 从尾部开始同步\n  // i = 2, e1 = 4, e2 = 3\n  // (a b) c (d e)\n  // (a b) (d e)\n  // 3. 普通序列挂载剩余的新节点\n  // i = 2, e1 = 2, e2 = 1\n  // 不满足\n  if (i > e1) {\n  }\n  // 4. 普通序列删除多余的旧节点\n  // i = 2, e1 = 2, e2 = 1\n  else if (i > e2) {\n    while (i <= e1) {\n      // 删除节点\n      unmount(c1[i], parentComponent, parentSuspense, true)\n      i++\n    }\n  }\n}\n\n```\n\n如果索引 i 大于尾部索引 e2（新子节点都没有了且旧子节点都还有剩余），那么从索引 i 开始到索引 e1 之间，**我们直接删除旧子树这部分的节点**。\n\n![1716199296806](/images/diff-vue-react/1716199296806.png)\n\n删除完 c 节点后，旧子节点的 DOM 和新子节点对应的 vnode 映射一致，也就完成了更新。\n\n<font color=red>**中途总结：3 和 4 步的前提是基于新子节点或旧子节点有一方已经没有了（临近边界值情况下），直接挂载或卸载剩余节点。** </font>\n\n但是呢，如果两者都有剩余子序列，就需要进行最后一步了。\n\n#### 处理未知子序列\n\n假设遇到这种情况：\n\n![1716199809171](/images/diff-vue-react/1716199809171.png)\n\n##### 正序遍历新子序列-建立索引图\n\n```javascript\nconst patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, isSVG, optimized) => {\n  let i = 0\n  const l2 = c2.length\n  // 旧子节点的尾部索引\n  let e1 = c1.length - 1\n  // 新子节点的尾部索引\n  let e2 = l2 - 1\n  // 1. 从头部开始同步\n  // i = 0, e1 = 7, e2 = 7\n  // (a b) c d e f g h\n  // (a b) e c d i g h\n  // 2. 从尾部开始同步\n  // i = 2, e1 = 7, e2 = 7\n  // (a b) c d e f (g h)\n  // (a b) e c d i (g h)\n  // 3. 普通序列挂载剩余的新节点， 不满足\n  // 4. 普通序列删除多余的旧节点，不满足\n  // i = 2, e1 = 4, e2 = 5\n  // 旧子序列开始索引，从 i 开始记录\n  const s1 = i\n  // 新子序列开始索引，从 i 开始记录\n  const s2 = i //\n  // 5.1 根据 key 建立新子序列的索引图\n  const keyToNewIndexMap = new Map()\n  for (i = s2; i <= e2; i++) {\n    const nextChild = c2[i]\n    keyToNewIndexMap.set(nextChild.key, i)\n  }\n}\n```\n\n新旧子序列是从 i 开始的，所以我们先用 s1、s2 分别作为新旧子序列的开始索引，接着建立一个 keyToNewIndexMap 的 Map<key, index> 结构，遍历新子序列，把节点的 key 和 index 添加到这个 Map 中，注意我们这里假设所有节点都是有 key 标识的。\n\nkeyToNewIndexMap 存储的就是新子序列中每个节点在新子序列中的索引，我们来看一下示例处理后的结果，如下图所示：\n\n![1716200036280](/images/diff-vue-react/1716200036280.png)\n\n##### 正序遍历旧子序列-更新和移除旧节点\n\n**接下来，我们就需要遍历旧子序列，有相同的节点就通过 patch 更新，并且移除那些不在新子序列中的节点，同时找出是否有需要移动的节点，**\n\n```javascript\nconst patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, isSVG, optimized) => {\n  let i = 0\n  const l2 = c2.length\n  // 旧子节点的尾部索引\n  let e1 = c1.length - 1\n  // 新子节点的尾部索引\n  let e2 = l2 - 1\n  // 1. 从头部开始同步\n  // i = 0, e1 = 7, e2 = 7\n  // (a b) c d e f g h\n  // (a b) e c d i g h\n  // 2. 从尾部开始同步\n  // i = 2, e1 = 7, e2 = 7\n  // (a b) c d e f (g h)\n  // (a b) e c d i (g h)\n  // 3. 普通序列挂载剩余的新节点，不满足\n  // 4. 普通序列删除多余的旧节点，不满足\n  // i = 2, e1 = 4, e2 = 5\n  // 旧子序列开始索引，从 i 开始记录\n  const s1 = i\n  // 新子序列始索引，从 i 开始记录\n  const s2 = i\n  // 5.1 根据 key 建立新子序列的索引图\n  // 5.2 正序遍历旧子序列，找到匹配的节点更新，删除不在新子序列中的节点，判断是否有移动节点\n  // 新子序列已更新节点的数量\n  let patched = 0\n  // 新子序列待更新节点的数量，等于新子序列的长度\n  const toBePatched = e2 - s2 + 1\n  // 是否存在要移动的节点\n  let moved = false\n  // 用于跟踪判断是否有节点移动\n  let maxNewIndexSoFar = 0\n  // 这个数组存储新子序列中的元素在旧子序列节点的索引，用于确定最长递增子序列\n  const newIndexToOldIndexMap = new Array(toBePatched)\n  // 初始化数组，每个元素的值都是 0\n  // 0 是一个特殊的值，如果遍历完了仍有元素的值为 0，则说明这个新节点没有对应的旧节点\n  for (i = 0; i < toBePatched; i++)\n    newIndexToOldIndexMap[i] = 0\n  // 正序遍历旧子序列\n  for (i = s1; i <= e1; i++) {\n    // 拿到每一个旧子序列节点\n    const prevChild = c1[i]\n    if (patched >= toBePatched) {\n      // 所有新的子序列节点都已经更新，剩余的节点删除\n      unmount(prevChild, parentComponent, parentSuspense, true)\n      continue\n    }\n    // 查找旧子序列中的节点在新子序列中的索引\n    let newIndex = keyToNewIndexMap.get(prevChild.key)\n    if (newIndex === undefined) {\n      // 找不到说明旧子序列已经不存在于新子序列中，则删除该节点\n      unmount(prevChild, parentComponent, parentSuspense, true)\n    }\n    else {\n      // 更新新子序列中的元素在旧子序列中的索引，这里加 1 偏移，是为了避免 i 为 0 的特殊情况，影响对后续最长递增子序列的求解\n      newIndexToOldIndexMap[newIndex - s2] = i + 1\n      // maxNewIndexSoFar 始终存储的是上次求值的 newIndex，如果不是一直递增，则说明有移动\n      if (newIndex >= maxNewIndexSoFar) {\n        maxNewIndexSoFar = newIndex\n      }\n      else {\n        moved = true\n      }\n\n      // 更新新旧子序列中匹配的节点\n      patch(prevChild, c2[newIndex], container, null, parentComponent, parentSuspense, isSVG, optimized)\n      patched++\n    }\n  }\n}\n```\n\n建立了一个 newIndexToOldIndexMap 的数组，来存储新子序列节点的索引和旧子序列节点的索引之间的映射关系，用于确定最长递增子序列，这个数组的长度为新子序列的长度，每个元素的初始值设为 0， 它是一个特殊的值，如果遍历完了仍有元素的值为 0，则说明遍历旧子序列的过程中没有处理过这个节点，这个节点是新添加的。\n\n下面我们说说具体的操作过程：**正序遍历旧子序列，根据前面建立的 keyToNewIndexMap 查找旧子序列中的节点在新子序列中的索引，如果找不到就说明新子序列中没有该节点，就删除它；如果找得到则将它在旧子序列中的索引更新到 newIndexToOldIndexMap 中。**\n\n注意这里索引加了长度为 1 的偏移，是为了应对 i 为 0 的特殊情况，如果不这样处理就会影响后续求解最长递增子序列。\n\n遍历过程中，我们用变量 maxNewIndexSoFar 跟踪判断节点是否移动，maxNewIndexSoFar 始终存储的是上次求值的 newIndex，一旦本次求值的 newIndex 小于 maxNewIndexSoFar，这说明顺序遍历旧子序列的节点在新子序列中的索引并不是一直递增的，**也就说明存在移动的情况**。\n\n除此之外，这个过程中我们也会更新新旧子序列中匹配的节点，另外如果所有新的子序列节点都已经更新，而对旧子序列遍历还未结束，说明剩余的节点就是多余的，删除即可。\n\n**至此，我们完成了新旧子序列节点的更新、多余旧节点的删除，并且建立了一个 newIndexToOldIndexMap 存储新子序列节点的索引和旧子序列节点的索引之间的映射关系，并确定是否有移动**。\n\n![1716200275355](/images/diff-vue-react/1716200275355.png)\n\n可以看到， c、d、e 节点被更新，f 节点被删除，newIndexToOldIndexMap 的值为 [5, 3, 4 ,0]，此时 moved 也为 true，也就是存在节点移动的情况。\n\n##### 倒序遍历新子序列-移动和挂载新节点\n\n接下来，就到了处理未知子序列的最后一个流程，移动和挂载新节点，我们来看一下这部分逻辑的实现：\n\n```javascript\nconst patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, isSVG, optimized) => {\n  let i = 0\n  const l2 = c2.length\n  // 旧子节点的尾部索引\n  let e1 = c1.length - 1\n  // 新子节点的尾部索引\n  let e2 = l2 - 1\n  // 1. 从头部开始同步\n  // i = 0, e1 = 6, e2 = 7\n  // (a b) c d e f g\n  // (a b) e c d h f g\n  // 2. 从尾部开始同步\n  // i = 2, e1 = 6, e2 = 7\n  // (a b) c (d e)\n  // (a b) (d e)\n  // 3. 普通序列挂载剩余的新节点， 不满足\n  // 4. 普通序列删除多余的节点，不满足\n  // i = 2, e1 = 4, e2 = 5\n  // 旧子节点开始索引，从 i 开始记录\n  const s1 = i\n  // 新子节点开始索引，从 i 开始记录\n  const s2 = i //\n  // 5.1 根据 key 建立新子序列的索引图\n  // 5.2 正序遍历旧子序列，找到匹配的节点更新，删除不在新子序列中的节点，判断是否有移动节点\n  // 5.3 倒序的方式遍历新子序列，移动和挂载新节点\n  // 仅当节点移动时生成最长递增子序列\n  const increasingNewIndexSequence = moved\n    ? getSequence(newIndexToOldIndexMap)\n    : EMPTY_ARR\n\n  let j = increasingNewIndexSequence.length - 1\n  // 倒序遍历以便我们可以使用最后更新的节点作为锚点\n  for (i = toBePatched - 1; i >= 0; i--) {\n    const nextIndex = s2 + i\n    const nextChild = c2[nextIndex]\n    // 锚点指向上一个更新的节点，如果 nextIndex 超过新子节点的长度，则指向 parentAnchor\n    const anchor = nextIndex + 1 < l2 ? c2[nextIndex + 1].el : parentAnchor\n    if (newIndexToOldIndexMap[i] === 0) {\n      // 挂载新的子节点\n      patch(null, nextChild, container, anchor, parentComponent, parentSuspense, isSVG)\n    }\n    else if (moved) {\n      // 没有最长递增子序列（reverse 的场景）或者当前的节点索引不在最长递增子序列中，需要移动\n      if (j < 0 || i !== increasingNewIndexSequence[j]) {\n        move(nextChild, container, anchor, 2)\n      }\n      else {\n        // 倒序递增子序列\n        j--\n      }\n    }\n  }\n}\n\n```\n\n我们前面已经判断了是否移动，**如果 moved 为 true 就通过 getSequence(newIndexToOldIndexMap) 计算最长递增子序列**，这部分算法我会放在后文详细介绍。\n\n接着我们采用**倒序的方式遍历新子序列，因为倒序遍历可以方便我们使用最后更新的节点作为锚点**。在倒序的过程中，锚点指向上一个更新的节点，然后判断 newIndexToOldIndexMap[i] 是否为 0，如果是则表示这是新节点，就需要挂载它；接着判断是否存在节点移动的情况，如果存在的话则看节点的索引是不是在最长递增子序列中，如果在则倒序最长递增子序列，否则把它移动到锚点的前面。\n\n为了便于你更直观地理解，我们用前面的例子展示一下这个过程，此时 toBePatched 的值为 4，j 的值为 1，最长递增子序列 increasingNewIndexSequence 的值是 [1, 2]。在倒序新子序列的过程中，首先遇到节点 i，发现它在 newIndexToOldIndexMap 中的值是 0，则说明它是新节点，我们需要挂载它；然后继续遍历遇到节点 d，因为 moved 为 true，且 d 的索引存在于最长递增子序列中，则执行 j-- 倒序最长递增子序列，j 此时为 0；接着继续遍历遇到节点 c，它和 d 一样，索引也存在于最长递增子序列中，则执行 j--，j 此时为 -1；接着继续遍历遇到节点 e，此时 j 是 -1 并且 e 的索引也不在最长递增子序列中，所以做一次移动操作，把 e 节点移到上一个更新的节点，也就是 c 节点的前面。\n\n新子序列倒序完成，即完成了新节点的插入和旧节点的移动操作，也就完成了整个核心 diff 算法对节点的更新。\n\n![1716200731849](/images/diff-vue-react/1716200731849.png)\n\n可以看到新子序列中的新节点 i 被挂载，旧子序列中的节点 e 移动到了 c 节点前面，至此，我们就在已知旧子节点 DOM 结构和 vnode、新子节点 vnode 的情况下，求解出生成新子节点的 DOM 的更新、移动、删除、新增等系列操作，并且以一种较小成本的方式完成 DOM 更新。\n\n我们知道了子节点更新调用的是 patch 方法， Vue.js 正是通过这种递归的方式完成了整个组件树的更新。\n\n**总结：第五步的主要步骤**：\n\n- 根据 key 建立新子序列的索引图\n- 正序遍历旧子序列，找到匹配的节点更新，删除不在新子序列中的节点，判断是否有移动节点\n- 倒序遍历新子序列，移动和挂载新节点\n\n### 非核心算法\n\n`patchUnkeyedChildren` 是基于没有标记 key 的子节点 diff，我们来分析一下它的实现。\n\n```javascript\n  const patchUnkeyedChildren = (\n    c1: VNode[],\n    c2: VNodeArrayChildren,\n    container: RendererElement,\n    anchor: RendererNode | null,\n    parentComponent: ComponentInternalInstance | null,\n    parentSuspense: SuspenseBoundary | null,\n    namespace: ElementNamespace,\n    slotScopeIds: string[] | null,\n    optimized: boolean,\n  ) => {\n    c1 = c1 || EMPTY_ARR\n    c2 = c2 || EMPTY_ARR\n    const oldLength = c1.length\n    const newLength = c2.length\n    const commonLength = Math.min(oldLength, newLength)\n    let i\n    for (i = 0; i < commonLength; i++) {\n      const nextChild = (c2[i] = optimized\n        ? cloneIfMounted(c2[i] as VNode)\n        : normalizeVNode(c2[i]))\n      patch(\n        c1[i],\n        nextChild,\n        container,\n        null,\n        parentComponent,\n        parentSuspense,\n        namespace,\n        slotScopeIds,\n        optimized,\n      )\n    }\n    if (oldLength > newLength) {\n      // remove old\n      unmountChildren(\n        c1,\n        parentComponent,\n        parentSuspense,\n        true,\n        false,\n        commonLength,\n      )\n    } else {\n      // mount new\n      mountChildren(\n        c2,\n        container,\n        anchor,\n        parentComponent,\n        parentSuspense,\n        namespace,\n        slotScopeIds,\n        optimized,\n        commonLength,\n      )\n    }\n  }\n```\n\n实现也是非常简单的，分三步：\n\n1. 取最小公共长度，调用 patch 方法更新每个子节点；\n2. 删除旧子序列中多余的子节点；\n3. 挂载新子序列中新增的子节点。\n\n### 番外篇\n\n#### 计算最长递增子序列\n\n```javascript\n// https://en.wikipedia.org/wiki/Longest_increasing_subsequence\nfunction getSequence(arr: number[]): number[] {\n  const p = arr.slice()\n  const result = [0]\n  let i, j, u, v, c\n  const len = arr.length\n  for (i = 0; i < len; i++) {\n    const arrI = arr[i]\n    if (arrI !== 0) {\n      j = result[result.length - 1]\n      if (arr[j] < arrI) {\n        // 存储在 result 更新前的最后一个索引的值\n        p[i] = j\n        result.push(i)\n        continue\n      }\n      u = 0\n      v = result.length - 1\n      // 二分搜索，查找比 arrI 小的节点，更新 result 的值\n      while (u < v) {\n        c = (u + v) >> 1\n        if (arr[result[c]] < arrI) {\n          u = c + 1\n        } else {\n          v = c\n        }\n      }\n      if (arrI < arr[result[u]]) {\n        if (u > 0) {\n          p[i] = result[u - 1]\n        }\n        result[u] = i\n      }\n    }\n  }\n  u = result.length\n  v = result[u - 1]\n\n  // 回溯数组 p，找到最终的索引\n  while (u-- > 0) {\n    result[u] = v\n    v = p[v]\n  }\n  return result\n}\n```\n"},{"title":"vue2-diff","url":"/2023/10/02/vue2-diff/","content":"\nVue2 diff 算法使用的是**双端比较算法**。\n\n<!-- more -->\n\n核心算法源码位于 `src/core/vdom/patch.ts` 的 `updateChildren` 函数\n\n```javascript\nfunction updateChildren(\n    parentElm,\n    oldCh,\n    newCh,\n    insertedVnodeQueue,\n    removeOnly\n  ) {\n    let oldStartIdx = 0\n    let newStartIdx = 0\n    let oldEndIdx = oldCh.length - 1\n    let oldStartVnode = oldCh[0]\n    let oldEndVnode = oldCh[oldEndIdx]\n    let newEndIdx = newCh.length - 1\n    let newStartVnode = newCh[0]\n    let newEndVnode = newCh[newEndIdx]\n    let oldKeyToIdx, idxInOld, vnodeToMove, refElm\n\n    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {\n      //...\n    }\n  }\n```\n\n注意：需要维护四个重要的索引变量（该算法就是双端算法）\n\n- oldStartIdx：旧子节点列表的起始索引\n- oldEndIdx：旧子节点列表的结束索引\n- newStartIdx：新子节点列表的起始索引\n- newEndIdx：新子节点列表的结束索引\n\n前提：整个 while 循环执行的条件是：头部索引值要小于等于尾部索引值。\n\n## 1. 比较过程\n\n\n```javascript\n  if (isUndef(oldStartVnode)) {\n    oldStartVnode = oldCh[++oldStartIdx] // Vnode has been moved left\n  } else if (isUndef(oldEndVnode)) {\n    oldEndVnode = oldCh[--oldEndIdx]\n  } \n```\n\n<font color=red>注意：后续在第 5 步，在旧子节点中寻找与新首节点相同 key 的 vnode 过程中，**已处理过的旧子节点**中对应位置的 vnode 会被标记为 undefined，所以无需处理，跳过到下一个索引即可。</font>\n\n### 1.1 旧头和新头比较\n\n```javascript\nif (sameVnode(oldStartVnode, newStartVnode)) {\n  patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue)\n  oldStartVnode = oldCh[++oldStartIdx]\n  newStartVnode = newCh[++newStartIdx]\n}\n```\n\n### 1.2 旧尾和新尾比较\n\n```javascript\nif (sameVnode(oldEndVnode, newEndVnode)) {\n  patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue)\n  oldEndVnode = oldCh[--oldEndIdx]\n  newEndVnode = newCh[--newEndIdx]\n}\n```\n\n### 1.3 旧头和新尾比较\n\n```javascript\nif (sameVnode(oldStartVnode, newEndVnode)) {\n  // Vnode moved right\n  patchVnode(\n    oldStartVnode,\n    newEndVnode,\n    insertedVnodeQueue,\n    newCh,\n    newEndIdx\n  )\n  canMove &&\n    nodeOps.insertBefore(\n    parentElm,\n    oldStartVnode.elm,\n    nodeOps.nextSibling(oldEndVnode.elm)\n    )\n  oldStartVnode = oldCh[++oldStartIdx]\n  newEndVnode = newCh[--newEndIdx]\n}\n```\n\n### 1.4 旧尾和新头比较\n\n```javascript\nif (sameVnode(oldEndVnode, newStartVnode)) {\n  // Vnode moved left\n  patchVnode(\n    oldEndVnode,\n    newStartVnode,\n    insertedVnodeQueue,\n    newCh,\n    newStartIdx\n  )\n  canMove &&\n    nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm)\n  oldEndVnode = oldCh[--oldEndIdx]\n  newStartVnode = newCh[++newStartIdx]\n}\n```\n\n**小总结：前面 4 步是通过对比找到了可以复用的节点，执行对应的操作，然后更新索引变量。**\n\n### 1.5 新头和旧中间比较\n\n```javascript\n if (isUndef(idxInOld)) {\n    // New element\n    createElm(\n      newStartVnode,\n      insertedVnodeQueue,\n      parentElm,\n      oldStartVnode.elm,\n      false,\n      newCh,\n      newStartIdx\n    )\n  } else {\n    vnodeToMove = oldCh[idxInOld]\n    if (sameVnode(vnodeToMove, newStartVnode)) {\n      patchVnode(\n        vnodeToMove,\n        newStartVnode,\n        insertedVnodeQueue,\n        newCh,\n        newStartIdx\n      )\n      oldCh[idxInOld] = undefined\n      canMove &&\n        nodeOps.insertBefore(\n          parentElm,\n          vnodeToMove.elm,\n          oldStartVnode.elm\n        )\n    } else {\n      // same key but different element. treat as new element\n      createElm(\n        newStartVnode,\n        insertedVnodeQueue,\n        parentElm,\n        oldStartVnode.elm,\n        false,\n        newCh,\n        newStartIdx\n      )\n    }\n  }\n  newStartVnode = newCh[++newStartIdx]\n```\n\n以 newStartVnode 的 key 为标记，在旧子节点中寻找相同 key 的 vnode，如果找到了，则执行 patchVnode 函数，<font color=red>然后将旧子节点中对应位置的 vnode 标记为 undefined，表示该 vnode 已经处理过了</font>。\n\n如果没找到，则说明是新元素，则执行 createElm 函数，创建新元素。\n\n**小总结：**\n\n- 旧子节点中没有新子节点中的 key，则说明是新元素，执行 createElm 函数创建新元素。\n- 旧子节点中有新子节点中的 key，则说明是旧元素，执行 patchVnode 函数更新旧元素。\n\n<font color=red>总结：前面 5 步都是位于循环中的，循环跳出后，需要处理剩余的节点。</font>\n\n### 1.6 剩余节点的处理\n\n```javascript\nif (oldStartIdx > oldEndIdx) {\n  // 新子节点还有剩余\n  refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm\n  addVnodes(\n    parentElm,\n    refElm,\n    newCh,\n    newStartIdx,\n    newEndIdx,\n    insertedVnodeQueue\n  )\n} else if (newStartIdx > newEndIdx) {\n  // 旧子节点还有剩余\n  removeVnodes(oldCh, oldStartIdx, oldEndIdx)\n}\n```\n\n处理剩余节点：\n\n如果新子节点还有剩余，则执行 addVnodes 函数，将剩余的新子节点添加到 DOM 中。\n\n如果旧子节点还有剩余，则执行 removeVnodes 函数，将剩余的旧子节点从 DOM 中移除。\n"},{"title":"Hexo：问题记录","url":"/2023/06/20/hexo-summary/","content":"\n\n记录搭建 hexo 博客网站后，在扩展功能问题上的摸索。\n\n<!-- more -->\n\n背景：使用 hexo ocean 主题搭建。\n\n### 图片预览放大功能\n\n> 参考文章: [Hexo 添加图片放大功能](http://gaothink.top/2020/03/31/%E6%9D%82%E8%AE%B0-Hexo%E6%B7%BB%E5%8A%A0%E5%9B%BE%E7%89%87%E6%94%BE%E5%A4%A7%E5%8A%9F%E8%83%BD/)\n\n本站图片文字太小，需要放大才能看清，于是想添加图片放大功能。发现 Ocean 主题是自带的，需要在配置文件(/themes/ocean/_config.yml)中开启。\n\n```Shell\n# fancybox\nfancybox: true\n```\n\n配置后行不通，然后查看了 [fancybox](https://fancyapps.com/fancybox/getting-started/) 的官方文档和页面元素，原来是使用上出现了问题。这个库需要手动在图片代码上添加代码，而 Hexo 本身编译完的代码并不会帮我们主动处理，正确用法如下：\n\n```html\n<a href=\"image-a.jpeg\" data-fancybox data-caption=\"Single image\">\n  <img src=\"thumbnail-a.jpeg\" />\n</a>\n```\n\n接着想着这样的事还是交给自动化吧，在 `/themes/ocean/js/` 文件夹下新增 `wrapImage.js` 文件：\n\n```JavaScript\n$(document).ready(function() {\n    wrapImageWithFancyBox();\n});\n\n/**\n * Wrap images with fancybox support.\n */\nfunction wrapImageWithFancyBox() {\n    $('img').not('.sidebar-image img').not('#author-avatar img').not(\".mdl-menu img\").not(\".something-else-logo img\").not('[title=notice]').each(function() {\n        var $image = $(this);\n        var imageCaption = $image.attr('alt');\n        var $imageWrapLink = $image.parent('a');\n\n        if ($imageWrapLink.size() < 1) {\n            var src = this.getAttribute('src');\n            var idx = src.lastIndexOf('?');\n            if (idx != -1) {\n                src = src.substring(0, idx);\n            }\n            $imageWrapLink = $image.wrap('<a href=\"' + src + '\"></a>').parent('a');\n        }\n\n        $imageWrapLink.attr('data-fancybox', 'images');\n        if (imageCaption) {\n            $imageWrapLink.attr('data-caption', imageCaption);\n        }\n\n    });\n\n    $('[data-fancybox=\"images\"]').fancybox({\n      buttons : [ \n        'slideShow',\n\t\t'thumbs',\n        'zoom',\n        'fullScreen',\n        'close'\n      ],\n      thumbs : {\n        autoStart : false\n      }\n    });\n}\n```\n\n最后一步，在 `/themes/ocean/layout/_partial/after-footer.ejs` 引入 `wrapImage.js` 文件即可：\n\n```JavaScript\n<% if (theme.fancybox){ %>\n<%- js('js/wrapImage') %>\n<%- js('fancybox/jquery.fancybox.min') %>\n<% } %>\n```\n\n### 文章搜索功能\n\n\n"},{"title":"WEB：常用 git 命令备忘录","url":"/2023/05/23/common-git/","content":"\n\n虽然平时使用习惯 `vscode` 的 `git` 插件功能，但还是得记住常用的 `git` 命令。\n\n<!-- more -->\n\n一般来说，日常使用只要记住下图6个命令，就可以了。\n\n![总结](/images/common-git/all.png)\n\n几个专用名词的译名如下:\n\n- Workspace：工作区（本地文件）\n- Index / Stage：暂存区\n- Repository：仓库区（或本地仓库）\n- Remote：远程仓库\n\n**关于常用的 git 命令，可以直接查看阮一峰大佬的 [常用 Git 命令清单](https://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html)。**\n\n### 从下载到更新项目的命令\n\n```Shell\n# 下载一个项目和它的整个代码历史\n$ git clone [url]\n\n# 切换到指定分支，并更新工作区\n$ git checkout [branch-name]\n\n# 取回远程仓库的变化，并与本地分支合并\n$ git pull [remote] [branch]\n\n# 添加当前目录的所有文件到暂存区\n$ git add .\n\n# 提交暂存区到仓库区\n$ git commit -m [message]\n\n# 上传本地指定分支到远程仓库\n$ git push [remote] [branch]\n```\n\n### 开发时使用频率高的命令\n\n#### 重写 commit 的提交信息\n\n```Shell\n# 改写上一次commit的提交信息\n$ git commit --amend -m [message]\n```\n\n#### 回滚 commit\n\n```Shell\n# 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致\n$ git reset --hard [commit]\n\n$ git push --force\n```\n\n#### 回滚 add\n\n```Shell\n# 恢复暂存区的所有文件到工作区\n$ git checkout .\n```\n\n#### 缓存已修改的文件\n\n```Shell\n# 暂时将未提交的变化移除，稍后再移入\n$ git stash\n$ git stash pop\n```\n\n### 排查时使用频率高的命令\n\n#### 查看变更文件信息\n\n```Shell\n# 显示有变更的文件\n$ git status\n```\n\n```Shell\n# 显示暂存区和工作区的差异\n$ git diff\n```\n\n```Shell\n# 显示指定文件是什么人在什么时间修改过\n$ git blame [file]\n```\n\n#### 查看版本历史\n\n```Shell\n# 显示当前分支的版本历史\n$ git log\n\n# 显示指定文件相关的每一次diff\n$ git log -p [file]\n\n# 搜索提交历史，根据关键词\n$ git log -S [keyword]\n```\n\n```Shell\n# 显示当前分支的最近几次提交\n$ git reflog\n```\n\n### 总结\n\n常用命令速查表\n\n![常用命令速查表](/images/common-git/shell.png)\n\n\n参考文章：\n\n[常用 Git 命令清单](https://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html)\n\n"},{"title":"WEB：webpack tapable","url":"/2023/05/09/web-webpack-tapable/","content":" `Webpack` 的插件体系是一种基于 [Tapable](https://github.com/webpack/tapable) 实现的强耦合架构，在特定时机触发钩子时会附带上足够的上下文信息。插件定义的钩子回调中，能也只能与这些上下文背后的数据结构、接口交互产生 side effect，进而影响到编译状态和后续流程。\n\n<!-- more -->\n\n`tapable` 可以说是增强版的**发布订阅模式**，类似的库还有不少：\n\n* `redux` 的 `subscribe` 和 `dispatch`\n* `Node.js` 的 `EventEmitter`\n* `redux-saga` 的 `take` 和 `put`\n\n### 基础用法\n\n`Tapable` 的基础用法\n\n```Javascript\nconst { SyncHook } = require(\"tapable\");\n\n// 1. 创建钩子实例\nconst sleep = new SyncHook();\n\n// 2. 调用订阅接口注册回调\nsleep.tap(\"test\", () => {\n  console.log(\"callback A\");\n});\n\n// 3. 调用发布接口触发回调\nsleep.call();\n\n// 运行结果：\n// callback A\n```\n\n使用 Tapable 时通常需要经历三个步骤：\n\n* 创建钩子实例；\n* 调用订阅接口注册回调，包括：tap、tapAsync、tapPromise；\n* 调用发布接口触发回调，包括：call、callAsync、promise。\n\n### 具体用法\n\n查看源码，发现官方提供的 API，[Readme 传送门](https://github1s.com/webpack/tapable)：\n\n```Javascript\nconst {\n    SyncHook,\n    SyncBailHook,\n    SyncWaterfallHook,\n    SyncLoopHook,\n    AsyncParallelHook,\n    AsyncParallelBailHook,\n    AsyncSeriesHook,\n    AsyncSeriesBailHook,\n    AsyncSeriesLoopHook,\n    AsyncSeriesWaterfallHook\n } = require(\"tapable\");\n```\n\nTabable 提供如下类型的钩子：\n\n| 名称                         | 简介               | 统计                                                                |\n| ---------------------------- | ------------------ | ------------------------------------------------------------------- |\n| `SyncHook`                 | 同步钩子           | Webpack 共出现 71 次，如 `Compiler.hooks.compilation`             |\n| `SyncBailHook`             | 同步熔断钩子       | Webpack 共出现 66 次，如 `Compiler.hooks.shouldEmit`              |\n| `SyncWaterfallHook`        | 同步瀑布流钩子     | Webpack 共出现 37 次，如 `Compilation.hooks.assetPath`            |\n| `SyncLoopHook`             | 同步循环钩子       | Webpack 中未使用                                                    |\n| `AsyncParallelHook`        | 异步并行钩子       | Webpack 仅出现 1 次：`Compiler.hooks.make`                        |\n| `AsyncParallelBailHook`    | 异步并行熔断钩子   | Webpack 中未使用                                                    |\n| `AsyncSeriesHook`          | 异步串行钩子       | Webpack 共出现 16 次，如 `Compiler.hooks.done`                    |\n| `AsyncSeriesBailHook`      | 异步串行熔断钩子   | Webpack 中未使用                                                    |\n| `AsyncSeriesLoopHook`      | 异步串行循环钩子   | Webpack 中未使用                                                    |\n| `AsyncSeriesWaterfallHook` | 异步串行瀑布流钩子 | Webpack 共出现 5 次，如 `NormalModuleFactory.hooks.beforeResolve` |\n\n类型虽多，但整体遵循两种分类规则：\n\n按回调逻辑，分为：\n\n* 基本类型，名称不带 Waterfall/Bail/Loop 关键字：与通常 订阅/回调 模式相似，按钩子注册顺序，逐次调用回调；\n* waterfall 类型：前一个回调的返回值会被带入下一个回调；\n* bail 类型：逐次调用回调，若有任何一个回调返回非 undefined 值，则终止后续调用；\n* loop 类型：逐次、循环调用，直到所有回调函数都返回 undefined 。\n\n按执行回调的并行方式，分为：\n\n* sync ：同步执行，启动后会按次序逐个执行回调，支持 call/tap 调用语句；\n* async ：异步执行，支持传入 callback 或 promise 风格的异步回调函数，支持 callAsync/tapAsync 、promise/tapPromise 两种调用语句\n\n**查看 [webpack plugin hook](https://webpack.js.org/api/compiler-hooks/) 类型与用法。**\n\n> 提示：Webpack 官方文档并没有覆盖介绍所有钩子，必要时建议读者直接翻阅 Webpack 源码，分析钩子类型。\n\n虽然多数情况下我们不需要手动调用 Tapable，但编写插件时可以借助这些知识，识别 Hook 类型与执行特性后，正确地调用，正确地实现交互。\n\n### 高级特性\n\n#### Intercept\n\n#### HookMap\n\n### 原理浅析\n\nHook 动态编译\n\n![alt text](/images/webpack-tapable/image.png)\n\n编译过程主要涉及三个实体：\n\n* tapable/lib/SyncHook.js ：定义 SyncHook 的入口文件；\n* tapable/lib/Hook.js ：SyncHook 只是一个代理接口，内部实际上调用了 Hook 类，由 Hook 负责实现钩子的逻辑（其它钩子也是一样的套路）；\n* tapable/lib/HookCodeFactory.js ：动态编译出 call、callAsync、promise 函数内容的工厂类，注意，其他钩子也都会用到 HookCodeFactory 工厂函数。\n\ntapable 提供的大多数特性都是基于 Hook + HookCodeFactory 实现的\n\n参考文章：\n\n[webpack核心模块tapable源码解析](https://dennisgo.cn/Articles/Engineering/tapable-source-code.html)\n"},{"title":"WEB：Next Nuxt Nest 傻傻分不清楚","url":"/2023/04/18/next-nuxt-nest/","content":"`Next` 和 `Nuxt` 是常见的 `SSR` 框架，而 `Nest` 是 `Nodejs` 服务器端应用的框架。\n\n<!-- more -->\n\n### Nuxt(Vue)\n\n> [Nuxt](https://nuxt.com.cn/) 是一个开源框架，它提供了一种直观且可扩展的方式来创建类型安全、高性能和生产级别的全栈Web应用和网站，使用的是Vue.js。\n\n### Next(React)\n\n> [Nextjs](https://www.nextjs.cn/) 为您提供生产环境所需的所有功能以及最佳的开发体验：包括静态及服务器端融合渲染、 支持 TypeScript、智能化打包、 路由预取等功能 无需任何配置。\n\n### Nest(Turbo)\n\n> [Nest](https://nest.nodejs.cn/#google_vignette) (NestJS) 是一个用于构建高效、可扩展的 Node.js 服务器端应用的框架。它使用渐进式 JavaScript，构建并完全支持 TypeScript（但仍然允许开发者使用纯 JavaScript 进行编码）并结合了 OOP（面向对象编程）、FP（函数式编程）和 FRP（函数式反应式编程）的元素。\n\n\n后续有时间再详细研究。\n"},{"title":"WEB：Vue SSR","url":"/2023/04/13/vue-ssr/","content":"\n\nSSR（Server-Side Rendering）: 服务端渲染，那它到底跟客户端渲染（CSR）有什么区别呢？\n<!-- more -->\n\n***\n\n**`SSR` 指由服务侧完成页面的 `HTML` 结构拼接的页面处理技术，（把渲染完毕的 html 页面）发送到浏览器，然后为其绑定状态与事件，成为完全可交互页面的过程。**\n\n可以先分析两者在返回数据时的具体表现：\n\nCSR:\n\n![CSR](/images/vue-ssr/csr.png)\n\nSSR:\n\n![SSR](/images/vue-ssr/ssr.png)\n\nSSR、CSR、同构渲染之间的对比：\n\n<table>\n    <tr>\n        <td></td>\n        <td>SSR</td>\n        <td>CSR</td>\n        <td>同构渲染</td>\n    </tr>\n    <tr>\n        <td>SEO</td>\n        <td>友好</td>\n        <td>不友好</td>\n        <td>友好</td>\n    </tr>\n    <tr>\n        <td>白屏问题</td>\n        <td>无</td>\n        <td>有</td>\n        <td>无</td>\n    </tr>\n    <tr>\n        <td>占用服务端资源</td>\n        <td>多</td>\n        <td>少</td>\n        <td>中</td>\n    </tr>\n    <tr>\n        <td>用户体验</td>\n        <td>差</td>\n        <td>好</td>\n        <td>好</td>\n    </tr>\n</table>\n\n关于 `SSR` 与 `CSR` 的区别，在 `Vue SSR` 文章中已经给出了答案。具体可看 [服务端渲染 (SSR)](https://cn.vuejs.org/guide/scaling-up/ssr)：\n\n- 更好的 SEO：搜索引擎爬虫可以直接看到完全渲染的页面（**首要原因，官网项目首选**）。\n- 更快的首屏加载：减少浏览器请求数量（内部管理系统项目一般不考虑 SSR，不太在乎渲染速度）。\n- 统一的心智模型：前后端开发语言一致（Javascript）。\n\n***\n\n**关键词：`renderToString`、`createSSRApp`、`vue-server-renderer`、服务端首屏渲染、客户端激活**。\n\n### 原理\n\n完成 SSR 的两大核心步骤：**服务端首屏渲染**和**客户端激活**。\n\n![ssr-summary](/images/vue-ssr/ssr-summary.png)\n\n简述：关注图片 `webpack` 右侧打包后的文件。\n- 第一步 `Server Bundle` 文件用于在服务端渲染生成 `html` 页面 **`<body>` 内容**（string），然后嵌入到 html 模板里面。\n- 第二步 `Client Bundle` 文件直接嵌入到 `html` 页面的 **`<script>` 标签**中，在浏览器渲染时用于激活 vue 实例（**只激活不重新挂载渲染**）。\n\n#### 服务端首屏渲染\n\n同构代码：\n\n```JavaScript\n// app.js (在服务器和客户端之间共享)\nimport { createSSRApp } from 'vue'\n\nexport function createApp() {\n  return createSSRApp({\n    data: () => ({ count: 1 }),\n    template: `<button @click=\"count++\">{{ count }}</button>`\n  })\n}\n```\n\n小插曲：【同构】的含义是，同样一套代码即可以在服务端运行，也可以在客户端运行（Vue.js 的组件即可以在服务端运行，被渲染为 HTML 字符串；也可以在客户端运行，就像普通的 CSR 应用程序一样）。 **<font color=\"red\">同构渲染，组件的代码会在服务端和客户端分别执行一次。</font>**\n\n服务端代码：\n\n```JavaScript\n// server.js 此文件运行在 Node.js 服务器上\n// Vue 的服务端渲染 API 位于 `vue/server-renderer` 路径下\nimport { renderToString } from 'vue/server-renderer'\n\nconst app = createApp()\nrenderToString(app).then((html) => {\n  res.send(`\n    <!DOCTYPE html>\n    <html>\n      <head>\n        <title>Vue SSR Example</title>\n      </head>\n      <body>\n        <div id=\"app\">${html}</div>\n      </body>\n    </html>\n  `)\n})\n```\n\n[核心 API](https://cn.vuejs.org/api/ssr.html)：`renderToString`\n\n`renderToString()` 接收一个**Vue 应用实例**作为参数，返回一个 Promise，当 Promise resolve 时得到应用渲染的 HTML，嵌入到 HTML 模板中并返回给浏览器。\n\n#### 客户端激活(hydration)\n\n客户端激活指的是 Vue 在**浏览器端**接管由服务端发送的静态 HTML，使其变为由 Vue 管理的动态 DOM 的过程。\n\n在浏览器运行时主要做两件事：\n- 在页面中的 `DOM` 元素与虚拟节点对象之间建立联系\n- 为页面中的 `DOM` 元素添加事件绑定（服务端渲染时会忽略节点中与事件相关的 `props`）\n\n**但不会再次创建 `DOM` 元素。**\n\n客户端代码：\n\n```JavaScript\n// client.js 该文件运行在浏览器中\nimport { createApp } from './app.js'\n\n// 在客户端挂载一个 SSR 应用时会假定\n// HTML 是预渲染的，然后执行激活过程，\n// 而不是挂载新的 DOM 节点\ncreateApp().mount('#app')\n```\n\n将 `<script type=\"module\" src=\"/client.js\"></script>` 添加到 HTML 外壳以加载客户端入口文件。\n\n总结: 只在首屏渲染时获取一次 html 文件，**激活完成后，整个应用程序已经完全被 `Vue.js` 接管为 `CSR` 应用程序了**。后续路由变化或等事件都是请求 js 文件，真正地复用 `Vue.js` 的 spa 功能。\n\n[代码完整实例](/vue-ssr-example.zip)，可自行下载运行。\n\n### 框架\n\n#### Nuxt\n\n可移步至  [WEB：Next Nuxt Nest 傻傻分不清楚](https://zeuscoder.github.io/2023/04/18/next-nuxt-nest/)\n\n#### Vite SSR\n\n参考文章：\n\n[服务端渲染 (SSR)](https://cn.vuejs.org/guide/scaling-up/ssr)\n\n[理解Vue SSR原理，搭建项目框架](https://juejin.cn/post/6950802238524620837?searchId=20240321112333AB6B0212A536DE53B864)\n\n[Vue.js 设计与实现 第六篇：服务端渲染]()"},{"title":"Project：Vue vs React","url":"/2023/04/09/project-diff-vue-and-react/","content":"最主流的两个框架 Vue 和 React，比较一下。\n\n<!--more-->\n\n|          | Vue2           | Vue3                          | React                   |\n| -------- | -------------- | ----------------------------- | ----------------------- |\n| 适用场景 | 中小型单页应用 | 大型复杂单页应用              | 大型复杂单页应用        |\n| 响应式   | 双向绑定       | 双向绑定                      | 单向数据流              |\n| 路由     | vue-router4    | vue-router5                   | react-router            |\n| 状态     | vuex3          | vuex4、pinia                  | mobx、redux             |\n| diff     | 双端比较       | 双端比较                      | fiber                   |\n| UI       | elementUI      | element-plus                  | ant-design              |\n| 跨端     | weex           | weex                          | react-native            |\n| 小程序   | uni-app        | uni-app                       | taro                    |\n| 开发     | options api    | compisition api / hooks       | class component / hooks |\n| 工具     |                | vueuse、vue-hooks-plius、mitt |                         |\n| 性能     | 中             | 高                            | 高                      |\n"},{"title":"随笔：论自己的博客风格","url":"/2023/03/22/write-blog/","content":"\n每年都会断断续续地写几篇博客，自然而然也形成了自己写博客的风格。\n\n<!-- more -->\n\n> 全篇为个人观点，论述自己喜欢的博客风格，也希望自己可以形成的博客风格，不论对错。\n\n我偏好开门见山，言简意赅，一针见血。\n\n**开篇先浓缩总结，表明观点，正文再娓娓道来，图文并茂，最后再来总结一番。**\n\n开篇部分希望可以看到浓缩版总结性言论（就简单几句话），先告诉我看的是什么，为什么，怎么做。\n\n我是典型的【拿走主义】，要是**开篇再搭配上关键词和核心 API**，就更完美了。\n\n如果开篇写得好，接下来正文的部分，我觉得可以不用看或者不用细看了。\n\n**正文部分，图文并茂当然是最好的（技术博客需要附上核心代码）。**能用一张图说明的，没必要花大段文字总结。*二次阅读时*只需要简单观看图片就能了解文章。\n\n![write-blog](/images/write-blog/blog.png)\n\n关于图，可以是流程图、思维导图，说明彼此之间的关联和注意事项。\n\n对于一张图的好坏评判，就在于下一次翻阅文章时，是不是只看图片就能明白了。\n\n关于文字，是更难的，首先是自己能看懂，然后还得别人看懂。<font color=\"red\">特别在大段文字中，适当加上颜色或加重字号等特殊标记，提醒重点是什么。</font>\n\n\n在此，对*修言大佬*表示深深的崇敬和谢意（我蹭一蹭热度），每次看到大佬的文章，都会给我一种和朋友交流技术的感觉，志同道合，收获满满。"},{"title":"WEB：算法的那些套路儿","url":"/2023/01/22/web-algorithm/","content":"\n\n算法这回事，用则进，不用则废；学而时习之，共勉之。学习前端算法惯用的套路，以不变应万变，**从难到易**。\n\n<!-- more -->\n\n***\n\n> 一句话总结：算法的本质就是「穷举」，而穷举有两个关键难点：**无遗漏、无冗余**。\n\n***\n\n> 本文讲解题目全部来源于 [leetcode](https://leetcode.cn/problemset/)，请根据题目序号查看题目内容。\n\n***\n\n## 数据结构\n\n数据结构的存储方式只有两种：__数组（顺序存储）__ 和 __链表（链式存储）__ ，其余可以先忽略不计。\n\n### 数组\n\n\n数组（二维数组）的核心是**初始化和遍历**，以及很多常用的 API。\n\n数组初始化：\n\n```JavaScript\nconst arr = new Array()\nconst arr = new Array(8)\nconst arr = (new Array(8)).fill(1)\n\nconst arr = []\n\n// 二维数组\nfor(let i = 0; i < arr.length; i++) {\n    arr[i] = []\n}\n```\n\n数组遍历：\n\n```JavaScript\nfor(let i = 0; i < arr.length; i++) {\n    console.log(arr[i], i)\n}\n\narr.forEach((item, index) => {\n    console.log(item, index)\n})\n\nconst newArr = arr.map((item, index) => {\n    console.log(item, index)\n    return item + 1\n})\n```\n\n常用 API：`concat`、`some`、`slice`、`splice`、`join`、`sort`、`pop`、`push` 等等。\n\n### 链表\n\n链表中，数据单位的名称叫做“结点”，而结点和结点的分布，在内存中可以是离散的。\n\n结点数据结构：\n\n```JavaScript\nfunction ListNode(val) {\n    this.val = val;\n    this.next = null;\n}\n```\n\n创建结点：\n\n```JavaScript\nconst node = new ListNode(1)\nnode.next = new ListNode(2)\n```\n\n插入结点：\n\n```JavaScript\n// 如果目标结点本来不存在，那么记得手动创建\nconst node3 = new ListNode(3)\n// 把node3的 next 指针指向 node2（即 node1.next）\nnode3.next = node1.next\n// 把node1的 next 指针指向 node3\nnode1.next = node3\n```\n\n删除结点：\n\n```JavaScript\n// 利用 node1 可以定位到 node3\nconst target = node1.next\nnode1.next = target.next\n```\n\n// TODO：分析下链表的几项基础类型题目\n\n环形链表基本问题——如何判断链表是否成环？\n\n### 二叉树（演变结构）\n\n二叉树结点的构造函数：\n\n```JavaScript\nfunction TreeNode(val) {\n    this.val = val;\n    this.left = this.right = null;\n}\n```\n\n二叉树问题的重中之重便是**遍历**及其相关的演变。先学会二叉树的各种遍历方式（四种）：\n\n* 前序遍历\n* 中序遍历\n* 后序遍历\n* 层次遍历\n\n前三种属于递归遍历，最后一种属于迭代遍历。\n\n```JavaScript\n// 所有遍历函数的入参都是树的根结点对象\nvar traverse = function(root) {\n    if (root === null) {\n        return;\n    }\n    // 前序位置\n    // console.log('当前遍历的结点值是：', root.val)\n    traverse(root.left);\n    // 中序位置\n    traverse(root.right);\n    // 后序位置\n}\n```\n\n总结：这里指的前中后顺序，关键就在于 __root.val__ 语句的处理位置。\n\n\n\n\n## 方法论\n\n### 动态规划（Dynamic Programming，DP）\n\n核心思想：\n\n* 动态规划问题的一般形式就是**求最值**，求解动态规划的核心问题是**穷举**。因为要求最值，肯定要把所有可行的答案穷举出来，然后在其中找最值。\n\n问题特点：\n\n* __只要求__ 给出达成某个目的的 **`解法个数或最终答案`**\n* __不要求__ 给出每一种解法对应的 **`具体路径`**\n\n关键特征（三要素）：\n\n* 具备【最优子结构】：能够通过子问题的最值得到原问题的最值\n* 存在【重叠子问题】\n* 列出 【状态转移方程】\n\n解答技巧：\n\n* **明确 base case**（很关键的一步）\n* 明确【状态】\n* 明确【选择】\n* 定义 __dp__ 数组/函数的含义\n\n套路框架：\n\n```JavaScript\n\n```\n\n典例分析：\n\n* P509 【斐波那契数列】\n\n一、暴力递归\n\n```JavaScript\nvar fib = function(n) {\n    if (n === 1 || n === 2) return 1;\n    return fib(n - 1) + fib(n - 2);\n};\n```\n\n缺点：每求一个中间值都会存在大量重复计算，这就是存在了 **【重叠子问题】** 。\n\n二、带备忘录的递归解法\n\n在动态规划中，常常会遇到子问题的重复计算。DP table （通常是一个数组）的主要作用是在求解过程中保存已解决的子问题的结果，以便在后续的计算中直接使用，从而避免了重复计算，提高了算法的效率。\n\n> 请注意，这里 table 长度为 n + 1，而 table[0] 一般不用。\n\n```JavaScript\nvar fib = function(n) {\n    // 备忘录全初始化为 0\n    const memo = new Array(n + 1).fill(0);\n    // 进行带备忘录的递归\n    return dp(memo, n);\n};\n\n// 带着备忘录进行递归\nvar dp = function(memo, n) {\n    // base case\n    if (n == 0 || n == 1) return n;\n    // 已经计算过，不用再计算了\n    if (memo[n] != 0) return memo[n];\n    memo[n] = dp(memo, n - 1) + dp(memo, n - 2);\n    return memo[n];\n};\n```\n\n![状态转移方程](/images/web-algorithm/numbers.png)\n\n三、dp 数组的迭代（递推）解法\n\n请注意：这次的解法是【自底向上】的，而前面两种是【自顶向下】的。\n\n```JavaScript\nvar fib = function(N) {\n    if (N === 0) return 0;\n    const dp = new Array(N + 1).fill(0);\n    // base case\n    dp[0] = 0; dp[1] = 1;\n    // 状态转移\n    for (let i = 2; i <= N; i++) {\n        dp[i] = dp[i - 1] + dp[i - 2];\n    }\n\n    return dp[N];\n};\n```\n\n* P322 【零钱兑换】\n\nTODO: 描述解题技巧\n\n![状态转移方程](/images/web-algorithm/coins.png)\n\n```JavaScript\n// 定义：要凑出金额 n，至少要 dp(coins, n) 个硬币\nfunction coinChange(coins, amount) {\n    // base case\n    if (amount == 0) return 0;\n    if (amount < 0) return -1;\n\n    let res = Infinity;\n    for (let coin of coins) {\n        // 计算子问题的结果\n        let subProblem = coinChange(coins, amount - coin);\n        // 子问题无解则跳过\n        if (subProblem == -1) continue;\n        // 在子问题中选择最优解，然后加一\n        res = Math.min(res, subProblem + 1);\n    }\n\n    return res == Infinity ? -1 : res;\n}\n```\n\n**个人体验来说，我更喜欢自底向上的迭代算法，更直观，更容易理解。**\n\n```JavaScript\nvar coinChange = function(coins, amount) {\n    var dp = new Array(amount + 1).fill(amount + 1);\n     // The size of the array is amount + 1, and the initial value is also amount + 1\n    //  dp[i] represents the minimum number of coins needed for the amount i\n    dp[0] = 0;\n    // The outer loop is traversing all the values of all states\n    for (var i = 0; i < dp.length; i++) {\n        // The inner loop is to find the minimum value of all choices\n        for (var coin of coins) {\n            // Sub-problems are unsolvable, skip\n            if (i - coin < 0) {\n                continue;\n            }\n            dp[i] = Math.min(dp[i], 1 + dp[i - coin]);\n\n        }\n    }\n    return (dp[amount] == amount + 1) ? -1 : dp[amount];\n};\n```\n\n相关问题：\n[70.排楼梯](https://leetcode-cn.com/problems/climbing-stairs/description/)\n[198. 打家劫舍](https://leetcode-cn.com/problems/house-robber/descrip+tion/)\n\n#### 0-1 背包模型（动态规划升级版）\n\nDP table 通常是一个数组，但在背包问题中，需要升级为二维数组，并求出对应二维下标的目标值是多少。\n\n```JavaScript\nint[][] dp[N+1][W+1]\ndp[0][..] = 0\ndp[..][0] = 0\n\nfor i in [1..N]:\n    for w in [1..W]:\n        dp[i][w] = max(\n            把物品 i 装进背包,\n            不把物品 i 装进背包\n        )\nreturn dp[N][W]\n```\n\n### 回溯算法（backtrack）\n\n应用场景：排列、组合、子集问题。\n\n套路框架：\n\n```JavaScript\nvar backtrack = function(root) {\n  if (root == null) return;\n\n  for (var i = 0; i < root.children.length; i++) {\n    var child = root.children[i];\n    // 做选择\n    printf(\"从 \" + root + \" 到 \" + child);\n    backtrack(child);\n    // 撤销选择\n    printf(\"从 \" + child + \" 到 \" + root);\n  }\n};\n```\n\n<span style=\"color: red\">牢记，核心中的核心：前序位置（的代码）是进入一个节点的时候，后序位置（的代码）是离开一个节点的时候！！！</span>\n\n\n\n### BFS（广度优先搜素）\n\nBFS 算法都是用**队列**这种数据结构，每次将一个节点周围的所有节点加入队列。\n每次把下一行的所有节点先存放在队列中，放到下一次轮询来遍历，以此类推。\n\n套路框架：\n\n```JavaScript\nfunction BFS(root) {\n    const queue = [] // 初始化队列queue\n    // 根结点首先入队\n    queue.push(root)\n    // 队列不为空，说明没有遍历完全\n    while(queue.length) {\n        const top = queue[0] // 取出队头元素\n        // 访问 top\n        console.log(top.val)\n        // 如果左子树存在，左子树入队\n        if(top.left) {\n            queue.push(top.left)\n        }\n        // 如果右子树存在，右子树入队\n        if(top.right) {\n            queue.push(top.right)\n        }\n        queue.shift() // 访问完毕，队头元素出队\n    }\n}\n```\n\n 111 题「二叉树的最小深度」\n\n### 二分搜索\n\n适用数据类型：有序数组。\n\n### 双指针\n\n适用类型：数组、链表、字符串。\n\n双指针分两种类型：__快慢指针和左右指针（对撞指针）__。\n\n#### 滑动窗口（快慢指针）\n\n适用数据类型：字符串、数组。\n\n套路框架：\n\n```JavaScript\nlet left = 0, right = 0;\nlet window = [];\nwhile (left < right && right < s.length) {\n    // 增大窗口\n    window.add(s[right]);\n    right++;\n\n    while (window needs shrink) {\n        // 缩小窗口\n        window.remove(s[left]);\n        left++;\n    }\n}\n```\n\n运用滑动窗口算法，具体要回答下面几个问题：\n\n1. 什么时候应该扩大窗口？\n2. 什么时候应该缩小窗口？\n3. 什么时候应该更新答案？\n\n#### 左右指针\n\n主要应用在**数组和字符串**上，因为该数据结构具备**前后下标**。\n\n关键字：**有序**和**数组**。\n\n相关问题：\n[1.两数之和](https://leetcode.cn/problems/two-sum/)\n[15. 三数之和](https://leetcode.cn/problems/3sum/description/)\n\n\n## 经验总结（重点浓缩版）\n\n1. 涉及链表操作、尤其是涉及结点删除的题目，建议大家写代码的时候直接把 dummy 节点（虚拟头节点）给用起来，建立好的编程习惯。\n\n```Javascript\nconst dummy = new ListNode()\n// 这里的 head 是链表原有的第一个结点\ndummy.next = head\n```\n\n\n2. 写算法题的小经验：如果有返回值，记得先写 return 。\n\n```Javascript\nfunction dp () {\n    const res = []\n    ...\n    return res\n}\n```\n\n3. 单链表常考的技巧就是双指针，特别出现【倒数】字眼（因为链表是不知道自身长度的）。\n\n```Javascript\nconst removeNthFromEnd = function(head, n) {\n    // 初始化 dummy 结点\n    const dummy = new ListNode()\n    // dummy指向头结点\n    dummy.next = head\n    // 初始化快慢指针，均指向dummy\n    let fast = dummy\n    let slow = dummy\n```\n\n\n\n"},{"title":"WEB：前端学习网站指南","url":"/2022/04/19/web-study/","content":"\n\n读书和学习是在别人思想和知识的帮助下，建立起自己的思想和知识。 ---普希金\n\n<!-- more -->\n\n***\n\n### 中文官网集\n\n毕竟是中文官网，看起来还是容易点的。\n\n* [印记中文](https://docschina.org/)\n\n### 吃灰收藏集\n\n收藏从未停止，学习从未开始。既然你进来了，那就翻开看看吧。\n\n* [github](https://github.com/zeuscoder?tab=stars)\n* [juejin](https://juejin.cn/user/4283353030729480/collections)\n\n### 付费收看区\n\n什么都没有学会，就学会了花钱。学到就是赚到，升职加薪不是梦。\n\n* [拉勾教育](https://kaiwu.lagou.com/hasBuy/special)\n* [掘金小册](https://juejin.cn/my-course)\n* [GitChat](https://gitbook.cn/gitchat/ordered/columns)\n* [珠峰培训](http://www.javascriptpeixun.cn/course/3709/task/248257/show#)\n\n### 前沿学习区\n\n除了上班，还要学习。学海无涯，总有一款你想看的前沿技术。\n\n* [奇舞周刊](https://weekly.75.team/)\n\n### 源码狂虐区\n\n[看源码](https://cloud.tencent.com/developer/article/1581855)\n\n* [React](https://react.iamkasong.com/preparation/idea.html#react%E7%90%86%E5%BF%B5)\n* [React](https://react.jokcy.me/)\n* [React](https://github.com/7kms/react-illustration-series)\n* [Vue3](https://kaiwu.lagou.com/course/courseInfo.htm?courseId=326#/detail/pc?id=4054)\n* [Vue3](https://github.com/cuixiaorui/mini-vue)\n* [Vue2](https://ustbhuangyi.github.io/vue-analysis/v2/prepare/)\n* [ElementUI](https://mp.weixin.qq.com/s?__biz=MzA3NTk4NjQ1OQ==&mid=2247484649&idx=1&sn=8ee67553193fda33e7c637568bb0a86f&chksm=9f69679da81eee8bba046776de07f8848ad9061e6c04ca781bf052fc9bcee70ea34a48c81864&token=103240474&lang=zh_CN#rd)\n\n### 算法必刷区\n\n考算法\n\n* [算法小册](https://juejin.cn/book/6844733800300150797/section/6844733800371453966)\n* [Leetcode 题解](https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.md#leetcode-%E9%A2%98%E8%A7%A3---%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92)\n"},{"title":"DevOps：常用快捷键备忘录","url":"/2021/11/27/common-shell/","content":"\n不同开发工具的频繁切换，记录下常用好用的快捷键，还是能省下不少时间的。\n\n<!-- more -->\n\n基于 Mac 环境下操作：\n\n### Shell\n\n#### 移动光标\n\n- 移动光标到命令行首：`Ctrl + a`\n- 移动光标到命令行尾：`Ctrl + e`\n- 移动到当前单词的开头：`Esc + b`\n- 移动光标到命令行尾：`Esc + f`\n- 光标在命令行中光标最后两次出现的位置间进行切换：`Ctrl + x + x`\n\n#### 删除命令\n\n- 剪切光标之前的一个词：`Ctrl + w`\n- 剪切光标之后的一个词：`Alt + d`\n- 从当前光标所在位置向左剪切全部命令：`Ctrl + u`\n- 从当前光标所在位置向右剪切全部命令：`Ctrl + k`\n\n#### 历史命令\n\n- 查看历史命令：`history`\n- 执行history历史命令列表中第num条命令：`!num`\n- 执行history历史命令列表中上一条命令：`!!`\n- 执行含有string字符串的最新命令：`!?string?`\n\n#### 其它\n\n- 按一次补全，按两次列出所有相关信息：`Tab`\n- 强制终止当前命令：`Ctrl + c`\n- __清屏__：`Ctrl + l`\n\n#### Shell 脚本教程\n\n[脚本教程](https://www.runoob.com/linux/linux-shell.html)\n\n***\n\n### VS Code\n\nVS Code中的每个命令也可以通过使用 `Ctrl + Shift + P` 和搜索查询的命令提示符来执行。\n\n#### 代码命令\n\n- 选择当前行：`Ctrl + K`\n- 移动当前行：`Alt + up/down`\n- 复制当前行：`Shift + Alt +up/down`\n- 删除当前行：`Ctrl + Shift + K`\n\n#### 查找命令\n\n- 查找跳转到指定行：`Ctrl + G`\n\n#### 工具命令\n\n- 控制台终端显示与隐藏：`Ctrl + ～`\n- 左侧目录栏显示与隐藏：`Ctrl + B`\n- 新建一个窗口：`Ctrl + Shift + N`\n\n***\n\n### Vim\n\nvi 的最常用的两种模式： __普通模式__ | __输入模式__\n\n- 按指令 `i` 后会在光标位置开始输入，这时候左下角会有 __--- INSERT ---__ 提示，表示当前正在输入模式。\n- 要切换到 普通模式 只需要按一下键盘的最左上角 `esc` 键即可。\n\n#### 基本操作\n\n- 存储文本：`:w`\n- 退出文本：`:q`\n- 退出不保存文本：`:q!`\n- 保存并退出文本：`:wq`\n- 显示行号：`:set nu`\n- 不显示行号：`:set nonu`\n- 删除当前行：`dd`\n"},{"title":"DevOps：Nginx 安装部署 SSL 证书","url":"/2021/11/24/nginx-https/","content":"\n接着上次部署遇到的问题，简单描述下云服务器安装 SSL 证书的过程。\n\n<!-- more -->\n\n多数云服务器网站都有部署相关的[教程](https://cloud.tencent.com/document/product/1207/47027)，这里就基于腾讯云服务器`东拼西凑`下实现步骤。\n\n### 运行环境\n\n- 服务器操作系统：CentOS 8.0\n- 服务器 Nginx 版本：Nginx 1.18.0\n- 本地 SSH 工具：Mac Termius\n\n#### 安装 Nginx\n\n通过账号密码登录到 CentOS 服务器，[安装 Nginx 步骤](https://cloud.tencent.com/document/product/214/33413)：\n\n```powershell\n# 安装 Nginx：\nyum -y install nginx\n# 查看 Nginx 版本\nnginx -v\n# 查看 Nginx 安装目录\nrpm -ql nginx\n# 启动 Nginx\nservice nginx start\n```\n\n然后访问云服务器的公网 IP，如果可以显示出 Nginx 默认的静态页面，则证明 Nginx 部署成功。\n\n> Nginx 的默认端口是80，如果想修改端口请修改配置文件并重启 Nginx。\n\n### 证书部署\n\nSSL 证书是需要 CA 颁发的，在购买域名时一般都会有个一年的免费证书。为了测试方便，也可以使用自签名证书。\n\n#### CA 证书\n\n前往服务器 `SSL 证书管理控制台` 中下载 SSL 证书\n\n#### 自签名证书\n\n生成自签名证书，可以通过[该教程](https://cloud.tencent.com/developer/article/1160294)生成。\n\n#### 证书安装\n\n最后生成的证书种有两个文件：__**.crt 证书文件__ 和 __**.key 私钥文件__。\n\n我们需要做的是把这两个文件放到服务器的目录以及修改 Nginx 配置文件，[具体教程](https://cloud.tencent.com/document/product/1207/47027)：\n\n1. 我是通过本地 Termius 软件左侧的 `SFTP` 功能可视化放进两个文件的，也可以通过本地 `scp` 命令或者在服务器 `rz` 命令来传输文件，这里放在了服务器的 `/etc/nginx` 目录下。\n\n2. 编辑 Nginx 默认配置文件目录中的 nginx.conf 文件，`vim /etc/nginx/nginx.conf`，在 http 字段里添加：\n\n```powershell\nserver {\n  listen         443;\n  server_name  ***.com;    #更换上所绑定的域名，一定要是申请了证书的域名\n  ssl                  on;     #这一行是另外添加的，意思是打开ssl功能，一定要添加。\n  ssl_certificate      /etc/nginx/****.crt;  #这是下载下来的nginx证书的crt文件路径，绝对或者相对路径都可以\n  ssl_certificate_key  /etc/nginx/******.key;   #和crt的规则一样\n  ssl_session_cache    shared:SSL:1m;\n  ssl_session_timeout  5m;\n  ssl_ciphers  HIGH:!aNULL:!MD5;\n  ssl_prefer_server_ciphers  on;\n  location / {\n    root   html;\n    index  index.html index.htm;\n  }\n}\n```\n\n保存修改后退出，运行 `nginx -s reload` 重启 Nginx 生效。\n\n#### 设置 HTTP 请求自动跳转 HTTPS\n\n还可以通过配置服务器，让其自动将 HTTP 的请求重定向到 HTTPS。编辑 Nginx 默认配置文件目录中的 nginx.conf 文件，`vim /etc/nginx/nginx.conf`，在 http 字段里添加：\n\n```powershell\nserver {\n    listen 80;\n    server_name cloud.tencent.com;    #填写您的证书绑定的域名，例如：cloud.tencent.com\n    return 301 https://$host$request_uri;       #将http的域名请求转成https\n}\n```\n\n附上：[其他教程](https://cloud.tencent.com/developer/article/1611144)\n"},{"title":"DevOps：Nginx 部署的一个有趣问题","url":"/2021/11/23/nginx-error/","content":"\n\n浏览器访问服务器 IP 地址，页面显示的是 Apache 的默认页面。但是服务器起的是 Nginx 服务。\n\n<!-- more -->\n\n### 背景\n\nUbuntu 云服务器部署 SSL 证书，先安装了 Apache 服务，停止服务后，重新安装了 Nginx 服务。\n\n### 排查问题过程\n\n- 首先通过 `lsof -i:80` 查看端口占用情况：\n\n![PCM](/images/nginx-error/lsof.png)\n\n- 发现端口都是 nginx 服务在占用，然后打算重启 nginx 服务试试：`nginx -s reload`，发现页面显示的还是 Apache 的默认页面。\n\n- 再通过 `kill -9 PID` 命令杀掉了 nginx 对应的进程后（或者可以通过 `nginx -s stop` 停止 nginx 服务），重新访问 IP 发现无法访问，证明这个 80 端口的确是 nginx 起的服务。\n\n- 接下来就查看 nginx 配置文件指向的页面到底有没有问题，`cd /var/www/html` 目录后，发现目录下竟然有两个 html 文件：分别是 index.html 和 index.nginx-debian.html，`vim index.html` 一看，是 apache 的页面，真相大白。\n\n### 解决方法\n\n最后通过重命名 `mv index.nginx-debian.html index.html` 替换默认的 index.html。\n\n总结：安装 Apache 服务时生成了默认的 index.html 文件，而后安装的 Nginx 服务生成的默认文件无法替换，才导致起的 Nginx 服务，显示 Apache 页面的有趣问题。\n"},{"title":"WEB：Audio 音频基础","url":"/2021/06/27/web-audio/","content":"\nWeb Audio API (AduioContext) 实在太多了，当然玩起来也会很有趣。\n\n<!-- more -->\n\n![PCM](/images/web-audio/audio.jpeg)\n\n## 基础概念\n\n声音：根据初中物理知识，声音是由物体振动产生的__声波__，通过介质（空气或固体、液体）传播，被人或动物听觉器官所感知的波动现象。气压的变化会产生声音信号，声音是一种波。人的耳朵可以听到20~20000Hz的声音，最敏感是200~800Hz之间的声音，蚊子挥动翅膀的频率刚好就在 600Hz 左右（频率越高音调 pitch 或 key 越高）。\n\n我们可以测量压力变化的强度，并绘制随时间变化的测量值。其中音频采样，是把声音从模拟信号转换为数字信号，所得的被称为 `PCM` 。\n\n![PCM](/images/web-audio/audio-steps.png)\n\n- 模拟信号：通常指连续的物理量，例如温度、湿度、速度、光照、声响等\n- 数字信号：通常是模拟信号经过采样、量化和编码等几个步骤后得到的\n\n## PCM\n\n `PCM` (脉冲编码调制）有[三要素](https://www.cnblogs.com/yongdaimi/p/10722355.html)：声道数（channel number）、采样率（sample rate）、采样位数或位深（bit depth）。\n\n![PCM](/images/web-audio/pcm.png)\n\n> PCM 是一种编码格式，WAV 是一种文件格式。\n\n### 声道数\n\n声道数，常见的声道（喇叭数量）类型：\n\n- 单声道：Mono，单喇叭或者两个喇叭输出同一个声道的声音（**在线 ASR 录音用的是单声道**）\n- 双声道：Stereo，分左声道和右声道，更加有空间效果\n\n![双声道](/images/web-audio/channel.png)\n\n### 采样率\n\n采样率：每秒对声音进行采集的次数，同样也是所得的数字信号的每秒样本数，单位为 Hz。**采样率越高，声音的质量就越好，声音的还原就越真实越自然。**\n\n当然人耳对频率识别范围有限，超过 48k 的采样率意义不大，一般 20k 可以满足， **22050 Hz** 为常用的采样频率。\n\n- 采样率：数字音频系统记录声音信号时每秒采集的数据个数\n- 声音频率：物体每秒的震动频率\n\n> [声音频率和采样率的区别](https://www.zhihu.com/question/27644914)：其实它们之间没有直接关系，不是同一回事。\n\n![采样率](/images/web-audio/sample-rate.png)\n\n### 采样位数\n\n采样位数：采样后，将采样的单个样本进行量化，用来衡量声音波动变化的一个参数，也可以说是声卡的分辨率。**它的数值越大，分辨率也就越高，所发出声音的能力就越强，声音越好。**\n\nn-bit 指的是声音的强度（振幅）被均分为 2^n 级，常用的有 8bit（1字节）、`16bit（2字节）`、32bit（4字节）。振幅越大，音量越大。\n\n在把量化所得的结果，即单个声道的样本，以`二进制`的码字进行存放。\n\n> B for Byte (字节)， b for bit（位）。1 Byte = 8 bit\n\n![采样位数](/images/web-audio/bit-depth.png)\n\n### 比特率\n\n比特率：每秒的传输速率，单位为 bps。\n\n采样率为 16khz，位深为 16 bit，单声道的比特率为 `16000 * 16 * 1 = 256000 b/s（比特/秒）`，转化为字节 `256000 / 8 = 32000 B/s（字节/秒）`。\n\n> 通常说的 10M 带宽为 10Mbps（这里是比特），下载速率为 10M / 8 = 1.25 MB/s（这里是字节）\n\n## 音频采集\n\n讲述完 PCM 的基础概念后，开始谈谈如何通过浏览器实现音频采集。\n\n### getUserMedia\n\n实现媒体音频采集的是 `WebRTC` 技术，使用的方法是 `navigator.mediaDevices.getUserMedia()`，需要做低版本兼容。麦克风或摄像头的启用涉及到安全隐私，通常网页中会有弹框提示，用户确认后才可启用相关功能，调用成功后，回调函数中就可以得到**多媒体流对象**，后续的工作就是围绕这个`媒体流(MediaStream)`展开的。\n\n![wav-audio-api](/images/web-audio/web-audio-api.png)\n\n```Javascript\nnavigator.mediaDevices.getUserMedia({audio:true})\n  .then(mediaStream=> {\n    // audioInput 表示音频源节点\n    const audioInput = audioContext.createMediaStreamSource(stream);\n    // scriptProcessorNode 为关键节点\n    const recorder = audioContext.createScriptProcessor(4096, 1, 1)\n    // 音频采集，每采集完样本帧预设数值（4096）后会触发 onaudioprocess 接口一次\n    recorder.onaudioprocess = (e: {\n      inputBuffer: AudioBuffer;\n      outputBuffer: AudioBuffer;\n    }) => {\n      // 核心：处理 AudioBuffer 逻辑，假设是单声道\n      encodePCM(compress(e.inputBuffer.getChannelData(0)))\n    }\n    audioInput.connect(recorder);\n    recorder.connect(audioContext.destination);\n  })\n```\n\n核心过程：\n\n1. 通过 createMediaStreamSource 方法创建 MediaStreamAudioSourceNode 音频源节点\n\n2. 通过 createScriptProcessor 方法创建 scriptProcessorNode 脚本处理节点\n\n3. 通过 scriptProcessorNode 节点的 onaudioprocess 回调函数**处理音频逻辑**\n\n#### [AudioBuffer](https://developer.mozilla.org/zh-CN/docs/Web/API/AudioBuffer)\n\nAudioBuffer接口表示存在内存里的一段短小的音频资源。缓存区（buffer）包含以下数据：不间断的 IEEE754 32 位线性PCM，从-1到1的范围额定，就是说，32位的浮点缓存区的每个样本在-1.0到1.0之间。\n\n#### 采样率的转写\n\n音频是由浏览器采样率（一般为 48k）采集的，需要进行转写为我们真正需要的采样率（假设 16k），只支持由高转低，**具体为按照输入采样率和输出采样率的比例，每隔比例位数取1位**。\n\n```Javascript\n/**\n * 根据输入和输出的采样率压缩数据，\n * 比如输入的采样率是48k的，我们需要的是（输出）的是16k的，由于48k与16k是3倍关系，\n * 所以输入数据中每隔3取1位\n *\n * @param {float32array} data       [-1, 1]的pcm数据\n * @param {number} inputSampleRate  输入采样率\n * @param {number} outputSampleRate 输出采样率\n * @returns  {float32array}         压缩处理后的二进制数据\n */\n  function interleave(data: Float32Array, inputSampleRate: number, outputSampleRate: number) {\n    const t = data.length;\n    let s = 0;\n    const o = inputSampleRate / outputSampleRate;\n    const u = Math.ceil((t * outputSampleRate) / inputSampleRate);\n    const a = new Float32Array(u);\n    for (let i = 0; i < u; i++) {\n      a[i] = data[Math.floor(s)];\n      s += o;\n    }\n    return a;\n  }\n```\n\n#### 位深的转写\n\n采样率的问题解决完，还需要将音频流转为对应位深，生成长度为（位深/8 * 音频原长度）的 Uint8Array。\n\n```Javascript\n// bit reduce and convert to integer\nswitch (this.bytesPerSample) {\n  case 4: // 32 bits signed\n    sample = sample * 2147483647.5 - 0.5;\n    reducedData[outputIndex] = sample;\n    // tslint:disable-next-line:no-bitwise\n    reducedData[outputIndex + 1] = sample >> 8;\n    // tslint:disable-next-line:no-bitwise\n    reducedData[outputIndex + 2] = sample >> 16;\n    // tslint:disable-next-line:no-bitwise\n    reducedData[outputIndex + 3] = sample >> 24;\n    break;\n\n  case 3: // 24 bits signed\n    sample = sample * 8388607.5 - 0.5;\n    reducedData[outputIndex] = sample;\n    // tslint:disable-next-line:no-bitwise\n    reducedData[outputIndex + 1] = sample >> 8;\n    // tslint:disable-next-line:no-bitwise\n    reducedData[outputIndex + 2] = sample >> 16;\n    break;\n\n  case 2: // 16 bits signed\n    sample = sample * 32767.5 - 0.5;\n    reducedData[outputIndex] = sample;\n    // tslint:disable-next-line:no-bitwise\n    reducedData[outputIndex + 1] = sample >> 8;\n    break;\n\n  case 1: // 8 bits unsigned\n    reducedData[outputIndex] = (sample + 1) * 127.5;\n    break;\n```\n\n### HTTPS vs HTTP\n\n获取麦克风权限时需要 https 协议下验证，如何能在 http 网站情况下也可以获取[权限](https://support.scandit.com/hc/en-us/articles/360002743551-Do-I-really-need-to-serve-my-site-with-https-)。\n\n> chrome://flags/#unsafely-treat-insecure-origin-as-secure\n\n本地服务 iOS wss 连接断开问题，[需要开启指定的新特性](https://stackoverflow.com/questions/37898048/websocket-network-error-osstatus-error-9807-invalid-certificate-chain/42148960)\n\n> Settings（设置） > Safari > Advanced（高级） > Experimental Features > NSURLSession Websocket\n\n### 设备兼容情况\n\nAndroid WebView 和 Chrome 支持程度较好，Mac 和 iOS Safari 支持系统版本 11 及以上，**iOS WKWebView 支持系统版本 14.3 及以上（iOS 微信内置浏览器和小程序 web-view 使用的是 WKWebView）**。\n\n![getUserMedia](/images/web-audio/getUserMedia.jpeg)\n\n## 音频播放\n\n下一步，需要了解采集后得到的 PCM 是如何播放：PCM 是无法直接播放的，需要给 PCM **添加 wav 头部**，才能通过 AudioContext 转换为 AudioBuffer 播放。\n\n### 转换\n\nwav 格式是一种无损格式，是依据规范在 pcm 数据前添加 **44** 个__字节__长度用来填充一些声明信息的。wav 头部有 44 个字节，具体对应如下：\n\n![wav 头部](/images/web-audio/wav-header.png)\n\n<details>\n<summary>如何添加 wav 头部代码</summary>\n\n```Javascript\n  public generateWavHeader(options: IWavHeaderOptions): ArrayBuffer {\n    const {\n      numFrames = originArrayBuffer.byteLength, // originArrayBuffer 为源 PCM\n      numChannels = 1,\n      sampleRate = 16000,\n      bytesPerSample = 2\n    } = options;\n    const blockAlign = numChannels * bytesPerSample;\n    const byteRate = sampleRate * blockAlign;\n    const chunkSize = (numFrames as number) * blockAlign;\n\n    const buffer = new ArrayBuffer(44);\n    const dataview = new DataView(buffer);\n\n    let position = 0;\n    position = this.dataviewWriteString(dataview, 'RIFF', position); // ChunkID\n    position = this.dataviewWriteUint32(dataview, chunkSize + 36, position); // ChunkSize\n    position = this.dataviewWriteString(dataview, 'WAVE', position); // Format\n    position = this.dataviewWriteString(dataview, 'fmt ', position); // Subchunk1ID\n    position = this.dataviewWriteUint32(dataview, 16, position); // Subchunk1Size\n    position = this.dataviewWriteUint16(dataview, 1, position); // AudioFormat\n    position = this.dataviewWriteUint16(dataview, numChannels, position); // NumChannels\n    position = this.dataviewWriteUint32(dataview, sampleRate, position); // SampleRate\n    position = this.dataviewWriteUint32(dataview, byteRate, position); // ByteRate\n    position = this.dataviewWriteUint16(dataview, blockAlign, position); // BlockAlign\n    position = this.dataviewWriteUint16(dataview, bytesPerSample * 8, position); // BitsPerSample\n    position = this.dataviewWriteString(dataview, 'data', position); // Subchunk2ID\n    this.dataviewWriteUint32(dataview, chunkSize, position); //  Subchunk2Size\n\n    return buffer;\n  }\n\n  public concatArrayBuffer(...buffers: ArrayBuffer[]): ArrayBuffer {\n    const newBufferLength = buffers.reduce((total, buffer) => {\n      total += buffer.byteLength;\n      return total;\n    }, 0);\n    const newBuffer = new Uint8Array(newBufferLength);\n\n    let bufferIndex = 0;\n    buffers.forEach((buffer) => {\n      newBuffer.set(new Uint8Array(buffer), bufferIndex);\n      bufferIndex += buffer.byteLength;\n    });\n\n    return newBuffer.buffer;\n  }\n\n  private dataviewWriteString(\n    dataview: DataView,\n    str: string,\n    position: number\n  ): number {\n    for (let i = 0; i < str.length; i++) {\n      dataview.setUint8(position + i, str.charCodeAt(i));\n    }\n    position += str.length;\n    return position;\n  }\n\n  private dataviewWriteUint32(\n    dataview: DataView,\n    num: number,\n    position: number\n  ): number {\n    dataview.setUint32(position, num, true);\n    position += 4;\n    return position;\n  }\n\n  private dataviewWriteUint16(\n    dataview: DataView,\n    num: number,\n    position: number\n  ): number {\n    dataview.setUint16(position, num, true);\n    position += 2;\n    return position;\n  }\n```\n\n</details>\n\n通过浏览器打印日志或者通过记事本打开 WAV 格式的音频 可以发现：\n\n![wav 头部](/images/web-audio/arrayBuffer.png)\n\nWAV文件格式的结构组成，对该内容进行分析如下：\n\n```Javascript\n52 49 46 46（ChunkID，4 字节） = ‘RIFF’\n\n24 42 04 00 （ChunkSize，4 字节）=  279076  = 279084 - 8\n\n57 41 56 45 （Format，4 字节） = ‘WAVE’\n\n66 6D 74 20 （Subchunk1ID，4 字节） = ‘fmt ’\n\n10 00 00 00 (Subchunk1 Size，4 字节) = 16\n\n01 00（AudioFormate，2 字节） = 音频格式 = 1\n\n01 00 （NumChannels，2 字节）= 声道数 = 1\n\n80 3E 00 00（SampleRate，4 字节）= 采样率 = 16000\n\n00 7D 00 00（ByteRate，4 字节）= 字节率 = 32000 = 16000 * 16 / 8\n\n02 00 （BlockAlign，2 字节）= 内存对齐 = 2\n\n10 00 （BitsPerSample）= 每个样本的位深度 =  16\n\n64 61 74 61（Subchunk2ID，4 字节） = ‘data’\n\n00 42 04 00 (Subchunk2 Size，4 字节) = 音频PCM数据大小 = 279040 = 279084 - 44\n```\n\n![wav 头部分析](/images/web-audio/wav-header-detail.jpeg)\n\n可以通过 `file` 命令查看 wav 头部简要信息\n\n```Bash\n$file test.wav\n```\n\n![wav-file](/images/web-audio/wav-file-detail.png)\n\n### 解码(decode)\n\n通过 `AudioContext` 的 `decodeAudioData` API 解码 wav 文件中的 ArrayBuffer，转换为 Audiobuffer。\n\n```Javascript\nfunction playWav(wavBuffer: ArrayBuffer) {\n  const AudioContext = window.AudioContext || window.webkitAudioContext;\n  const audioCtx = new AudioContext();\n\n  // Safari 不支持 decodeAudioData promise 模式\n  audioCtx.decodeAudioData(\n    wavBuffer,\n    (audioBuffer) => {},\n    (err) => {}\n  );\n}\n```\n\n### 降噪（消除毛刺）\n\n播放短小的 Audiobuffer 时开始和结束可能会有细微的噪音出现，其中[降噪](https://stackoverflow.com/questions/53100047/why-state-can-be-invalid-in-web-audio-in-safari-after-resume)的方法如下：\n\n```Javascript\nfunction deNoising(buffer: AudioBuffer) {\n  const fixRange = 100; // 该数值根据情况调整\n  const audioBufferArray = buffer.getChannelData(0);\n  const length = audioBufferArray.length;\n\n  for (let i = 0; i < fixRange; i++) {\n    audioBufferArray[i] = (audioBufferArray[i] * i) / fixRange; // fade in\n    audioBufferArray[length - i - 1] =\n      (audioBufferArray[length - i - 1] * i) / fixRange; // fade out\n  }\n}\n```\n\n### 播放\n\n通过 createBufferSource() 方法用于创建一个新的 `AudioBufferSourceNode` 接口, 该接口可以通过 AudioBuffer 对象来播放音频数据。再连接到 AudioContext 中所有音频（节点）的最终目标节点，一般是音频渲染设备，比如扬声器。\n\n```Javascript\nfunction play(buffer: AudioBuffer) {\n  const AudioContext = window.AudioContext || window.webkitAudioContext;\n  const audioCtx = new AudioContext();\n  const source = audioCtx.createBufferSource();\n\n  source.buffer = buffer;\n  source.connect(audioCtx.destination);\n  source.start();\n}\n```\n\n### PCM 播放工具\n\n音频混音器：[Audacity](https://www.audacityteam.org/)\n\n![audacity](/images/web-audio/audacity.png)\n\n## ArrayBuffer\n\n`ArrayBuffer` 对象用来表示通用的、*固定长度*的__原始二进制数据缓冲区__（预分配内存）。\n\n```Javascript\n const buffer = new ArrayBuffer(16); // 16 字节长度的 ArrayBuffer\n console.log(buffer.byteLength);\n```\n\n- 单位是__字节__，它是一个字节数组，通常在其他语言中称为 byte array\n- 不能__直接操作__ `ArrayBuffer` 的内容，只能通过 DataView 或者定型数组对象操作\n- ArrayBuffer 分配的内存__不能超过__ Number.MAX_SAFE_INTEGER(2^53 - 1) 字节\n\n### DataView\n\n`DataView` 视图是一个可以从二进制 *ArrayBuffer* 对象中读写多种数值类型的底层接口，使用它时不用考虑不同平台的`字节序`问题。\n\n> 必须在对已有的 ArrayBuffer 读取或写入时才能创建 DataView 实例。\n\n```Javascript\n const buffer = new ArrayBuffer(16)\n\n const dataview = new DataView(buffer);\n dataview.setUint8(0, 255);\n dataview.setUint8(1, 0xff);\n console.log(dataview.byteOffset);\n console.log(dataview.byteLength);\n console.log(dataview.buffer === buffer); // DataViiew 维护着对该缓冲实例的引用\n```\n\n要通过 DataView 读取缓冲，还需要以下几点：\n\n- 首先是要读或者写的字节偏移量。可以看出 DataView 中的某种“地址”\n- DataView 应该使用 ElementType 来实现 Javascript 的 Number 类型到缓冲内二进制格式的转换\n- 最后是内存中值的字节序。默认为大端字节序\n\n### 定型数组\n\n![DataView Element Type](/images/web-audio/dataview-type.jpeg)\n\n### 字节序\n\n[字节序](https://developer.mozilla.org/zh-CN/docs/Glossary/Endianness)，或字节顺序（\"Endian\"、\"endianness\" 或 \"byte-order\"），描述了计算机如何组织字节，组成对应的数字。\n\n每一个字节可以存储一个 8 位（bit）的数字（0x00-0xff），存储更大数字需要多个字节，现在大部分需占用多字节的数字排列方式是 little-endian（低位字节排放在内存中低地址端，高字节排放在内存的高地址端），与 big-endian 相反。\n\n举例：用不同字节序存储数字 `0x12345678`(即十进制中的 305 419 896)\n\n- little-endian：`0x78 0x56 0x34 0x12`\n- big-endian：`0x12 0x34 0x56 0x78`\n\n## 问题总结\n\n总结下处理音频时遇到的问题：iOS 和 Safari 问题就是特别多。\n\n### iOS Q&A\n\n#### 1. Safari 调用 AudioContext 的次数有限\n\n问题：多次生成 AudioContext 实例会报错 `null is not an object`\n\n方案：销毁  AudioContext 实例\n\n```Javascript\nAudioContext.close(); // 关闭一个音频环境, 释放任何正在使用系统资源的音频.\n```\n\n#### 2. Safari 不支持 AudioContext.decodeAudio Promise\n\n问题：AudioContext.decodeAudio Promise Safari 下会报错\n\n方案：直接使用回调函数，不使用 Promise\n\n#### 3. iOS AudioContext 播放没有声音\n\n问题：点击 Audio 标签播放有声音，AudioContext 播放没有声音\n\n方案：检查后发现 AudioContext 在 iOS 静音模式下无法播放声音，其次判断 AudioContext 是否处于 running 状态，否则调用\n\n```Javascript\naudioContext.resume();\n```\n\n#### 4. iOS Safari 不触发 canplaythrough 事件\n\n问题：iOS Audio 标签加载资源后 Safari 不触发 canplaythrough 事件\n\n方案：设置 src 后调用 load 方法（iOS 14 及以上）\n\n```Javascript\nconst audio = document.createElement('AUDIO');\naudio.addEventListener('canplaythrough', loadedVideo, false);\naudio.src = url;\naudio.load(); // 关键代码\n```\n\n#### 5. iOS Safari 显示播放时间不正确\n\n问题：iOS Safari Audio 标签加载资源后显示的时间长度不正确\n\n方案：头部部分字段值不正确\n\n#### 6. iPad 14.8 播放时间不正确\n\n问题：iPad 14.8 AudioContext 播放的时间跟理论上（source.buffer.duration 或者 arraybuffer/samplerate/2）计算的时间不一致，实际上播放时间更短\n\n方案：使用 source.onended 监听回调函数替代\n\n最后寄语：WebRTC 和 FFmpeg 太多要学习的，后续再进一步研究。\n\n参考文章：\n\n[音频属性相关：声道、采样率、采样位数、样本格式、比特率](https://www.cnblogs.com/yongdaimi/p/10722355.html)\n\n[让音视频学习变得简单之音频深度学习](https://rtcdeveloper.com/t/topic/21480)\n\n[WebRTC在浏览器中如何获得指定格式的PCM数据](https://www.cnblogs.com/dashnowords/p/11795251.html)\n\n[WAVE PCM soundfile format](http://soundfile.sapp.org/doc/WaveFormat/)\n\n[ArrayBuffer MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer)\n\nJavascript 高级程序设计（第四版）：定型数组\n"},{"title":"JS：函数式编程小结","url":"/2021/02/20/js-function-programming/","content":"\nJavascript 到底适不适合函数式编程呢？\n\n<!-- more -->\n\n在 2021 年看完的第一本书《Javascript 函数式编程指南》，接着看完了《前端函数式编程演进》，确实让我稍微打开了函数式编程的大门。\n\n{% pdf /images/js-function-programming/Javascript_函数式编程.pdf %}"},{"title":"DevOps：Docker 实操笔记","url":"/2020/09/06/docker/","content":"\nDocker 是一个用于开发，发布和运行应用程序的开放平台，也是跨平台的解决方案。\n\n<!-- more -->\n\n首先来看看这张 docker 的架构图：\n\n![架构图](/images/docker/docker-architecture.webp)\n\n总体来讲，必须了解 Docker 三剑客概念：仓库、镜像、容器。\n\n### 常见操作\n\n* 拉取镜像：`docker pull <image_name>`\n* 分析镜像：`docker inspect <image_name>`\n* 列出本地镜像列表：`docker images`\n\n\n调试两部曲：\n\n* 列出所有容器：`docker ps`\n* 进入容器调试：`docker exec -it <container_name> sh`\n\n\n### Dockerfile\n\nDockerfile 的各个指令可参考 [Dockerfile Reference](https://docs.docker.com/engine/reference/builder/)。\n\n使用 `docker build` 构建镜像，`docker build` 会使用当前目录的 Dockerfile 构建镜像，\n\n* 构建镜像：`docker build`\n* 启动容器：`docker run <image_name>`\n\n最后来看看 [Vue-cli 项目部署 Dockerfile 实例](https://cli.vuejs.org/zh/guide/deployment.html#bitbucket-cloud)：\n\n```Docker\nFROM node:10\nCOPY ./ /app\nWORKDIR /app\nRUN npm install && npm run build\n\nFROM nginx\nRUN mkdir /app\nCOPY --from=0 /app/dist /app\nCOPY nginx.conf /etc/nginx/nginx.conf\n```\n\n### docker compose\n\n启动 docker-compose.yaml 文件：`docker compose up`\n"},{"title":"JS：浅析 mpvue","url":"/2020/05/03/js-mpvue/","content":"\n[mpvue](https://github.com/Meituan-Dianping/mpvue) 是一个使用 Vue.js 开发**小程序**的前端框架。框架基于 Vue.js 核心，mpvue 修改了 Vue.js 的 `runtime` 和 `compiler` 实现，使其可以运行在小程序环境中，从而为小程序开发引入了整套 Vue.js 开发体验。\n\n> 引用自 [mpvue](http://mpvue.com/) 官网的介绍。\n<!-- more -->\n\n基于官方的解释，可以初步认为 mpvue 是：\n\n* 基于 Vue.js 源码修改，是小程序获得 Vue.js 的开发体验；\n* 修改 Vue.js 的 `runtime` 和 `compiler` 源码，兼容小程序环境。\n\n上述两点是全文的**核心**。\n\n关于 mpvue 的基础用法，请参考 [mpvue](http://mpvue.com/) 官网，这里不再详细介绍。\n\n### 构建流程\n\n首先 mpvue 借鉴了 Vue 的实现思路，实现了与其类似的生态：\n\n* mpvue.js：mpvue 的小程序核心库；\n* mpvue-quickstart：基于 Vue-CLI 2.0 的 mpvue 脚手架；\n* mpvue-loader：实现自定义 .vue 文件的解析，将其解析为 wxml、wxss 和 js 文件。\n\n① 通过 `mpvue-quickstart` 快速构建 mpvue 项目：\n\n```Node\nvue init mpvue/mpvue-quickstart mpvue-project\n```\n\n② `mpvue` 通过 `webpack` 构建和 `mpvue-loader` 解析将 .vue 文件转化为小程序能够识别的 wxml、wxss 和 js 文件\n\n```Javascript\n{\n    test: /\\.vue$/,\n    loader: 'mpvue-loader',\n    options: vueLoaderConfig\n}\n```\n\n在 `mpvue-loader` 中，使用了 `mpvue-template-compiler` 对 .vue 文件中的 `template` 进行了解析。`mpvue-template-compiler` 是核心的解析逻辑，将 .vue 文件中的 `template` 解析为小程序 `wxml` 对应的字符串。\n\n### 构建模式\n\nmpvue 的构建过程中分为 dev 模式和 build 模式：\n\n* dev 模式：使用了 source-map 模式，增加了对文件的监听；\n* build 模式：关闭了 source-map 模式，一次性构建，且压缩源码。\n\n在 dev 模式下，使用了 `webpack-dev-middleware-hard-disk` 进行文件修改的监听，每次对代码进行修改，都会触发 `webpack` 重新 `compiler`。\n\n### 实例化\n\n前置条件：[浅析 Vue](https://zeuscoder.github.io/2019/07/23/js-vue/)。\n\nmpvue 的分析是从 `const app = new Vue(App)` 开始的。\n\n由于 mpvue 是基于 Vue.js 源码修改的，源码执行流程与 Vue.js 大致相同。Vue 的实例化从 `_init` 方法开始：\n\n```Javascript\ninitLifecycle(vm);\ninitEvents(vm);\ninitRender(vm);\ncallHook(vm, 'beforeCreate');\ninitInjections(vm); // resolve injections before data/props\ninitState(vm);\ninitProvide(vm); // resolve provide after data/props\ncallHook(vm, 'created');\n\nif (vm.$options.el) {\n    vm.$mount(vm.$options.el);\n}\n```\n\n1. 首先 `initRender` 函数中的 `vm.$createElement` 在小程序中并不生效，小程序渲染逻辑与 Web 不同，小程序通过 wxml 对界面进行渲染，可以忽略 `initRender` 函数。\n2. 然后 `initState` 函数完成了 `props`、`methods`、`data`、`computed` 和 `watch` 5 个属性的初始化。\n3. 最后在调用了 `beforeCreate` 和 `created` 生命回调函数，完成 Vue 实例化后，继续执行 `$mount` 方法。\n\nmpvue 的 `$mount` 方法定义在 `platform/mp/runtime/index.js` 中，`platform` 目录存放了区别 `mpvue`、`web` 和 `weex` 的 **`runtime` 和 `compiler`**。\n\n```Javascript\n// public mount method\nVue.prototype.$mount = function (el, hydrating) {\n    // 初始化小程序生命周期相关\n    const options = this.$options\n\n    if (options && (options.render || options.mpType)) {\n        const { mpType = 'page' } = options\n        return this._initMP(mpType, () => {\n            return mountComponent(this, undefined, undefined)\n        })\n    } else {\n        return mountComponent(this, undefined, undefined)\n    }\n}\n```\n\n`$mount` 方法主要判断 `mpType` 的类型（默认值是 page），实例化 App 或 Page。mpvue 与 vue 的不同之处在于 mpvue 将不执行界面的更新行为，只负责更新数据，其更新行为都将交由小程序框架程序处理。\n\n`_initMP` 方法位于 /packages/mpvue/index.js 中：\n\n```Javascript\nfunction initMP (mpType, next) {\n    if (mp.status) {\n        // 处理子组件的小程序生命周期\n        if (mpType === 'app') {\n            callHook$1(this, 'onLaunch', mp.appOptions);\n        } else {\n            callHook$1(this, 'onLoad', mp.query);\n            callHook$1(this, 'onReady');\n        }\n        return next()\n    }\n\n    mp.mpType = mpType;\n    mp.status = 'register';\n\n    // 简化\n    createMP()\n}\n```\n\n注：`MPPage` 源码位于 `test/mp/helpers/mp.runtime.js`。\n\n`createMP` 方法调用 global 方法实例化 App 或 Page 对象，其中 global.App 和 global.Page 都继承自 `MPPage`。其构造函数会调用 `_initLifecycle` 函数，会分别执行 `onLaunch` 和 `onShow` 或 `onLoad`、`onReady` 和 `onShow` 回调函数，执行完毕后会调用传入的回调函数 `next`，也就是 `mountComponent`：\n\n> BUG：首次初始化不执行 onShow 回调函数\n\n```Javascript\nexport function mountComponent (\n    vm: Component,\n    el: ?Element,\n    hydrating?: boolean\n): Component {\n    callHook(vm, 'beforeMount')\n\n    if (process.env.NODE_ENV !== 'production' && config.performance && mark) {\n        updateComponent = () => {\n        vm._update(vnode, hydrating)\n        }\n    } else {\n        updateComponent = () => {\n            vm._update(vm._render(), hydrating)\n        }\n    }\n\n    vm._watcher = new Watcher(vm, updateComponent, noop)\n\n    if (vm.$vnode == null) {\n        vm._isMounted = true\n        callHook(vm, 'mounted')\n    }\n    return vm\n}\n```\n\n`mountComponent` 方法在执行 `beforeMount` 生命周期函数之后，紧接着会执行一个**关键步骤**：\n\n```Javascript\nvm._watcher = new Watcher(vm, updateComponent, noop);\n```\n\n**mpvue 不依赖 Vue 进行渲染，但是依赖 Vue 完成响应式功能**。实例化渲染 Watcher 后会调用 mounted 生命周期回调函数，一个组件对应一个 Watcher。\n\n整个 mpvue 的实例化和渲染过程完成。\n\n### 响应式\n\n响应式数据收集依赖的相关知识请参考：[深入响应式原理](https://cn.vuejs.org/v2/guide/reactivity.html)\n\n实例化渲染 Watcher 后，当赋值 data 时， mpvue 会调用 Dep 的 notify 方法实现界面更新。\n\n仔细分析 `_.initMp` 方法中对 Page 进行的初始化：\n\n```Javascript\nvar app = global.getApp();\nglobal.Page({\n    data: {\n        $root: {}\n    },\n\n    // 全局事件代理的方式\n    handleProxy: function handleProxy (e) {\n        return rootVueVM.$handleProxyWithVue(e)\n    },\n\n    // mp lifecycle for vue\n    // 生命周期函数--监听页面加载\n    onLoad: function onLoad (query) {\n        mp.page = this;\n        mp.query = query;\n        mp.status = 'load';\n        getGlobalData(app, rootVueVM);\n        callHook$1(rootVueVM, 'onLoad', query);\n    },\n\n    // 生命周期函数--监听页面显示\n    onShow: function onShow () {\n        mp.page = this;\n        mp.status = 'show';\n        callHook$1(rootVueVM, 'onShow');\n\n        // 只有页面需要 setData\n        rootVueVM.$nextTick(function () {\n        rootVueVM._initDataToMP();\n        });\n    },\n\n    // 生命周期函数--监听页面初次渲染完成\n    onReady: function onReady () {\n        mp.status = 'ready';\n\n        callHook$1(rootVueVM, 'onReady');\n        next();\n    }\n});\n```\n\n* 调用 `global.Page` 初始化 `Page` 对象，从而实现页面的初始化；\n* 初始化 Page 的 data 为 `$root`，且 `$root` 为空；\n* 定义了事件代理方法 `handleProxy`（重点）；\n* 依次定义了 Page 的所有生命周期回调函数，用 `callHook$1` 绑定 Vue 实例 options 对应的生命周期回调函数。\n\n且在 onReady 函数调用完毕后，会调用 next 回调函数，即 mountComponent 函数。\n\n上面提到了 data 中 $root 的值为空，其中 mountComponent 函数会将完成 mpvue 实例中的 data 与 Page 中的 data 的映射：\n\n```Javascript\nfunction mountComponent (vm, el,hydrating) {\n    // ...\n    var updateComponent = function () {\n        vm._update(vm._render(), hydrating);\n    };\n\n    vm._watcher = new Watcher(vm, updateComponent, noop);\n    // ...\n    return vm\n}\n```\n\n`Watcher` 的逻辑不做详细描述。集中精神分析 mpvue 的核心 `updateComponent`。首先执行 `vm._render` 函数生成 vnode，然后调用 `vm._update` 完成界面渲染。小程序界面渲染由小程序处理，与 mpvue 没有关联，直接关注 vm._update 方法：\n\n```Javascript\nVue.prototype._update = function (vnode, hydrating) {\n    // ...\n    vm.__patch__(prevVnode, vnode)\n    // ...\n}\n```\n\n`vm.__patch__` 方法进行 **diff** 算法，找出差异项进行最小颗粒度的更新：\n\n```Javascript\n// src/platforms/mp/runtime/patch.js\nfunction patch () {\n    corePatch.apply(this, arguments)\n    this.$updateDataToMP()\n}\n```\n\n我们可以忽略一切与界面渲染相关的代码 `corePatch`。因为 mpvue 实际做的，是监听 data 的变化，当 mpvue 实例的 data 变化时，调用 setData 方法对小程序界面进行更新：\n\n```Javascript\n// packages/mpvue/index.js\n// 优化js变量动态变化时候引起全量更新\n// 优化每次 setData 都传递大量新数据\nfunction updateDataToMP () {\n  var page = getPage(this);\n  if (!page) {\n    return\n  }\n\n  var data = formatVmData(this);\n  diffData(this, data);\n  throttleSetData(page.setData.bind(page), data);\n}\n```\n\n* formatVmData 方法初始化 page 实例下的 data 对象，包含 props、computed 的数据；\n* diffData 将 mpvue 实例下的 data 对象与 page 实例下的 data 对象进行对比，如果不一致则进行更新；\n* 最后通过 throttleSetData 方法调用 page.setData 完成对界面的渲染和更新，throttleSetData 方法主要优化了频繁调用 setData 的场景，限制了 setData 的调用间隔为 50ms，因为频繁调用 setData 会造成页面的卡顿，所以 mpvue 对此进行了优化。\n\n### 事件代理\n\nmpvue 通过全局事件代理 **`handleProxy`** 的方式，实现事件的响应，事件响应过程中，通过 view 的 data 中的 eventid 和 comkey 区分事件和组件。\n\n打包后的文件：\n\n```Html\n<!-- wxml -->\n<view bindtap=\"handleProxy\" data-eventid=\"{{'3'}}\" data-comkey=\"{{$k}}\" class=\"_div data-v-4cf53cc1\"></view>\n```\n\n在 `this._initMp` 方法中，完成了上述打包文件 data 的注入：\n\n```Javascript\nglobal.Page({\n  data: {\n    $root: {}\n  },\n\n  handleProxy: function handleProxy (e) {\n    return rootVueVM.$handleProxyWithVue(e)\n  },\n\n  onShow: function onShow () {\n    mp.page = this;\n    mp.status = 'show';\n    callHook$1(rootVueVM, 'onShow');\n\n    rootVueVM.$nextTick(function () {\n      rootVueVM._initDataToMP();\n    });\n  }\n}\n```\n\n* 定义了 data 只包含一个 $root 属性，该属性为空对象；\n* 定义了 handleProxy 函数，即事件代理；\n* 通过 `rootVueVM._initDataToMP` 方法实现了 data 的注入。\n\n```Javascript\nfunction initDataToMP () {\n    // ...\n    var data = collectVmData(this.$root);\n    page.setData(data);\n}\n\nfunction collectVmData (vm, res) {\n    if ( res === void 0 ) res = {};\n\n    var vms = vm.$children;\n    if (vms && vms.length) {\n        vms.forEach(function (v) { return collectVmData(v, res); });\n    }\n    return Object.assign(res, formatVmData(vm))\n}\n```\n\n最终 initDataToMP 生成的 data 数据格式：\n\n```Javascript\n$root.0: {\n    $k: \"0\"\n    $kk: \"0_\"\n    $p: \"\"\n    message: \"Hello\"\n}\n```\n\n$k 即组件的 comkey，$kk 为父组件的前缀，$p 这里没有用到，所以为空。获得 data 之后，mpvue 调用 page.setData(data) 完成 data 的注入。\n\n事件代理：每个 page 实例只会绑定一个 handleProxy 方法，核心实现：\n\n* 通过 event 获取 comkey，通过 comkey 获取对应的 mpvue 页面或组件实例；\n* 通过 event 获取 eventid，通过 eventid 获取对应的事件处理方法；\n* 执行方法时会传入一个 event 对象，该 event 对象为 mpvue 额外包装的，包装的方法为：getWebEventByMP。\n\n### mpvue-loader\n\n前置条件：[webpack](https://zeuscoder.github.io/2020/03/08/web-webpack/)。\n\nmpvue 框架从运行环境来分，可以分为运行时和构建时。mpvue 运行时指 mpvue 编写的小程序在运行时的环境；**运行前需要将 .vue 编写的 mpvue 源码编译为小程序源码，其通过 webpack 进行构建的过程，被称为 mpvue 构建时**。\n\n构建时最关键的一个步骤是将 .vue 源码编译为小程序源码。.vue 文件是 Vue.js 自定义的文件类型，符合 [SFC](https://vue-loader.vuejs.org/zh/spec.html#%E7%AE%80%E4%BB%8B) 规范。\n\n通过对比 mpvue 和 vue 的 SFC 规范，得出 mpvue 构建时的**主要改动**：\n\n* 修改 vue-loader 为 mpvue-loader：\n  * template 导出为小程序布局文件 wxml\n  * style 导出为小程序样式文件 wxss\n* 修改 vue-template-compiler 为 mpvue-template-compiler，编译 mpvue 的 template。\n\n首先通过观察 mpvue-loader 构建 .vue 文件后输出的结果，分析可以较为直观。\n\n构建前的 .vue 文件：\n\n```Html\n<template>\n    <div>{{message}}</div>\n</template>\n\n<script>\nexport default {\n    data () {\n        return {\n            message: 'Hello World'\n        }\n    }\n}\n</script>\n\n<style scoped>\ndiv {\n    color: red;\n}\n</style>\n```\n\n构建后的 js 文件：\n\n```Javascript\nfunction injectStyle (ssrContext) {\n  require(\"!!../../../node_modules/_extract-text-webpack-plugin@3.0.2@extract-text-webpack-plugin/dist/loader.js?{\\\"omit\\\":1,\\\"remove\\\":true}!vue-style-loader!css-loader?{\\\"minimize\\\":true,\\\"sourceMap\\\":false}!../../../node_modules/_mpvue-loader@2.0.1@mpvue-loader/lib/style-compiler/index?{\\\"vue\\\":true,\\\"id\\\":\\\"data-v-32ccf774\\\",\\\"scoped\\\":true,\\\"hasInlineConfig\\\":false}!px2rpx-loader?{\\\"baseDpr\\\":1,\\\"rpxUnit\\\":0.5}!postcss-loader?{\\\"sourceMap\\\":true}!../../../node_modules/_mpvue-loader@2.0.1@mpvue-loader/lib/selector?type=styles&index=0!../../../build/rules/test-loader/index.js!./index.vue\")\n}\nvar normalizeComponent = require(\"!../../../node_modules/_mpvue-loader@2.0.1@mpvue-loader/lib/component-normalizer\")\n/* script */\nimport __vue_script__ from \"!!babel-loader!../../../node_modules/_mpvue-loader@2.0.1@mpvue-loader/lib/selector?type=script&index=0!../../../build/rules/test-loader/index.js!./index.vue\"\n/* template */\nimport __vue_template__ from \"!!../../../node_modules/_mpvue-loader@2.0.1@mpvue-loader/lib/template-compiler/index?{\\\"id\\\":\\\"data-v-32ccf774\\\",\\\"hasScoped\\\":true,\\\"transformToRequire\\\":{\\\"video\\\":\\\"src\\\",\\\"source\\\":\\\"src\\\",\\\"img\\\":\\\"src\\\",\\\"image\\\":\\\"xlink:href\\\"},\\\"fileExt\\\":{\\\"template\\\":\\\"wxml\\\",\\\"script\\\":\\\"js\\\",\\\"style\\\":\\\"wxss\\\",\\\"platform\\\":\\\"wx\\\"}}!../../../node_modules/_mpvue-loader@2.0.1@mpvue-loader/lib/selector?type=template&index=0!../../../build/rules/test-loader/index.js!./index.vue\"\n/* styles */\nvar __vue_styles__ = injectStyle\n/* scopeId */\nvar __vue_scopeId__ = \"data-v-32ccf774\"\n/* moduleIdentifier (server only) */\nvar __vue_module_identifier__ = null\nvar Component = normalizeComponent(\n  __vue_script__,\n  __vue_template__,\n  __vue_styles__,\n  __vue_scopeId__,\n  __vue_module_identifier__\n)\n\nexport default Component.exports\n```\n\nmpvue-loader 的主要功能就是将 mpvue 的 .vue 文件输出为一个 Component.exports 对象。\n\n### mpvue-template-compiler\n\n源码： `node_modules/mpvue-template-compiler/build.js`。\n\nmpvue-loader 中会调用 mpvue-template-compiler 实现 template 解析，这样做的目的是为了节约在运行时解析 template 所带来的开销。引用自 `mpvue-loader/lib/template-compiler/index.js`\n\n```Javascript\nvar compiled = compiler.compile(html, compilerOptions)\n```\n\n* html 参数就是 .vue 文件的 template 字符串，通过 compile 函数生成 AST 和 render 函数；\n* AST 是抽象代码树的含义，它会将 html 标签解析为一个 js 对象，通过该对象最终生成 render 函数；\n* 执行 render 会生成 vnode 对象，该 vnode 对象对应 template 的结构。\n\n① 生成了 AST 之后，即是上述的 compiled，会继续执行 compileMPML：\n\n```Javascript\ncompileMPML.call(this, compiled, html, options)\n```\n\n② compileMPML 是实际生成 wxml 文件的方法，这里不做详述。\n\n其实呢，`mpvue` 的 `compiler.compile` 和 `vue` 的 `compile` 生成 `AST` 是同样的三个步骤：\n\n```Javascript\nfunction baseCompile (template, options) {\n    var originAst = parse(template.trim(), options);\n    var ast = markComponent(originAst, options);\n    optimize(ast, options);\n    var code = generate(ast, options);\n    return {\n        ast: ast,\n        render: code.render,\n        staticRenderFns: code.staticRenderFns\n    }\n}\n```\n\n* 生成 ast：通过 parse 方法生成 ast；\n* 优化 ast：通过 optimize 优化 ast，主要是对 ast 中的静态节点进行识别和标记；\n* 生成 render 函数：通过 generate 方法将 ast 转化为 render 函数。\n\n不同的是 mpvue 解析出的 AST 中的 tag 是对应 WXML 标签 view 的。\n\n参考文章：\n\n[mpvue原理深入解析36讲](https://www.imooc.com/read/45/article/769)\n"},{"title":"JS：this 备忘录","url":"/2020/03/22/js-this/","content":"\n阅读源码的时候，深刻理解 *this* 的指向至关重要；同时设计 npm 库和插件的时候，也会需要改变 *this* 的指向。\n<!-- more -->\n\n如果只用一句话概括 this 指向的话：\n\n最简单的说法（平时记住这句话就得了）：\n> **this 永远指向最后调用它的那个对象**\n\n更准确的说法：\n> **this 的指向，是在调用函数时根据执行上下文所动态决定的**\n\n至于 this 的具体环节和规则，**死记硬背**以下几条规则：\n\n* 在函数体中，简单调用该函数时（非显式/隐式绑定下），严格模式下 this 绑定到 undefined，否则绑定到全局对象 window／global；\n* 一般构造函数 new 调用，绑定到新创建的对象上；\n* 一般由 call/apply/bind 方法显式调用，绑定到指定参数的对象上；\n* 一般由上下文对象调用，绑定在该对象上；\n* 箭头函数中，根据外层上下文绑定的 this 决定 this 指向。\n\n#### 实例一：函数调用\n\n```Javascript\n// 非严格模式下，独立声明的函数体挂载在 window 上\nfunction fn () {\n    console.log(this)\n}\n\n// 这里等同于调用 window.f1()\nfn() // window\n```\n\n```Javascript\n// 初级版\nconst person = {\n    name: 'Zeus',\n    fn: function() {\n       console.log(this)\n    }\n}\n// 调用 fn 的是 person，this 指向 person\nperson.fn() // {name: 'Zeus', fn: ƒ}\n\n// 升级版\nvar fn1 = foo.fn\n// fn1 是声明挂载在 window 上的函数，调用 fn1 的是 window，this 指向 window\nfn1() // window\n\n// 最终版\nconst person1 = {\n    fn: function() {\n        return this\n    }\n}\nconst person2 = {\n    fn: function() {\n        return person1.fn()\n    }\n}\nconst person3 = {\n    fn: function() {\n        var fn = person1.fn // 这里 fn 直接挂载 window 调用了\n        return fn()\n    }\n}\n\nconsole.log(o1.fn())  // person1\nconsole.log(o2.fn())  // person1\nconsole.log(o3.fn())  // window\n```\n\n**this 指向的是最后调用它的对象。**\n\n要记住了：\n> 在执行函数时，如果函数中的 this 是被上一级的对象所调用，那么 this 指向的就是上一级的对象；否则指向全局环境。\n\n#### 实例二：bind/call/apply 都是用来改变 this 指向\n\n```Javascript\n// call\nconst target = {}\nfn.call(target, 'arg1', 'arg2')\n\n// apply\nconst target = {}\nfn.apply(target, ['arg1', 'arg2'])\n\n// bind 不会执行相关函数，而是返回一个新的函数，这个新的函数已经自动绑定了新的 this 指向\nconst target = {}\nfn.bind(target, 'arg1', 'arg2')()\n\n// 简单的例子\nconst zeus = {\n    name: 'Zeus',\n    logName: function() {\n        console.log(this.name)\n    }\n}\nconst chloe = {\n    name: 'Chloe'\n}\nconsole.log(zeus.logName.call(chloe)) // Chloe\n```\n\n#### 实例三：new 构造函数和 this\n\n```Javascript\nfunction Person() {\n    this.name = 'Zeus'\n}\nconst person = new Person()\nconsole.log(person.name)  // Zeus\n```\n\nnew 操作符调用构造函数，具体做了什么？以下供参考：\n\n* 创建一个新的对象；\n* 将构造函数的 this 指向这个新对象；\n* 为这个对象添加属性、方法等；\n* 最终返回新对象。\n\n类似于：\n\n```Javascript\nvar obj  = {}\nobj.__proto__ = Person.prototype\nPerson.call(obj)\n```\n\n有一点必须注意的是：\n> 如果构造函数中显式返回一个值，且返回的是一个对象，那么 this 就指向这个返回的对象；如果返回的不是一个对象，那么 this 仍然指向实例。\n\n#### 实例四：箭头函数\n\n```Javascript\nconst person1 = {  \n    fn: function () {  \n        setTimeout(function() {  \n            console.log(this)\n        })\n    }  \n}\nconst person2 = {  \n    fn: function () {  \n        setTimeout(() => {  \n            console.log(this)\n        })\n    }  \n}\n\nconsole.log(person1.fn()) // window\nconsole.log(person2.fn()) // person2\n```\n\n#### 实例五：this 优先级\n\n```Javascript\nfunction foo (a) {\n    this.a = a\n}\n\nconst obj1 = {}\n\nvar bar = foo.bind(obj1)\nbar(2)\nconsole.log(obj1.a) // 2\n\nvar obj2 = new bar(3)\nconsole.log(obj2.a) // 3\nconsole.log(obj1.a) // 2\n```\n\n> new 绑定修改了 bind 绑定中的 this，因此 new 绑定的优先级比显式 bind 绑定更高。\n\n参考文章:\n\n[一网打尽 this，对执行上下文说 Yes](https://gitbook.cn/gitchat/column/5c91c813968b1d64b1e08fde/topic/5c99a854ccb24267c1d0194f)\n\n[this MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/this)\n","tags":["JavaScript"],"categories":["web"]},{"title":"JS：浅析 Vue-Router","url":"/2020/03/19/js-vue-router/","content":"\n[Vue Router](https://router.vuejs.org/zh/) 是 Vue.js 构建单页面应用的路由管理器库，支持 **hash**、**history**、**abstract** 3种路由方式，提供了 **<router-view\\>** 和 **<router-link\\>** 2种组件。\n\n<!-- more -->\n\n基本使用例子：\n\n```Html\n<div id=\"app\">\n  <h1>Hello App!</h1>\n  <p>\n    <!-- 使用 router-link 组件来导航. -->\n    <!-- 通过传入 `to` 属性指定链接. -->\n    <!-- <router-link> 默认会被渲染成一个 `<a>` 标签 -->\n    <router-link to=\"/foo\">Go to Foo</router-link>\n    <router-link to=\"/bar\">Go to Bar</router-link>\n  </p>\n  <!-- 路由出口 -->\n  <!-- 路由匹配到的组件将渲染在这里 -->\n  <router-view></router-view>\n</div>\n```\n\n```Javascript\nimport Vue from 'vue'\nimport VueRouter from 'vue-router'\nimport App from './App'\n\nVue.use(VueRouter)\n\n// 1. 定义路由\n// 每个路由应该映射一个组件。 其中\"component\" 可以是\n// 通过 Vue.extend() 创建的组件构造器，\n// 或者，只是一个组件配置对象。\nconst routes = [\n  { path: '/foo', component: () => import('./foo.vue') },\n  { path: '/bar', component: () => import('./bar.vue') }\n]\n\n// 2. 创建 router 实例，然后传 `routes` 配置\nconst router = new VueRouter({\n  routes\n})\n\n// 3. 创建和挂载根实例\nconst app = new Vue({\n  el: '#app',\n  render(h) {\n    return h(App)\n  },\n  router // 记得要通过 router 配置参数注入路由，从而让整个应用都有路由功能\n})\n```\n\n> 分析源码时会涉及不少辅助函数，无需详细分析其函数，只需要通过 *test/unit/specs* 中的断言了解该辅助函数的作用输出即可。\n\n#### 路由注册\n\n使用 `Vue.use(VueRouter)` 其实是主动调用 `VueRouter` 的 **install** 方法。\n\ninstall 源代码：*src/install.js*\n\n```Javascript\nexport function install (Vue) {\n  const isDef = v => v !== undefined\n\n  const registerInstance = (vm, callVal) => {\n    let i = vm.$options._parentVnode\n    if (isDef(i) && isDef(i = i.data) && isDef(i = i.registerRouteInstance)) {\n      i(vm, callVal)\n    }\n  }\n\n  Vue.mixin({\n    beforeCreate () {\n      if (isDef(this.$options.router)) {\n        this._routerRoot = this\n        this._router = this.$options.router\n        this._router.init(this)\n        Vue.util.defineReactive(this, '_route', this._router.history.current)\n      } else {\n        this._routerRoot = (this.$parent && this.$parent._routerRoot) || this\n      }\n      registerInstance(this, this)\n    },\n    destroyed () {\n      registerInstance(this)\n    }\n  })\n\n  Object.defineProperty(Vue.prototype, '$router', {\n    get () { return this._routerRoot._router }\n  })\n\n  Object.defineProperty(Vue.prototype, '$route', {\n    get () { return this._routerRoot._route }\n  })\n\n  Vue.component('RouterView', View)\n  Vue.component('RouterLink', Link)\n\n  // 跟 created 一样的合并策略\n  const strats = Vue.config.optionMergeStrategies\n  // use the same hook merging strategy for route hooks\n  strats.beforeRouteEnter = strats.beforeRouteLeave = strats.beforeRouteUpdate = strats.created\n}\n```\n\n* 首先利用 `Vue.mixin` 在每个组件中的 `beforeCreate` 和 `destroyed` 钩子函数中注入实例。\n* 接着在 Vue 原型上定义了 `$router` 和 `$route` 2个属性的 get 方法，也就是 `this.$router` 和 `this.$route`。\n* 然后通过 `Vue.component` 定义 `<router-view>` 和 `<router-link>` 两个组件。\n* 最后定义路由中 `beforeRouteEnter`、`beforeRouteLeave`、`beforeRouteUpdate` 等钩子函数的合并策略，和普通的钩子函数一样。\n\n#### VueRouter\n\nVue-router 的入口文件是 *src/index.js*, 声明了 **VueRouter** 类，也实现了 **install** 的静态方法：`VueRouter.install = install`。\n\nVueRouter 源代码：*src/index.js*\n\n```Javascript\n// VueRouter\nconstructor (options: RouterOptions = {}) {\n    this.app = null // 根 Vue 实例\n    this.apps = [] // 持有 $options.router 属性的 Vue 实例\n    this.options = options // 路由配置\n    this.beforeHooks = [] // 全局 beforeEach\n    this.resolveHooks = [] // 全局 beforeResolve\n    this.afterHooks = [] // 全局 afterEach\n    this.matcher = createMatcher(options.routes || [], this) // 路由匹配器\n\n    this.mode = options.mode || 'hash'\n\n    // 以下都是继承了 History 基类\n    switch (mode) {\n        case 'history':\n            this.history = new HTML5History(this, options.base)\n            break\n        case 'hash':\n            this.history = new HashHistory(this, options.base, this.fallback)\n            break\n        case 'abstract':\n            this.history = new AbstractHistory(this, options.base)\n            break\n    }\n}\n```\n\n业务项目上调用 `const router = new VueRouter({routes})` 实例化 `VueRouter` 后会返回它的实例 `router`，再在 `const app = new Vue({router})` 时把 `router` 作为配置（$options）的属性传入，然后在 `install` 方法中 mixin 的 `beforeCreate` 函数使用：\n\n```Javascript\n    beforeCreate() {\n        if (isDef(this.$options.router)) {\n            // ...\n            this._router = this.$options.router\n            this._router.init(this)\n            // ...\n        }\n    }\n```\n\n当 `new Vue` 根组件执行 `beforeCreate` 钩子函数的时候，如果传入了 `router` 实例，都会执行 `router.init` 方法初始化：\n\n```Javascript\ninit (app: any /* Vue component instance */) {\n    this.apps.push(app) // app 就是持有 $options.router 属性的 Vue 实例\n\n    if (this.app) {\n      return\n    }\n\n    this.app = app\n\n    const history = this.history\n\n    if (history instanceof HTML5History) {\n      history.transitionTo(history.getCurrentLocation())\n    } else if (history instanceof HashHistory) {\n      const setupHashListener = () => {\n        history.setupListeners()\n      }\n      history.transitionTo(\n        history.getCurrentLocation(),\n        setupHashListener,\n        setupHashListener\n      )\n    }\n\n    history.listen(route => {\n      this.apps.forEach((app) => {\n        app._route = route\n      })\n    })\n}\n```\n\n`init` 传入的 `app` 参数是根 `Vue` 实例，然后存储到 `this.apps` 中。再根据 history 类型执行 `history.transitionTo` 方法，该方法定义在 `History` 基类中。源代码：*src/history/base.js*：\n\n```Javascript\n// 路由过渡\ntransitionTo (location: RawLocation, onComplete?: Function, onAbort?: Function) {\n    const route = this.router.match(location, this.current)\n    // ...\n}\n```\n\n调用 `this.router.match` 实际上是调用了 `this.matcher.match` 去做匹配。\n\n#### Matcher\n\nmatcher 源代码：*src/create-matcher.js*\n\n```Javascript\nexport type Matcher = {\n    match: (raw: RawLocation, current?: Route, redirectedFrom?: Location) => Route;\n    addRoutes: (routes: Array<RouteConfig>) => void;\n}\n```\n\n`Matcher` 返回了2个方法：`match` 和 `adddRoutes`。\n\n##### createMatcher\n\n在 `new VueRouter({routes})` 时, `VueRouter` 的 `constructor` 通过 `this.matcher = createMatcher(options.routes || [], this)` 创建 matcher。\n\n```Javascript\nexport function createMatcher (\n  routes: Array<RouteConfig>,\n  router: VueRouter\n): Matcher {\n    const { pathList, pathMap, nameMap } = createRouteMap(routes)\n\n    function addRoutes (routes) {\n        ...\n    }\n\n    function match (\n        raw: RawLocation,\n        currentRoute?: Route,\n        redirectedFrom?: Location\n    ): Route {\n        ...\n    }\n\n    return {\n        match,\n        addRoutes\n    }\n}\n```\n\n1. `createMatcher` 接受了 2 个参数，一个是 `routes`，它是用户定义的路由配置，一个是 `router`，是 `new VueRouter` 时返回的实例 `this`。\n\n2. `const { pathList, pathMap, nameMap } = createRouteMap(routes)` 深度遍历 `routes` 创建了一个映射路由表，`pathList` 存储所有的 `path`，`pathMap` 表示一个 `path` 到 `RouteRecord` 的映射关系，而 `nameMap` 表示 `name` 到 `RouteRecord` 的映射关系。`RouteRecord` 的数据结构如下：\n\n```Javascript\n// flow/declarations.js\ndeclare type RouteRecord = {\n    path: string;\n    regex: RouteRegExp;\n    components: Dictionary<any>;\n    instances: Dictionary<any>;\n    name: ?string;\n    parent: ?RouteRecord;\n    redirect: ?RedirectOption;\n    matchAs: ?string;\n    beforeEnter: ?NavigationGuard;\n    meta: any;\n    props: boolean | Object | Function | Dictionary<boolean | Object | Function>;\n}\n```\n\n##### addRoutes\n\n`addRoutes` 方法的作用是动态添加路由配置.\n\n```Javascript\nfunction addRoutes (routes) {\n    createRouteMap(routes, pathList, pathMap, nameMap)\n}\n```\n\n##### match\n\n```Javascript\nfunction match (\n    raw: RawLocation,\n    currentRoute?: Route,\n    redirectedFrom?: Location\n  ): Route {\n    const location = normalizeLocation(raw, currentRoute, false, router)\n    const { name } = location\n\n    if (name) {\n        const record = nameMap[name]\n\n        if (!record) return _createRoute(null, location)\n        const paramNames = record.regex.keys\n            .filter(key => !key.optional)\n            .map(key => key.name)\n\n        if (typeof location.params !== 'object') {\n            location.params = {}\n        }\n\n        if (currentRoute && typeof currentRoute.params === 'object') {\n            for (const key in currentRoute.params) {\n                if (!(key in location.params) && paramNames.indexOf(key) > -1) {\n                    location.params[key] = currentRoute.params[key]\n                }\n            }\n        }\n\n        location.path = fillParams(record.path, location.params, `named route \"${name}\"`)\n        return _createRoute(record, location, redirectedFrom)\n    } else if (location.path) {\n        location.params = {}\n        for (let i = 0; i < pathList.length; i++) {\n            const path = pathList[i]\n            const record = pathMap[path]\n            if (matchRoute(record.regex, location.path, location.params)) {\n                return _createRoute(record, location, redirectedFrom)\n            }\n        }\n    }\n    // no match\n    return _createRoute(null, location)\n}\n\nfunction _createRoute (\n    record: ?RouteRecord,\n    location: Location,\n    redirectedFrom?: Location\n): Route {\n    if (record && record.redirect) {\n        return redirect(record, redirectedFrom || location)\n    }\n    if (record && record.matchAs) {\n        return alias(record, location, record.matchAs)\n    }\n    return createRoute(record, location, redirectedFrom, router)\n}\n```\n\n`match` 方法接收3个参数，`raw` 可以是 url 字符串，也可以是 Location 对象,`currentRoute` 表示当前路径，`redirectedFrom` 与重定向相关。`_createRoute` 返回值是一个 `Route` 路径。\n\n`_createRoute` 最终会调用 `createRoute` 方法，createRoute 源代码：*src/uitl/route.js*:\n\n```Javascript\nexport function createRoute (\n    record: ?RouteRecord,\n    location: Location,\n    redirectedFrom?: ?Location,\n    router?: VueRouter\n): Route {\n    const stringifyQuery = router && router.options.stringifyQuery\n\n    let query: any = location.query || {}\n    try {\n        query = clone(query)\n    } catch (e) {}\n\n    const route: Route = {\n        name: location.name || (record && record.name),\n        meta: (record && record.meta) || {},\n        path: location.path || '/',\n        hash: location.hash || '',\n        query,\n        params: location.params || {},\n        fullPath: getFullPath(location, stringifyQuery),\n        matched: record ? formatMatch(record) : []\n    }\n    if (redirectedFrom) {\n        route.redirectedFrom = getFullPath(redirectedFrom, stringifyQuery)\n    }\n    return Object.freeze(route)\n}\n```\n\n`createRoute` 可以根据 `record` 和 `location` 创建出来，最终返回的是一条 `Route` 路径，在 Vue-Router 中，所有的 `Route` 最终都会通过 `createRoute` 函数创建，并且它最后是**不可以被外部修改**的。Route 对象中有一个非常重要属性是 `matched`，它通过 `formatMatch(record)` 计算而来。\n\n> `matched` 属性非常有用，它为之后渲染组件提供了依据。\n\n#### 路径切换（重点）\n\n`history.transitionTo` 是 `Vue-Router` 中非常重要的方法，在切换路由线路时执行。\n\n上面分析了 `matcher` 的相关实现，知道它是如何找到匹配的新线路，那么匹配到新线路后又做了哪些事情，这就涉及到 `transitionTo` 的实现了。源代码 *src/history/base.js*：\n\n```Javascript\ntransitionTo (location: RawLocation, onComplete?: Function, onAbort?: Function) {\n    const route = this.router.match(location, this.current)\n    this.confirmTransition(route, () => {\n        this.updateRoute(route)\n        onComplete && onComplete(route)\n        this.ensureURL()\n\n        // fire ready cbs once\n        if (!this.ready) {\n            this.ready = true\n            this.readyCbs.forEach(cb => { cb(route) })\n        }\n    }, err => {\n      if (onAbort) {\n        onAbort(err)\n      }\n      if (err && !this.ready) {\n        this.ready = true\n        this.readyErrorCbs.forEach(cb => { cb(err) })\n      }\n    })\n}\n```\n\n* 首先根据目标 `location` 和当前路径 `this.current` 执行 `this.router.match` 方法去匹配到目标的路径 `route`, `transitionTo` 实际上也就是在切换 `this.current`。\n* **拿到新的路径后，接下来会执行 `confirmTransition` 做真正的切换（关键点）**。\n\n```Javascript\nconfirmTransition (route: Route, onComplete: Function, onAbort?: Function) {\n    const current = this.current\n    const abort = err => {\n        if (isError(err)) {\n            if (this.errorCbs.length) {\n                this.errorCbs.forEach(cb => { cb(err) })\n            } else {\n                warn(false, 'uncaught error during route navigation:')\n                console.error(err)\n            }\n        }\n        onAbort && onAbort(err)\n    }\n    if (\n        isSameRoute(route, current) &&\n        // in the case the route map has been dynamically appended to\n        route.matched.length === current.matched.length\n    ) {\n        this.ensureURL()\n        return abort()\n    }\n\n    const {\n        updated,\n        deactivated,\n        activated\n    } = resolveQueue(this.current.matched, route.matched)\n\n    const queue: Array<?NavigationGuard> = [].concat(\n        extractLeaveGuards(deactivated),\n        this.router.beforeHooks,\n        extractUpdateHooks(updated),\n        activated.map(m => m.beforeEnter),\n        resolveAsyncComponents(activated)\n    )\n\n    this.pending = route\n    const iterator = (hook: NavigationGuard, next) => {\n        if (this.pending !== route) {\n            return abort()\n        }\n        try {\n            hook(route, current, (to: any) => {\n            if (to === false || isError(to)) {\n                // next(false) -> abort navigation, ensure current URL\n                this.ensureURL(true)\n                abort(to)\n            } else if (\n                typeof to === 'string' ||\n                (typeof to === 'object' && (\n                typeof to.path === 'string' ||\n                typeof to.name === 'string'\n                ))\n            ) {\n                // next('/') or next({ path: '/' }) -> redirect\n                abort()\n                if (typeof to === 'object' && to.replace) {\n                this.replace(to)\n                } else {\n                this.push(to)\n                }\n            } else {\n                // confirm transition and pass on the value\n                next(to)\n            }\n            })\n        } catch (e) {\n            abort(e)\n        }\n    }\n\n    runQueue(queue, iterator, () => {\n        const postEnterCbs = []\n        const isValid = () => this.current === route\n        // wait until async components are resolved before\n        // extracting in-component enter guards\n        const enterGuards = extractEnterGuards(activated, postEnterCbs, isValid)\n        const queue = enterGuards.concat(this.router.resolveHooks)\n        runQueue(queue, iterator, () => {\n            if (this.pending !== route) {\n                return abort()\n            }\n            this.pending = null\n            onComplete(route)\n            if (this.router.app) {\n                this.router.app.$nextTick(() => {\n                    postEnterCbs.forEach(cb => { cb() })\n                })\n            }\n        })\n    })\n}\n```\n\n* 首先定义了 `abort` 函数，判断要跳转的 `route` 和当前 `current` 是相同路径的话，直接调用 `this.ensureURL` 和 `abort`。\n* 接着根据 `current.matched` 和 `route.matched` 执行了 `resolveQueue` 方法解析出 3 个队列（这里是开始管理更新路由栈），拿到 `updated`(已更新)、`activated`（激活）、`deactivated`（失活） 3 个 `ReouteRecord` 数组后，接下来就是路径变换后的一个重要部分，执行一系列的钩子函数（[导航守卫](https://router.vuejs.org/zh/guide/advanced/navigation-guards.html#%E5%85%A8%E5%B1%80%E5%89%8D%E7%BD%AE%E5%AE%88%E5%8D%AB)）。\n\n##### 导航守卫\n\n路由切换的时候，会执行一系列的钩子函数，我们称之为导航守卫。\n\n![完整的导航解析流程](/images/js-vue-router/vue-router-guard.png)\n\n接着继续看上面 `confirmTransition` 函数中是怎样执行这些钩子函数的，首先构造出一个队列 `queue`，实际是一个导航守卫数组；然后再定义一个迭代器函数 `iterator`；最后再执行 `runQueue` 方法来执行这个队列。\n\n`runQueue` 方法源代码：*src/util/async.js*\n\n```Javascript\nexport function runQueue (queue: Array<?NavigationGuard>, fn: Function, cb: Function) {\n    const step = index => {\n        if (index >= queue.length) {\n            cb()\n        } else {\n            if (queue[index]) {\n                fn(queue[index], () => {\n                step(index + 1)\n                })\n            } else {\n                step(index + 1)\n            }\n        }\n    }\n    step(0)\n}\n```\n\n`runQueue` 是一个非常经典的异步函数队列执行的模式（小程序请求数限制的优化方案）。`queue` 是一个 `NavigationGuard` 类型的数组，这里的 `fn` 是刚才的 `iterator` 函数。回到之前 `iterator` 函数的定义：\n\n```Javascript\nconst iterator = (hook: NavigationGuard, next) => {\n    if (this.pending !== route) {\n        return abort()\n    }\n    try {\n        hook(route, current, (to: any) => {\n            if (to === false || isError(to)) {\n                // next(false) -> abort navigation, ensure current URL\n                this.ensureURL(true)\n                abort(to)\n            } else if (\n                typeof to === 'string' ||\n                (typeof to === 'object' && (\n                typeof to.path === 'string' ||\n                typeof to.name === 'string'\n                ))\n            ) {\n                // next('/') or next({ path: '/' }) -> redirect\n                abort()\n                if (typeof to === 'object' && to.replace) {\n                    this.replace(to)\n                } else {\n                    this.push(to)\n                }\n            } else {\n                // confirm transition and pass on the value\n                next(to)\n            }\n        })\n    } catch (e) {\n        abort(e)\n    }\n}\n```\n\n`iterator` 函数的逻辑就是去执行每一个导航守卫 `hook`，并传入了 `route`、`current` 和匿名函数，这三个参数对应 vue-router 官方文档中的 `to`、`from`、`next`。只有执行 next 的时候，才会前进到下一个导航守卫钩子函数中。\n\n最后我们可以看看被遍历执行的 `queue` 是怎么构造的：\n\n```Javascript\nconst queue: Array<?NavigationGuard> = [].concat(\n    extractLeaveGuards(deactivated),\n    this.router.beforeHooks,\n    extractUpdateHooks(updated),\n    activated.map(m => m.beforeEnter),\n    resolveAsyncComponents(activated)\n)\n```\n\n按照顺序如下：\n\n1. 在失活的组件里调用离开守卫。\n2. 调用全局的 beforeEach 守卫。\n3. 在重用的组件里调用 beforeRouteUpdate 守卫。\n4. 在激活的路由配置里调用 beforeEnter。\n5. 解析异步路由组件。\n\n这里执行了[完整的导航解析流程](https://router.vuejs.org/zh/guide/advanced/navigation-guards.html#%E7%BB%84%E4%BB%B6%E5%86%85%E7%9A%84%E5%AE%88%E5%8D%AB)的上半部分。\n\n* 第一步是通过执行 `extractLeavaGuards(deactivated)`, 在失活的组件里调用离开守卫 `beforeRouteLeave`:\n\n```Javascript\nfunction extractLeaveGuards (deactivated: Array<RouteRecord>): Array<?Function> {\n    return extractGuards(deactivated, 'beforeRouteLeave', bindGuard, true)\n}\n```\n\n内部调用了 `extractGuards` 的通用方法，可以从 `RouteRecord` 数组中提取各个阶段的守卫：\n\n```Javascript\nfunction extractGuards (\n    records: Array<RouteRecord>,\n    name: string,\n    bind: Function,\n    reverse?: boolean\n): Array<?Function> {\n    const guards = flatMapComponents(records, (def, instance, match, key) => {\n        // def 是 route\n        const guard = extractGuard(def, name)\n        if (guard) {\n            return Array.isArray(guard)\n                ? guard.map(guard => bind(guard, instance, match, key))\n                : bind(guard, instance, match, key)\n        }\n    })\n    return flatten(reverse ? guards.reverse() : guards)\n}\n\nexport function flatMapComponents (\n    matched: Array<RouteRecord>,\n    fn: Function\n): Array<?Function> {\n    return flatten(matched.map(m => {\n        return Object.keys(m.components).map(key => fn(\n            m.components[key],\n            m.instances[key],\n            m, key\n        ))\n    }))\n}\n\n// flatten 作用是把二维数组扁平为一维数组\nexport function flatten (arr: Array<any>): Array<any> {\n    return Array.prototype.concat.apply([], arr)\n}\n```\n\n**`flatMapComponents` 的作用就是返回一个数组**。数组的元素是从 `matched` 里获取到所有组件的 `key`，然后返回 `fn` 函数执行的结果，`flatten` 作用是把二维数组扁平为一维数组。\n\n那么对于 `extractGuards` 中 `flatMapComponents` 的调用，执行每个 `fn` 的时候，**通过 `extractGuard(def, name)` 获取到组件中对应 `name` 的导航守卫 `def.options[key]`**\n\n获取到 `guard` 后，还会调用 `bind` 方法把组件的实例 `instance` 作为函数执行的上下文绑定到 `guard` 上，`bind` 方法的对应的是 `bindGuard`:\n\n```Javascript\nfunction bindGuard (guard: NavigationGuard, instance: ?_Vue): ?NavigationGuard {\n    if (instance) {\n        return function boundRouteGuard () {\n            return guard.apply(instance, arguments)\n        }\n    }\n}\n```\n\n总结：**那么对于 `extractLeaveGuards(deactivated)` 而言，获取到的就是所有失活组件中定义的 `beforeRouteLeave` 钩子函数。**\n\n* 第二步是 `this.router.beforeHooks`, 获取的就是用户注册的全局 `beforeEach` 守卫。\n\n* 第三步执行了 `extractUpdateHooks(updated)`，和 `extractLeaveGuards(deactivated)` 类似，`extractUpdateHooks(updated)` 获取到的就是所有重用的组件中定义的 `beforeRouteUpdate` 钩子函数。\n\n* 第四步执行了 `activated.map(m => m.beforeEnter)`，获取的是在激活的路由配置中定义的 `beforeEnter` 函数。\n\n* 第五步是执行 `resolveAsyncComponents(activated)` 解析**异步组件**，解析完所有激活的异步组件后，我们就可以拿到这一次所有激活的组件。\n\n终于可以来到了重点的执行环节了：`runQueue`！\n\n```Javascript\nrunQueue(queue, iterator, () => {\n    const postEnterCbs = []\n    const isValid = () => this.current === route\n    // wait until async components are resolved before\n    // extracting in-component enter guards\n    const enterGuards = extractEnterGuards(activated, postEnterCbs, isValid)\n    const queue = enterGuards.concat(this.router.resolveHooks)\n    runQueue(queue, iterator, () => {\n        if (this.pending !== route) {\n            return abort()\n        }\n        this.pending = null\n        onComplete(route)\n        if (this.router.app) {\n            this.router.app.$nextTick(() => {\n                postEnterCbs.forEach(cb => { cb() })\n            })\n        }\n    })\n})\n```\n\n6. 在被激活的组件里调用 `beforeRouteEnter`。\n7. 调用全局的 `beforeResolve` 守卫 (2.5+)。\n8. 导航被确认。\n9. 调用全局的 afterEach 钩子。\n\n关于钩子函数的逻辑，后面有空再详细分析。路由在切换时除了执行钩子函数，还有关键的 2 个地方会发生变化：**一个是 url 发生变化，一个是组件发生变化**。\n\n##### URL\n\n必须得搞懂！\n\n不管是点击 `router-link` 还是直接调用直接调用 `this.$router.push`，都是调用 `history.push`：\n\n```Javascript\npush (location: RawLocation, onComplete?: Function, onAbort?: Function) {\n    this.history.push(location, onComplete, onAbort)\n}\n```\n\n我们看看 `hash` 模式下 `push` 函数的实现，源代码：*src/history/hash.js*\n\n```Javascript\npush (location: RawLocation, onComplete?: Function, onAbort?: Function) {\n    const { current: fromRoute } = this\n    this.transitionTo(location, route => {\n        pushHash(route.fullPath)\n        handleScroll(this.router, route, fromRoute, false)\n        onComplete && onComplete(route)\n    }, onAbort)\n}\n```\n\n* push 函数会先执行 this.transitionTo 切换路径（具体流程参考上面分析），在切换完成后执行回调函数，pushHash 函数：\n\n```Javascript\nfunction pushHash (path) {\n    if (supportsPushState) {\n        pushState(getUrl(path))\n    } else {\n        window.location.hash = path\n    }\n}\n\nfunction pushState (url?: string, replace?: boolean) {\n  saveScrollPosition() // 保存当前组件的滑动位置\n  const history = window.history\n  try {\n    if (replace) {\n      history.replaceState({ key: _key }, '', url)\n    } else {\n      _key = genKey()\n      history.pushState({ key: _key }, '', url)\n    }\n  } catch (e) {\n    window.location[replace ? 'replace' : 'assign'](url)\n  }\n}\n```\n\n`pushState` 会调用浏览器原生的 [`window.history`](https://developer.mozilla.org/zh-CN/docs/Web/API/History_API) 的 `pushState` 接口或者 `replaceState` 接口，添加和修改历史记录条目，更新浏览器的 `url` 地址，并把当前 `url` 压入历史栈中。\n\n关于 `pushState` 的详细讲解，请参考 [`MDN`](https://developer.mozilla.org/zh-CN/docs/Web/API/History_API)。\n\n**注意，调用 pushState 后浏览器并不会立即加载这个URL，但可能会在稍后某些情况下加载这个URL，比如在用户重新打开浏览器时。**\n\n而且在 VueRouter 初始化 history 时，会调用 `history.setupListeners()` 设置一个监听器，监听历史栈的变化：\n\n```Javascript\nsetupListeners () {\n    const router = this.router\n    const expectScroll = router.options.scrollBehavior\n    const supportsScroll = supportsPushState && expectScroll\n\n    if (supportsScroll) {\n        setupScroll()\n    }\n\n    window.addEventListener(supportsPushState ? 'popstate' : 'hashchange', () => {\n        const current = this.current\n        if (!ensureSlash()) {\n            return\n        }\n        this.transitionTo(getHash(), route => {\n            if (supportsScroll) {\n                handleScroll(this.router, route, current, true)\n            }\n            if (!supportsPushState) {\n                replaceHash(route.fullPath)\n            }\n        })\n    })\n}\n```\n\n当点击浏览器返回按钮的时候，则会触发 `popstate` 事件，然后拿到当前要跳转的 `hash`，执行 `transtionTo` 方法做一次路径转换。\n\n总结：`pushState` 和 `onpopstate` 就是 `hash` 模式下 `url` 变化过程的核心了。\n\n##### 组件\n\n当我们知道路由 url 的切换过程后，接下来就需要了解 `<router-view>` 组件是如何自动渲染最新路由的。源代码：*srx/components/view.js*：\n\n```Javascript\nrender (_, { props, children, parent, data }) {\n    ...\n\n    return h(component, data, children)\n}\n```\n\n组件 `render` 渲染函数首先获取当前的路径：\n\n```Javascript\nconst route = parent.$route\n```\n\n`<router-view>` 是支持嵌套的，需要遍历父节点，找出当前 `router-view` 的深度 `depth`，再根据当前线路匹配的路径和 `depth` 找到对应的 `RouteRecord`，进而找到该渲染的组件。\n\n```Javascript\nlet depth = 0\nwhile (parent && parent._routerRoot !== parent) {\n    if (parent.$vnode && parent.$vnode.data.routerView) {\n        depth++\n    }\n    parent = parent.$parent\n}\nconst matched = route.matched[depth]\n\nconst component = cache[name] = matched.components[name]\n```\n\n除了找到了应该渲染的组件 `component`，还定义了一个注册路由实例的方法：\n\n```Javascript\ndata.registerRouteInstance = (vm, val) => {\n    const current = matched.instances[name]\n    if (\n        (val && current !== vm) ||\n        (!val && current === vm)\n    ) {\n        matched.instances[name] = val\n    }\n}\n```\n\n给 `vnode` 的 `data` 定义了 `registerRouteInstance` 方法，其实在文章一开始的 `install` 时 `beforeCreate` 钩子函数 `mixin` 调用的 `registerInstance`，本质上就是调用上述的 `data.registerRouteInstance` 函数：\n\n```Javascript\nconst registerInstance = (vm, callVal) => {\n  let i = vm.$options._parentVnode\n  if (isDef(i) && isDef(i = i.data) && isDef(i = i.registerRouteInstance)) {\n    i(vm, callVal)\n  }\n}\n\nVue.mixin({\n  beforeCreate () {\n    // 相当于调用了 data.registerRouteInstance\n    registerInstance(this, this)\n  },\n  destroyed () {\n    registerInstance(this)\n  }\n})\n```\n\n`registerInstance` 的目的是给 `matched.instances[name]` 赋值当前组件的 `vm` 实例。\n\n`render` 函数的最后根据 `component` 渲染出对应的组件 `vonde`：\n\n```Javascript\nreturn h(component, data, children)\n```\n\n**关键点**：那么当我们执行 `transitionTo` 来更改路由线路后，组件是如何重新渲染的呢？\n\n答案是 `beforeCreate` 钩子函数的 `Vue.util.defineReactive(this, '_route', this._router.history.current)` 中的 `_route`。\n\n由于根Vue实例的 `_route` 属性是响应式的，当 `render` 函数访问 `parent.$route` 时，两者就产生了依赖。所以每当执行完 `transitionTo` 后，修改 `app._route` 时，就会通知渲染 `watcher` 更新，重新渲染组件。\n\none more time analyse（再回顾收集依赖和触发依赖的过程）：\n\n`<router-view>` 异步组件中的 `render` 渲染函数：\n\n```Javascript\nconst route = parent.$route\n```\n\n而这个 `parent` 实例的 `$route` 是在 `src/install.js` 中定义的：\n\n```Javascript\nObject.defineProperty(Vue.prototype, `$route`, {\n    get () { return this._routerRoot._route }\n})\n```\n\n① `render` 函数读取 `parent.$route` 时就会触发 `render` 的 `getter`，收集其依赖。\n\n然后再 `new Vue({router})` 时执行 `this._router.init`：\n\n```Javascript\nhistory.listen(route => {\n    this.apps.forEach((app) => {\n        app._route = route\n    })\n})\n\nlisten (cb: Function) {\n  this.cb = cb\n}\n```\n\n`history.listen` 接收的函数参数，是被设置为完成更新路由后的回调函数 `cb`：\n\n```Javascript\nhistory.listen(route => {\n    this.apps.forEach((app) => {\n        app._route = route\n    })\n})\n\nlisten (cb: Function) {\n  this.cb = cb\n}\n```\n\n会在更新路由函数 `updateRoute` 执行 `this.cb`：\n\n```Javascript\nupdateRoute (route: Route) {\n    const prev = this.current\n    this.current = route\n    this.cb && this.cb(route)  // 被执行的回调函数\n}\n```\n\n也就是执行 `transitionTo` 方法最后执行的 `updateRoute` 的时候执行回调 `cb`, 会将 `this.apps` 保存的组件实例 `app` 的 `_route` 设置为当前 `route`（`this.apps` 数组保存的实例的特点都是在初始化的时候有传入了 `router` 配置项的，一般的场景数组只会保存根 `Vue` 实例，数组长度为 1，因为我们只有在 `new Vue` 时传入了 `\brouter` 实例。\n\n② 由于修改 `app._route` 的时候，又触发了 `setter`，因此会通知 `<router-view>` 的渲染 watcher 更新，重新渲染组件。\n\n本文主要参考了 [Vue.js 技术揭秘](https://ustbhuangyi.github.io/vue-analysis/v2/vue-router/router.html#%E6%80%BB%E7%BB%93)，再加上自己的一点理解和注释。\n\n参考文章：\n[Vue.js 技术揭秘](https://ustbhuangyi.github.io/vue-analysis/v2/vue-router/router.html#%E6%80%BB%E7%BB%93)\n"},{"title":"JS：浅析 Vuex","url":"/2020/03/19/js-vuex/","content":"[Vuex](https://vuex.vuejs.org/zh/) 是一个专为 Vue.js 应用程序开发的**状态管理模式**。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。\n\n<!-- more -->\n\n![vuex](/images/js-vuex/vuex.png)\n\n先看看基本例子：\n\n```JavaScript\nimport Vuex from 'vuex'\n\ncont store =  new Vuex.Store({\n  actions,\n  getters,\n  state,\n  mutations,\n  modules\n  // ...\n})\n\nVue.use(Vuex)\n\nnew Vue({\n  store\n}).$mount('#app')\n```\n\n打开 `src/index.js`，`Vuex` 平时常用的 `API` 都包含在里面了。\n\n```JavaScript\nexport default {\n  Store,\n  install,\n  version: '__VERSION__',\n  mapState,\n  mapMutations,\n  mapGetters,\n  mapActions,\n  createNamespacedHelpers\n}\n```\n\n使用 `Vue.use(Vuex)` 初始化，其实是调用了 `Vuex` 的 `install` 方法，位于 `src/store.js`：\n\n```JavaScript\nfunction install (_Vue) {\n  Vue = _Vue\n  applyMixin(Vue)\n}\n\nfunction applyMixin(Vue) {\n  Vue.mixin({ beforeCreate: vuexInit })\n\n  function vuexInit () {\n    const options = this.$options\n    // store injection\n    if (options.store) {\n      this.$store = typeof options.store === 'function'\n        ? options.store()\n        : options.store\n    } else if (options.parent && options.parent.$store) {\n      this.$store = options.parent.$store\n    }\n  }\n}\n```\n\n`install` 方法是在全局 `beforeCreate` 钩子函数 `mixin` 了 `vuexInit` 方法，把根 `Vue` 实例的 `options.store` 保存在所有组件的 `this.$store` 中。`options.store` 就是我们在 `new Vue({store})` 时传入的 `store` 实例，**因此，我们在所有的组件都可以通过 `this.$store` 访问到这个实例**。\n\n### Store\n\n那么接下来我们分析上面 `store` 实例化的过程：\n\n```Javascript\nconst store = new Vuex.Store({\n  actions,\n  getters,\n  state,\n  mutations,\n  modules\n  // ...\n})\n```\n\n`Vuex` 的 `Store` 对象的构造函数接收一个对象参数 `options`，其包含 `state`、`getters`、`mutations`、`actions`、`modules` 等 Vuex 的核心概念。源代码 `src/store.js`：\n\n```Javascript\nexport class Store {\n  constructor (options = {}) {\n    // ...\n    this._modules = new ModuleCollection(options)\n\n    const store = this\n    const { dispatch, commit } = this\n    this.dispatch = function boundDispatch (type, payload) {\n      return dispatch.call(store, type, payload)\n    }\n    this.commit = function boundCommit (type, payload, options) {\n      return commit.call(store, type, payload, options)\n    }\n\n    // ...\n    installModule(this, state, [], this._modules.root)\n    resetStoreVM(this, state)\n    // ...\n  }\n}\n```\n\nStore 的实例化过程拆成3个部分，分别是 `初始化模块`、`安装模块`和 `初始化 store._vm`。\n\n#### 初始化模块\n\n`Store` 是单一状态树， `Vuex` 允许我们将 `store` 分割成模块 module，每个 `module` 拥有自己的 `state`、`getters`、`mutations`、`actions` 还有 `modules`：\n\n```Javascript\nconst moduleA = {\n  state: { ... },\n  getters: { ... },\n  mutations: { ... },\n  actions: { ... },\n  modules: { ... }\n}\n\nconst moduleB = {\n  ...\n}\n\nconst store = new Vuex.Store({\n  modules: {\n    a: moduleA,\n    b: moduleB\n  }\n})\n\nstore.state.a // -> moduleA 的状态\nstore.state.b // -> moduleB 的状态\n```\n\n`store` 本身可以理解为一个 `root module`，下面的 `_modules` 就是子模块，`Vuex` 需要完成这棵树的构建，构建过程的入口是：\n\n```Javascript\nthis._modules = new ModuleCollection(options)\n```\n\n`ModuleCollection` 源代码 `src/module/module-collection.js`：\n\n```Javascript\nexport default class ModuleCollection {\n  constructor (rawRootModule) {\n    // register root module (Vuex.Store options)\n    this.register([], rawRootModule, false)\n  }\n\n  register (path, rawModule, runtime = true) {\n    const newModule = new Module(rawModule, runtime)\n    if (path.length === 0) {\n      this.root = newModule\n    } else {\n      const parent = this.get(path.slice(0, -1))\n      parent.addChild(path[path.length - 1], newModule)\n    }\n\n    // register nested modules\n    if (rawModule.modules) {\n      forEachValue(rawModule.modules, (rawChildModule, key) => {\n        this.register(path.concat(key), rawChildModule, runtime)\n      })\n    }\n  }\n}\n```\n\n`ModuleCollection` 实例化的过程就是执行了 `register` 方法，接收3个参数：\n\n* path：表示路径，因为整体目标是要构建一颗模块树\n* rawModule：表示定义模块的原始配置\n* runtime：表示是否是一个运行时创建的模块\n\n`register` 方法首先通过 `const newModule = new Module(rawModule, runtime)` 创建了一个 root `Module` 实例, Module 是用来描述单个模块的类，源代码 `src/module/module.js`：\n\n```Javascript\nexport default class Module {\n  constructor (rawModule, runtime) {\n    this.runtime = runtime\n    this._children = Object.create(null)\n    this._rawModule = rawModule\n    const rawState = rawModule.state\n\n    // Store the origin module's state\n    this.state = (typeof rawState === 'function' ? rawState() : rawState) || {}\n  }\n}\n```\n\n从构造函数可以分析，每个 `Module` 模块包含三个属性 `_rawModule`、`_children`、`state`：\n\n* `_rawModule` 存储模块的配置，对象本身\n* `_children` 表示该模块的所有子模块，就是 `module` 定义的 `modules`\n* `state` 表示模块定义的 `state`\n\n最后递归构建成了完整的模块树：\n\n```Javascript\nconst store = new Vuex.Store({\n    modules: {\n        aM,\n        bM,\n        cM,\n    },\n    state: {\n        dS,\n        eS\n    },\n    getters,\n    mutations: {}\n});\n\n// this._modules = new ModuleCollection(options)\n// 转化成不同的数据结构类型\n_modules = {\n  root: {\n    _children: {\n      aM: {\n        _children: {}\n        _rawModule: {},\n        state\n      },\n      bM,\n      cM\n    }, // 相当于 modules\n    _rawModule: {modules, state, getters, mutations}, // 对象本身\n    state: {dS, eS} // state 照搬过来，不变\n  }\n}\n```\n\n#### 安装模块\n\n初始化模块后 `_modules`，执行安装模块的相关逻辑，它的目标就是对模块中的 `state`、`getters`、`mutations`、`actions` 做初始化工作：\n\n```Javascript\nconst state = this._modules.root.state\ninstallModule(this, state, [], this._modules.root)\n\nfunction installModule (store, rootState, path, module, hot) {\n  const isRoot = !path.length\n  const namespace = store._modules.getNamespace(path)\n\n  // register in namespace map\n  if (module.namespaced) {\n    store._modulesNamespaceMap[namespace] = module\n  }\n\n  const local = module.context = makeLocalContext(store, namespace, path)\n\n  module.forEachMutation((mutation, key) => {\n    const namespacedType = namespace + key\n    registerMutation(store, namespacedType, mutation, local)\n  })\n\n  module.forEachAction((action, key) => {\n    const type = action.root ? key : namespace + key\n    const handler = action.handler || action\n    registerAction(store, type, handler, local)\n  })\n\n  module.forEachGetter((getter, key) => {\n    const namespacedType = namespace + key\n    registerGetter(store, namespacedType, getter, local)\n  })\n\n  module.forEachChild((child, key) => {\n    installModule(store, rootState, path.concat(key), child, hot)\n  })\n}\n```\n\n`installModule` 方法接收了 5 个参数：\n\n* store：root store\n* state：root state\n* path：模块的访问路径\n* module：当前的模块\n* hot：表示是否热更新\n\n`installModule` 方法根据 `namespaced` 对所有的 `getter`、`action` 和 `mutation` 注册的路径进行调整命名。\n\n##### registerMutation\n\n```Javascript\nmodule.forEachMutation((mutation, key) => {\n  const namespacedType = namespace + key\n  registerMutation(store, namespacedType, mutation, local)\n})\n\n// handler 就是 mutation\nfunction registerMutation (store, type, handler, local) {\n  const entry = store._mutations[type] || (store._mutations[type] = [])\n  entry.push(function wrappedMutationHandler (payload) {\n    handler.call(store, local.state, payload)\n  })\n}\n```\n\n首先遍历模块中的 `mutations` 的定义，拿到每一个 `mutation` 和 `key`，并把 `key` 拼接 `namespace`，然后执行 `registerMutation` 方法，该方法实际上就是给 `root store` 上的 `_mutations[type]` 添加 `wrappedMutationHandler` 方法。注意： `_mutations[type]` 是个数组，同一 `type` 的 `_mutations` 可以对应多个方法。\n\n##### registerAction\n\n```Javascript\nmodule.forEachAction((action, key) => {\n  const type = action.root ? key : namespace + key\n  const handler = action.handler || action\n  registerAction(store, type, handler, local)\n})\n\nfunction registerAction (store, type, handler, local) {\n  const entry = store._actions[type] || (store._actions[type] = [])\n  entry.push(function wrappedActionHandler (payload, cb) {\n    let res = handler.call(store, {\n      dispatch: local.dispatch,\n      commit: local.commit,\n      getters: local.getters,\n      state: local.state,\n      rootGetters: store.getters,\n      rootState: store.state\n    }, payload, cb)\n    if (!isPromise(res)) {\n      res = Promise.resolve(res)\n    }\n    if (store._devtoolHook) {\n      return res.catch(err => {\n        store._devtoolHook.emit('vuex:error', err)\n        throw err\n      })\n    } else {\n      return res\n    }\n  })\n}\n```\n\n原理跟 `registerMutation` 相似。\n\n总结：`installModule` 本质上就是完成了模块下的 `state`、`getters`、`actions`、`mutations` 的初始化工作，并且通过递归遍历的方法，就完成了所有子模块的安装工作（在 `store` 添加以上_前缀的属性和完整 `state`）。\n\n结果就是：\n\n```Javascript\nstore: {\n  _actions: {},\n  _mutations: {},\n  _wrappedGetters: {},\n  _modules: {},\n}\n```\n\n#### 初始化 store._vm\n\n`Store` 实例化的最后一步，就是执行初始化 `store._vm` 的逻辑：\n\n```Javascript\nresetStoreVM(this, state)\n\nfunction resetStoreVM (store, state, hot) {\n  const oldVm = store._vm\n\n  // getters 开始\n  // bind store public getters\n  store.getters = {}\n  const wrappedGetters = store._wrappedGetters\n  const computed = {}\n  forEachValue(wrappedGetters, (fn, key) => {\n    // use computed to leverage its lazy-caching mechanism\n    computed[key] = () => fn(store)\n    Object.defineProperty(store.getters, key, {\n      get: () => store._vm[key],\n      enumerable: true // for local getters\n    })\n  })\n\n  // use a Vue instance to store the state tree\n  // suppress warnings just in case the user has added\n  // some funky global mixins\n  const silent = Vue.config.silent\n  Vue.config.silent = true\n  store._vm = new Vue({\n    data: {\n      $$state: state\n    },\n    computed\n  })\n  // getters 结束\n  Vue.config.silent = silent\n\n  // enable strict mode for new vm\n  if (store.strict) {\n    enableStrictMode(store)\n  }\n\n  if (oldVm) {\n    if (hot) {\n      // dispatch changes in all subscribed watchers\n      // to force getter re-evaluation for hot reloading.\n      store._withCommit(() => {\n        oldVm._data.$$state = null\n      })\n    }\n    Vue.nextTick(() => oldVm.$destroy())\n  }\n}\n```\n\n① `resetStoreVM` 的作用实际上就是建立 getters 和 state 的联系，利用 Vue 中的 `computed` 计算属性来实现。\n\n```Javascript\nstore._vm = new Vue({\n  data: {\n    $$state: state\n  },\n  computed\n})\n```\n\n`data` 选项里定义了 `$$state` 属性，访问 `store.state` 的时候，实际上会访问 `Store` 类上定义的 `state` 的 `get` 方法：\n\n```Javascript\nget state () {\n  return this._vm._data.$$state\n}\n```\n\n那么 getters 和 state 是怎么建立依赖逻辑的呢：\n\n```Javascript\norEachValue(wrappedGetters, (fn, key) => {\n  // use computed to leverage its lazy-caching mechanism\n  computed[key] = () => fn(store)\n  Object.defineProperty(store.getters, key, {\n    get: () => store._vm[key],\n    enumerable: true // for local getters\n  })\n})\n```\n\n② 当我根据 `key` 访问 `store.getters` 的某一个 `getter` 的时候，实际上就是访问 `store._vm[key]`（也就是 `computed[key]`），执行 `computed[key]` 对应的函数时会执行 `rawGetter(local.state,...)` 方法，就会访问到 `store.state`（也就是 `store._vm._data.$$state`），从而建立了 `getter` 和 `state` 的依赖关系。当 `store.state` 发生变化的时候，下一次再访问 `store.getters` 的时候会重新计算。\n\n③ 严格模式的逻辑：\n\n```Javascript\nif (store.strict) {\n  enableStrictMode(store)\n}\n\nfunction enableStrictMode (store) {\n  store._vm.$watch(function () { return this._data.$$state }, () => {\n    if (process.env.NODE_ENV !== 'production') {\n      assert(store._committing, `Do not mutate vuex store state outside mutation handlers.`)\n    }\n  }, { deep: true, sync: true })\n}\n```\n\n`store._vm` 会添加一个 `wathcer` 来观测 `this._data.$$state` 的变化，也就是当 `store.state` 被修改的时候, `store._committing` 必须为 `true`，否则在开发阶段会报警告。\n\n`store._committing` 默认为 false，只有执行 _withCommit 方法时才设置成 true：\n\n```Javascript\n_withCommit (fn) {\n  const committing = this._committing\n  this._committing = true\n  fn()\n  this._committing = committing\n}\n```\n\n**`_withCommit` 也是说明 `mutation` 为什么必须是同步函数的原因了**。一旦 `mutation` 是异步函数时，会由 `this._committing = true` 立即执行到 `this._committing = committing`，而此时异步 `mutation` 才执行完成且想要修改数据 `state`，是会报错的，因为此时的 `_committing` 为 false。\n\n### API\n\n其余的 API 再做详细分析。\n\n参考文章：\n\n[Vue.js 技术揭秘](https://ustbhuangyi.github.io/vue-analysis/v2/vuex/init.html#store-%E5%AE%9E%E4%BE%8B%E5%8C%96)\n"},{"title":"JS：潜伏的设计模式","url":"/2020/03/15/js-design-pattern/","content":"\n设计模式就是一种经验总结，最终的目的是为了更好的代码重用性、可读性、可靠性、可维护性。**设计模式的本质是*面向对象设计原则*的实际运用，是对类的封装性、继承性和多态性，以及类的关联关系和组合关系的总结应用。**\n<!-- more -->\n\n<!-- ![总纲](/images/js-design-pattern/all.png) -->\n\n### 设计模式原则\n\n设计模式万变不离其宗，其核心必然围绕六大原则展开的：\n\n1. 开闭原则\n2. 里氏替换原则\n3. 依赖反转原则\n4. 接口隔离原则\n5. 最小知道原则\n6. 合成复用原则\n\n![设计模式六大原则](/images/js-design-pattern/principle.png)\n\n#### 开闭原则（Open Close Principle）\n\n开闭原则：对外扩展**开放**，对内修改**关闭**。设计上往往需要使用接口和抽象类，提供灵活的插件机制，实现热插拔效果。\n\n#### 里氏替换原则（Liskov Substitution Principle）\n\n> 里氏替换原则要求，任何基类（父类）可以发挥作用的地方，子类一定可以发挥作用。\n\n里氏替换原则是继承复用的基础，只有当派生类可以随时替换掉其基类，同时功能不被破坏，基类的方法仍然能被使用，这才是真正的继承，继承才能真正地实现复用。\n\n#### 依赖反转原则（Dependence Inversion Principle）\n\n该原则要求针对接口编程，依赖于抽象。\n\n#### 接口隔离原则（Interface Segregation Principle）\n\n接口隔离的意思或者目的是减少耦合的出现。在大型软件架构中，使用多个相互隔离的接口，一定比使用单个大而全的接口要好。\n\n#### 最少知道原则，又称迪米特法则（Demeter Principle）\n\n最少知道顾名思义，是指：一个系统的功能模块应该最大限度地不知晓其他模块的出现，减少感知，模块应相对独立。\n\n#### 合成复用原则（Composite Reuse Principle）\n\n合成复用原则是指：尽量使用合成 / 聚合的方式，而不是使用继承。\n\n### 设计模式介绍\n\n所有的设计模式可以归结为三大类：\n\n* 创建型\n* 结构型\n* 行为型\n\n![设计模式](/images/js-design-pattern/pattern.png)\n\n#### 原型模式（prototype）\n\n原型模式不仅是一种设计模式，它还是一种编程范式（programming paradigm），是 JavaScript 面向对象系统实现的根基。\n\n在原型模式下，当我们想要创建一个对象时，会先找到一个对象作为原型，然后通过**克隆原型**的方式来创建出一个与原型一样（共享一套数据/方法）的对象。在 JavaScript 里，Object.create方法就是原型模式的天然实现——准确地说，只要我们还在借助Prototype来实现对象的创建和原型的继承，那么我们就是在应用原型模式。\n\n* **原型**\n\n在 JavaScript 中，每个构造函数都拥有一个prototype属性，它指向构造函数的原型对象，这个原型对象中有一个 construtor 属性指回构造函数；每个实例都有一个__proto__属性，当我们使用构造函数去创建实例时，实例的__proto__属性就会指向构造函数的原型对象。\n\n具体来说，当我们这样使用构造函数创建一个对象时：\n\n```JavaScript\n// 创建一个Dog构造函数\nfunction Dog(name, age) {\n  this.name = name\n  this.age = age\n}\n\nDog.prototype.eat = function() {\n  console.log('肉骨头真好吃')\n}\n\n// 使用Dog构造函数创建dog实例\nconst dog = new Dog('旺财', 3)\n```\n\n![设计模式](/images/js-design-pattern/prototype.png)\n\n* **原型链**\n\n```JavaScript\n// 输出\"肉骨头真好吃\"\ndog.eat()\n\n// 输出\"[object Object]\"\ndog.toString()\n```\n\n明明没有在 dog 实例里手动定义 eat 方法和 toString 方法，它们还是被成功地调用了。这是因为当我试图访问一个 JavaScript 实例的属性/方法时，它首先搜索这个实例本身；当发现实例没有定义对应的属性/方法时，它会转而去搜索实例的原型对象；如果原型对象中也搜索不到，它就去搜索原型对象的原型对象，这个搜索的轨迹，就叫做原型链。\n\n![设计模式](/images/js-design-pattern/prototype2.png)\n\n彼此相连的prototype，就组成了一个原型链。 注： 几乎所有 JavaScript 中的对象都是位于原型链顶端的 Object 的实例，除了Object.prototype（当然，如果我们手动用Object.create(null)创建一个没有任何原型的对象，那它也不是 Object 的实例）。\n\n重点：**对象的深拷贝**\n\n```JavaScript\nfunction deepClone(obj) {\n    // 如果是 值类型 或 null，则直接return\n    if(typeof obj !== 'object' || obj === null) {\n        return obj\n    }\n\n    // 定义结果对象\n    let copy = {}\n\n    // 如果对象是数组，则定义结果数组\n    if(obj.constructor === Array) {\n        copy = []\n    }\n\n    // 遍历对象的key\n    for(let key in obj) {\n        // 如果key是对象的自有属性\n        if(obj.hasOwnProperty(key)) {\n            // 递归调用深拷贝方法\n            copy[key] = deepClone(obj[key])\n        }\n    }\n\n    return copy\n}\n```\n\n#### 单例模式（Singleton）\n\n通俗来说，保证一个类只能有一个实例，并提供一个访问它的全局访问点，每次只返回第一次创建的唯一的一个实例。应用场景：引用第三方库，全局唯一的对象或者状态管理，全局唯一的插件\n\n* ES6 实现\n\n```JavaScript\nclass Singleton {\n  constructor() {\n    if (!Singleton.instance) {\n      Singleton.instance = this;\n    }\n\n    return Singleton.instance;\n  }\n}\n\nnew Singleton()\n\n// 或者 static 方法\n\nclass Singleton {\n    static getInstance() {\n        // 判断是否已经new过1个实例\n        if (!SingleDog.instance) {\n            // 若这个唯一的实例不存在，那么先创建它\n            SingleDog.instance = new SingleDog()\n        }\n        // 如果这个唯一的实例已经存在，则直接返回\n        return SingleDog.instance\n    }\n}\n\nSingleton.getInstance()\n```\n\n* 闭包实现\n\n```JavaScript\nSingleton.getInstance = (function() {\n    // 定义自由变量instance，模拟私有变量\n    let instance = null\n    return function() {\n        // 判断自由变量是否为null\n        if(!instance) {\n            // 如果为null则new出唯一实例\n            instance = new Singleton()\n        }\n        return instance\n    }\n})()\n```\n\n**生产实践**：Vuex 的 store || 实现全局 Modal\n\n#### 工厂模式（Factory）\n\n工厂模式就是隐藏了创建一个实例的复杂度，只需要提供一个简单的接口调用，直接完成创建实例的目的。\n\n创建型的工厂模式一共分为三种：\n\n* 简单工厂模式（Simple Factory）\n* 工厂方法模式（Factory Method）\n* 抽象工厂模式（Abstract Factory）\n\n```JavaScript\n// 抽象工厂不干活，具体工厂（ConcreteFactory）来干活！\n\n// 抽象工厂：手机的基本组成\nclass MobilePhoneFactory {\n    // 提供操作系统的接口\n    createOS(){\n        throw new Error(\"抽象工厂方法不允许直接调用，你需要将我重写！\");\n    }\n    // 提供硬件的接口\n    createHardWare(){\n        throw new Error(\"抽象工厂方法不允许直接调用，你需要将我重写！\");\n    }\n}\n\n// 具体工厂继承自抽象工厂\nclass FakeStarFactory extends MobilePhoneFactory {\n    createOS() {\n        // 提供安卓系统实例\n        return new AndroidOS()\n    }\n    createHardWare() {\n        // 提供高通硬件实例\n        return new QualcommHardWare()\n    }\n}\n\n// 定义操作系统这类产品的抽象产品类\nclass OS {\n    controlHardWare() {\n        throw new Error('抽象产品方法不允许直接调用，你需要将我重写！');\n    }\n}\n\n// 定义具体操作系统的具体产品类\nclass AndroidOS extends OS {\n    controlHardWare() {\n        console.log('我会用安卓的方式去操作硬件')\n    }\n}\n\nclass AppleOS extends OS {\n    controlHardWare() {\n        console.log('我会用🍎的方式去操作硬件')\n    }\n}\n...\n\n// 定义手机硬件这类产品的抽象产品类\nclass HardWare {\n    // 手机硬件的共性方法，这里提取了“根据命令运转”这个共性\n    operateByOrder() {\n        throw new Error('抽象产品方法不允许直接调用，你需要将我重写！');\n    }\n}\n\n// 定义具体硬件的具体产品类\nclass QualcommHardWare extends HardWare {\n    operateByOrder() {\n        console.log('我会用高通的方式去运转')\n    }\n}\n\nclass MiWare extends HardWare {\n    operateByOrder() {\n        console.log('我会用小米的方式去运转')\n    }\n}\n...\n\n\n// 这是我的手机\nconst myPhone = new FakeStarFactory()\n// 让它拥有操作系统\nconst myOS = myPhone.createOS()\n// 让它拥有硬件\nconst myHardWare = myPhone.createHardWare()\n// 启动操作系统(输出‘我会用安卓的方式去操作硬件’)\nmyOS.controlHardWare()\n// 唤醒硬件(输出‘我会用高通的方式去运转’)\nmyHardWare.operateByOrder()\n```\n\n使用抽象类去降低扩展的成本，同时需要对类的性质作划分，于是有了这样的四个关键角色：\n\n1. 抽象工厂（抽象类，它不能被用于生成具体实例）： 用于声明最终目标产品的共性。在一个系统里，抽象工厂可以有多个（大家可以想象我们的手机厂后来被一个更大的厂收购了，这个厂里除了手机抽象类，还有平板、游戏机抽象类等等），每一个抽象工厂对应的这一类的产品，被称为“产品族”。\n2. 具体工厂（用于生成产品族里的一个具体的产品）： 继承自抽象工厂、实现了抽象工厂里声明的那些方法，用于创建具体的产品的类。\n3. 抽象产品（抽象类，它不能被用于生成具体实例）： 上面我们看到，具体工厂里实现的接口，会依赖一些类，这些类对应到各种各样的具体的细粒度产品（比如操作系统、硬件等），这些具体产品类的共性各自抽离，便对应到了各自的抽象产品类。\n4. 具体产品（用于生成产品族里的一个具体的产品所依赖的更细粒度的产品）： 比如我们上文中具体的一种操作系统、或具体的一种硬件等。\n\n#### 建造者模式（builder）\n\n建造者的精髓在于“分步骤分情况构建一个复杂的对象”。与函数式编程一般，每次调用方法返回的都是对象本身，可以继续调用自身方法，形成调用链。\n\n```JavaScript\n// 建造者\nclass Pizza {\n    constructor(size) {\n        this.size = size\n    }\n\n    addMushroom() {\n        this.mushroom = true\n        return this\n    }\n\n    addOliver() {\n        this.oliver = true\n        return this\n    }\n\n    addPoulet() {\n        this.poulet = true\n        return this\n    }\n\n    addChesse() {\n        this.chesse = true\n        return this\n    }\n\n    addTomato() {\n        this.tomato = true\n        return this\n    }\n\n    addLettuce() {\n        this.lettuce = true\n        return this\n    }\n\n    build() {\n        return new Pizza(this)\n    }\n}\n\n// 调用方法\nnew Pizza(32)\n    .addOliver()\n    .addTomato()\n    .build()\n```\n\n#### 外观模式（Facade）\n\n外观模式的精髓在于对接口进行二次封装，隐藏其内部的复杂度。这种设计在前端开发中也非常常见，比如跨浏览器兼容性的封装，比如事件：\n\n```Javascript\n// polyfill\nconst addMyEventFacade = function(el, ev, fn) {\n  if (el.addEventListener) {//存在 DOM2 级方法，则使用并传入事件类型、事件处理程序函数和第3个参数 false（表示冒泡阶段）\n    el.addEventListener(ev, fn, false);\n  } else if(el.attachEvent) { // 为兼容 IE8 及更早浏览器，注意事件类型必须加上\"on\"前缀\n    el.attachEvent(\"on\" + ev, fn);\n  } else {\n    el[\"on\" + ev] = fn;//其他方法都无效，默认采用 DOM0 级方法，使用方括号语法将属性名指定为事件处理程序\n  }\n};\n```\n\n#### 适配器模式（adapter）\n\n适配器模式在于适配两个及以上类接口不兼容的问题，适用于迁移代码和兼容代码。\n> 适配器：电器转接头\n\n#### 代理模式（proxy）\n\n代理模式往往是一个对象不能直接访问另一个对象，需要一个第三者（代理）牵线搭桥从而间接达到访问目的。科学上网（代理劫持）是代理模式的典型案例。\n\n![代理模式](/images/js-design-pattern/proxy.png)\n\n前置知识：**ES6 中的 Proxy**\n\n```Javascript\n// 代理劫持 GET 和 SET\nconst proxy = new Proxy(obj, handler)\n```\n\n开发中最常见的四种代理类型：事件代理、虚拟代理、缓存代理和保护代理来进行讲解。\n\n* 事件代理\n  利用元素事件冒泡的特性，不需要在每个子元素都绑定相同的事件，直接在父元素上绑定，这就是事件代理了。\n\n* 虚拟代理\n    图片预加载：先让这个 img 标签展示一个占位图，然后创建一个 Image 实例，让这个 Image 实例的 src 指向真实的目标图片地址、观察该 Image 实例的加载情况 —— 当其对应的真实图片加载完毕后，即已经有了该图片的缓存内容，再将 DOM 上的 img 元素的 src 指向真实的目标图片地址。此时我们直接去取了目标图片的缓存。\n\n```Javascript\n// 骨架屏示例\nclass PreLoadImage {\n    constructor(imgNode) {\n        // 获取真实的DOM节点\n        this.imgNode = imgNode\n    }\n\n    // 操作img节点的src属性\n    setSrc(imgUrl) {\n        this.imgNode.src = imgUrl\n    }\n}\n\nclass ProxyImage {\n    // 占位图的url地址\n    static LOADING_URL = 'xxxxxx'\n\n    constructor(targetImage) {\n        // 目标Image，即PreLoadImage实例\n        this.targetImage = targetImage\n    }\n\n    // 该方法主要操作虚拟Image，完成加载\n    setSrc(targetUrl) {\n       // 真实img节点初始化时展示的是一个占位图\n        this.targetImage.setSrc(ProxyImage.LOADING_URL)\n\n        // 创建一个帮我们加载图片的虚拟Image实例\n        const virtualImage = new Image()\n        // 监听目标图片加载的情况，完成时再将DOM上的真实img节点的src属性设置为目标图片的url\n        virtualImage.onload = () => {\n            this.targetImage.setSrc(targetUrl)\n        }\n        // 设置src属性，虚拟Image实例开始加载图片\n        virtualImage.src = targetUrl\n    }\n}\n\n// ProxyImage 帮我们调度了预加载相关的工作，我们可以通过 ProxyImage 这个代理，实现对真实 img 节点的间接访问，并得到我们想要的效果。\n```\n  \n* 虚拟代理\n  用空间换时间\n\n```Javascript\n// addAll方法会对你传入的所有参数做求和操作\nconst addAll = function() {\n    console.log('进行了一次新计算')\n    let result = 0\n    const len = arguments.length\n    for(let i = 0; i < len; i++) {\n        result += arguments[i]\n    }\n    return result\n}\n\n// 为求和方法创建代理\nconst proxyAddAll = (function(){\n    // 求和结果的缓存池\n    const resultCache = {}\n    return function() {\n        // 将入参转化为一个唯一的入参字符串\n        const args = Array.prototype.join.call(arguments, ',')\n\n        // 检查本次入参是否有对应的计算结果\n        if(args in resultCache) {\n            // 如果有，则返回缓存池里现成的结果\n            return resultCache[args]\n        }\n        return resultCache[args] = addAll(...arguments)\n    }\n})()\n```\n\n#### 装饰器模式（decorator）\n\n在不改变原对象的基础上，对其对象进行包装和拓展，使原对象能够应对更加复杂的需求。\n\n1. extends：\n\n```Javascript\nclass App extends Component\n```\n\n2. AOP 面向切面编程：\n\n```Javascript\nFunction.prototype.before = function(fn) {\n  const self = this\n  return function() {\n    fn.apply(new(self), arguments)\n    return self.apply(new(self), arguments)\n  }\n}\n\nFunction.prototype.after = function(fn) {\n  const self = this\n  return function() {\n    self.apply(new(self), arguments)\n    return fn.apply(new(self), arguments)\n  }\n}\n```\n\n3. ES7 中的装饰器\n\n```Javascript\n// 装饰器函数，它的第一个参数是目标类\nfunction classDecorator(target) {\n    target.hasDecorator = true\n    return target\n}\n\n// 将装饰器“安装”到Button类上\n@classDecorator\nclass Button {\n    // Button类的相关逻辑\n}\n\n// 验证装饰器是否生效\nconsole.log('Button 是否被装饰了：', Button.hasDecorator)\n```\n\n```Javascript\nfunction funcDecorator(target, name, descriptor) {\n    let originalMethod = descriptor.value\n    descriptor.value = function() {\n    console.log('我是Func的装饰器逻辑')\n    return originalMethod.apply(this, arguments)\n  }\n  return descriptor\n}\n\nclass Button {\n    @funcDecorator\n    onClick() {\n        console.log('我是Func的原有逻辑')\n    }\n}\n\n// 验证装饰器是否生效\nconst button = new Button()\nbutton.onClick()\n```\n\n#### 策略模式（）\n\n策略模式就是通过构建对象映射表来消除 if-else，与状态模式相似。\n> 定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换。\n\n```Javascript\n// 定义一个询价处理器对象\nconst priceProcessor = {\n  pre(originPrice) {\n    if (originPrice >= 100) {\n      return originPrice - 20;\n    }\n    return originPrice * 0.9;\n  },\n  onSale(originPrice) {\n    if (originPrice >= 100) {\n      return originPrice - 30;\n    }\n    return originPrice * 0.8;\n  },\n  back(originPrice) {\n    if (originPrice >= 200) {\n      return originPrice - 50;\n    }\n    return originPrice;\n  },\n  fresh(originPrice) {\n    return originPrice * 0.5;\n  }\n};\n\n// 询价函数\nfunction askPrice(tag, originPrice) {\n  return priceProcessor[tag](originPrice)\n}\n```\n\n#### 观察者模式（Objecter）\n\n观察者模式基于发布-订阅,目标对象的状态发生变化时，会通知所有观察者对象，使它们能够自动更新。\n\n* 抽象发布-订阅\n\n```Javascript\n// 定义发布者类\nclass Publisher {\n  constructor() {\n    this.observers = []\n    console.log('Publisher created')\n  }\n  // 增加订阅者\n  add(observer) {\n    console.log('Publisher.add invoked')\n    this.observers.push(observer)\n  }\n  // 移除订阅者\n  remove(observer) {\n    console.log('Publisher.remove invoked')\n    this.observers.forEach((item, i) => {\n      if (item === observer) {\n        this.observers.splice(i, 1)\n      }\n    })\n  }\n  // 通知所有订阅者\n  notify() {\n    console.log('Publisher.notify invoked')\n    this.observers.forEach((observer) => {\n      observer.update(this)\n    })\n  }\n}\n\n// 定义订阅者类\nclass Observer {\n    constructor() {\n        console.log('Observer created')\n    }\n\n    update() {\n        console.log('Observer.update invoked')\n    }\n}\n```\n\n* 具体发布-订阅\n\n```Javascript\n// 定义一个具体的需求文档（prd）发布类\nclass PrdPublisher extends Publisher {\n    constructor() {\n        super()\n        // 初始化需求文档\n        this.prdState = null\n        // 韩梅梅还没有拉群，开发群目前为空\n        this.observers = []\n        console.log('PrdPublisher created')\n    }\n\n    // 该方法用于获取当前的prdState\n    getState() {\n        console.log('PrdPublisher.getState invoked')\n        return this.prdState\n    }\n\n    // 该方法用于改变prdState的值\n    setState(state) {\n        console.log('PrdPublisher.setState invoked')\n        // prd的值发生改变\n        this.prdState = state\n        // 需求文档变更，立刻通知所有开发者\n        this.notify()\n    }\n}\n\n// 定义订阅者类\nclass DeveloperObserver extends Observer {\n    constructor() {\n        super()\n        // 需求文档一开始还不存在，prd初始为空对象\n        this.prdState = {}\n        console.log('DeveloperObserver created')\n    }\n\n    // 重写一个具体的update方法\n    update(publisher) {\n        console.log('DeveloperObserver.update invoked')\n        // 更新需求文档\n        this.prdState = publisher.getState()\n        // 调用工作函数\n        this.work()\n    }\n\n    // work方法，一个专门搬砖的方法\n    work() {\n        // 获取需求文档\n        const prd = this.prdState\n        // 开始基于需求文档提供的信息搬砖。。。\n        ...\n        console.log('996 begins...')\n    }\n}\n```\n\n参考文章：\n\n[揭秘前端设计模式（上）](https://gitbook.cn/gitchat/column/5c91c813968b1d64b1e08fde/topic/5cbbf556bbbba80861a35c6e)\n\n[揭秘前端设计模式（下）](https://gitbook.cn/gitchat/column/5c91c813968b1d64b1e08fde/topic/5cbbf575bbbba80861a35c6f)\n\n[JavaScript 设计模式核⼼原理与应⽤实践](https://juejin.im/book/5c70fc83518825428d7f9dfb/section/5c8bb9a3f265da2d8410cb7e)\n","tags":["JS"]},{"title":"WEB：不起眼的 Webpack","url":"/2020/03/08/web-webpack/","content":"\nWebpack 是一个打包模块化 Javascript 的工具，在 webpack 里**一切皆模块**，通过 **`Loader`** 转换文件，通过 **`Plugin`** 注入钩子，最后输出由多个模块组合成的文件。webpack 专注于构建模块化项目。\n\n<!-- more -->\n\n**<font color=\"red\">以 webpack 5.x 为本文讲解版本。(篇幅太大，后续会再分篇详细论述)。</font>**\n\n![2021-road-map](/images/web-webpack/webpack-slogan.png)\n\n**<font color=\"red\">提前划重点：核心模块为 Loader 和 Plugin 两种开放接口。</font>**\n\n\n## 入门篇\n\n老样子，先动手搭建基础款的 Webpack 项目：\n\n### 安装依赖\n\n1. 初始化项目：\n\n```Shell\n    mkdir webpack-demo\n    cd webpack-demo\n    npm init -y\n```\n\n2. 安装相关依赖：\n\n```Shell\n    # webpack 4.0 后需要同时安装 webpack-cli\n    npm install webpack webpack-cli -D\n```\n\n依赖说明：\n\n- webpack: 属于[核心编译工具](https://webpack.docschina.org/)。\n\n- webpack-cli: 由 webpack 抽取出来独立的 **.bin 命令库**，[提供控制台命令](https://webpack.docschina.org/api/cli/)，接收参数，执行构建工作（npx webpack）。\n\n### 配置选项\n\n3. 生成 `webpack` 的配置文件 `webpack.config.js`：\n\n```Shell\n    touch webpack.config.js\n```\n\n<details>\n    <summary>配置文件内容（必须仔细浏览一遍）</summary>\n\n    ```JavaScript\n        // TODO：在这里放上一个完整的 webpack 完整配置文件\n        /** @type {import('webpack'.Configuration)} */\n        const path = require('path');\n        const HtmlWebpackPlugin = require('html-webpack-plugin');\n        const ConsoleLogOnBuildWebpackPlugin = require('./plugin/ConsoleLogOnBuildWebpackPlugin');\n\n        //\n        module.exports = {\n            mode: 'development',\n            entry: './src/index.js',\n            output: {\n                path: path.resolve(__dirname, 'dist'),\n                filename: 'bundle.js',\n            },\n            // Webpack 5 之后引入了 Asset Module 模型，自此我们只需要设置适当的 module.rules.type 配置即可，不需要为多媒体资源专门引入 Loader\n            module: {\n                rules: [{\n                    test: /\\.js$/,\n                    use: [\"babel-loader\"],\n                }, {\n                    test: /\\.less$/i,\n                    include: {\n                        and: [path.join(__dirname, './src/')]\n                    },\n                    use: [\n                        \"style-loader\",\n                        \"css-loader\",\n                        {\n                            loader: \"less-loader\",\n                        },\n                    ],\n                }, {\n                    test: /\\.(png|jpg)$/,\n                    use: [\n                        'file-loader',\n                        {\n                            loader: 'url-loader',\n                            options: {\n                                limit: 1024\n                            }\n                        },\n                        {\n                            loader: 'image-webpack-loader',\n                            options: {\n                            // jpeg 压缩配置\n                            mozjpeg: {\n                                quality: 80\n                            },\n                            }\n                        }\n                    ]\n                }, {\n                    test: /\\.svg$/i,\n                    use: ['raw-loader'],\n                }],\n            },\n            plugins: [\n                new ConsoleLogOnBuildWebpackPlugin(),\n                new HtmlWebpackPlugin({ template: './src/index.html' }),\n            ],\n        }\n    ```\n</details>\n\n> 小技巧：在 vscode 中 `webpack.config.js` 文件开头添加注释 `/**@type {import('webpack'.Configuration)} */`，会被标记为 webpack 配置文件，在输入时会有对应的提示选择项。\n\n### 编写代码\n\n4. 本处使用一个 import 引用的简单例子：\n\n```Shell\n    touch src/index.js\n    touch src/util.js\n```\n\n<details>\n    <summary>src 文件内容</summary>\n\n    ```JavaScript\n        /** ------ src/index.js start ------ */\n        import util from './util';\n\n        util.match();\n        /** ------ src/index.js end ------ */\n\n        /** ------ src/util.js start ------ */\n        export default {\n            match: () => {\n                console.log('match')\n            }\n        }\n        /** ------ src/util.js end ------ */\n    ```\n</details>\n\n### 构建运行\n\n将源代码文件编译构建生成最终产物 `dist/bundle.js`：\n\n```Shell\n    npx webpack\n```\n\nwebpack 自己实现了一套 `import`, 详细分析 `__webpack_require__`(TODO)\n\n<details>\n  <summary>生成的 bundle.js 内容</summary>\n\n  ```JavaScript\n    /******/ (() => { // webpackBootstrap\n    /******/  \"use strict\";\n    /******/  var __webpack_modules__ = ({\n\n    /***/ \"./src/index.js\":\n    /*!**********************!*\\\n    !*** ./src/index.js ***!\n    \\**********************/\n    /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n    eval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util */ \\\"./src/util.js\\\");\\n\\r\\n\\r\\n_util__WEBPACK_IMPORTED_MODULE_0__[\\\"default\\\"].match();\\r\\n\\n\\n//# sourceURL=webpack://webpack-demo/./src/index.js?\");\n\n    /***/ }),\n\n    /***/ \"./src/util.js\":\n    /*!*********************!*\\\n    !*** ./src/util.js ***!\n    \\*********************/\n    /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n    eval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\\n/* harmony export */   \\\"default\\\": () => (__WEBPACK_DEFAULT_EXPORT__)\\n/* harmony export */ });\\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\\r\\n    match: () => {\\r\\n        // console.log('match')\\r\\n        return 'match'\\r\\n    }\\r\\n});\\n\\n//# sourceURL=webpack://webpack-demo/./src/util.js?\");\n\n    /***/ })\n\n    /******/  });\n    /************************************************************************/\n    /******/  // The module cache\n    /******/  var __webpack_module_cache__ = {};\n    /******/\n    /******/  // The require function\n    /******/  function __webpack_require__(moduleId) {\n    /******/   // Check if module is in cache\n    /******/   var cachedModule = __webpack_module_cache__[moduleId];\n    /******/   if (cachedModule !== undefined) {\n    /******/    return cachedModule.exports;\n    /******/   }\n    /******/   // Create a new module (and put it into the cache)\n    /******/   var module = __webpack_module_cache__[moduleId] = {\n    /******/    // no module.id needed\n    /******/    // no module.loaded needed\n    /******/    exports: {}\n    /******/   };\n    /******/\n    /******/   // Execute the module function\n    /******/   __webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n    /******/\n    /******/   // Return the exports of the module\n    /******/   return module.exports;\n    /******/  }\n    /******/\n    /************************************************************************/\n    /******/  /* webpack/runtime/define property getters */\n    /******/  (() => {\n    /******/   // define getter functions for harmony exports\n    /******/   __webpack_require__.d = (exports, definition) => {\n    /******/    for(var key in definition) {\n    /******/     if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n    /******/      Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n    /******/     }\n    /******/    }\n    /******/   };\n    /******/  })();\n    /******/\n    /******/  /* webpack/runtime/hasOwnProperty shorthand */\n    /******/  (() => {\n    /******/   __webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))\n    /******/  })();\n    /******/\n    /******/  /* webpack/runtime/make namespace object */\n    /******/  (() => {\n    /******/   // define __esModule on exports\n    /******/   __webpack_require__.r = (exports) => {\n    /******/    if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n    /******/     Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n    /******/    }\n    /******/    Object.defineProperty(exports, '__esModule', { value: true });\n    /******/   };\n    /******/  })();\n    /******/\n    /************************************************************************/\n    /******/\n    /******/  // startup\n    /******/  // Load entry module and return exports\n    /******/  // This entry module can't be inlined because the eval devtool is used.\n    /******/  var __webpack_exports__ = __webpack_require__(\"./src/index.js\");\n    /******/\n    /******/ })()\n    ;\n    ```\n</details>\n\n基础项目的搭建和内容到此先告一段落，接下来就要开始涉及难懂的核心原理了。\n\n## 原理篇\n\n了解核心原理，首选边调试边查看的方式：\n\n1. 在 `vscode` 编辑器中单独打开项目\n2. 新建 terminal，**再新建 `JavaScript debug terminal`**\n3. 在** `node_modules/webpack/lib/`** 目录的 **`webpack.js`** 和 **`WebpackOptionsApply.js`** 调试位置打上断点\n4. 终端运行 `npx webpack`\n\n### 核心流程图\n\n![核心流程图](/images/web-webpack/webpack-core.png)\n\n### 架构\n\n| 技术名词 | 介绍 |\n| :------ | :------ |\n| Entry | 编译入口，webpack 编译的起点 |\n| Compiler | 编译管理器，webpack 启动后会创建 compiler 对象，**该对象一直存活直到结束退出** |\n| Compilation | 单次编辑过程的管理器，比如 watch = true 时，运行过程中只有一个 compiler，**但每次文件变更触发重新编译时，都会创建一个新的 compilation 对象** |\n| Dependence | 依赖对象，webpack 基于该类型记录模块间依赖关系 |\n| Module | webpack 内部所有资源都会以 module对象形式存在，所有关于资源的操作、转译、合并都是以 module为基本单位进行的 |\n| Chunk | 编译完成准备输出时，webpack 会将module按特定的规则组织成一个一个的 chunk，**这些 chunk 某种程度上跟最终输出一一对应** |\n| Loader | 资源内容转换器，其实就是实现从内容 A 转换 B 的转换器 |\n| Plugin | webpack构建过程中，会在特定的时机广播对应的事件，插件监听这些事件，在特定时间点介入编译过程 |\n\n\n## 核心篇\n\n### loader\n\n介绍：\n\n运行顺序：从右到左\n\n#### 核心原理\n\n#### 常用 loader\n\n| loader | 作用 |\n| :------ | :------: |\n| vue-loader |  |\n| style-loader |  |\n| css-loader |  |\n| scss-loader |  |\n| postcss-loader |  |\n| url-loader |  |\n| babel-loader |  |\n| posthtml-loader |  |\n| ts-loader |  |\n\n#### 编写 loader\n\n### plugin\n\n介绍：\n\n#### 核心原理\n\n关键：tap && call\n\n#### tapable\n\n地址：[tapable](https://github.com/webpack/tapable/)，dd\n\n#### hook\n\n### 常用 plugin\n\n| plugin | 作用 |\n| :------ | :------: |\n| SplitChunksPlugin |  |\n| TextExtractPlugin |  |\n| DllPlugin |  |\n| ImageMinimizerWebpackPlugin |  |\n| TerserWebpackPlugin |  |\n\n### 编写 plugin\n\n## 高级特性\n\n### hmr\n\n### tree-shaking\n\n> 你可以将应用程序想象成一棵树。绿色表示实际用到的 source code(源码) 和 library(库)，是树上活的树叶。灰色表示未引用代码，是秋天树上枯萎的树叶。为了除去死去的树叶，你必须摇动这棵树，使它们落下。\n\n现象：构建时会移除 JavaScript 上下文中的**未引用代码(dead-code)**。\n\n关联插件：`TerserWebpackPlugin`\n\n前提：\n\n* **使用 ES2015 模块语法（即 `import` 和 `export`）**;\n* 在项目的 package.json 文件中，添加 \"sideEffects\" 属性;\n* 需要将 `webpack.config.js` 中的 `mode` 配置选项设置为 `production`。\n\n\n和 `babel-loader` 的关系???\n\n### source-map\n\n`source map` 实质上是一个 **`JSON` 描述文件**，里面存储了代码打包转换后的位置信息，维护了打包前后的代码映射关系。\n\n#### 环境应用\n\n生成环境：`none`\n\n开发环境：`source-map`\n\n#### 配置参考\n\n| 关键字 | 含义 |\n| :------ | :------: |\n| source-map | 生成 sourcemap 文件，可以配置 inline，会以 dataURL 的方式内联，可以配置 hidden，只生成 sourcemap，不和生成的文件关联 |\n| eval | 浏览器 devtool 支持通过 sourceUrl 来把 eval 的内容单独生成文件，还可以进一步通过 sourceMappingUrl 来映射回源码，webpack 利用这个特性来简化了 sourcemap 的处理，可以直接从模块开始映射，不用从 bundle 级别 |\n| cheap | 只映射到源代码的某一行，不精确到列，可以提升 sourcemap 生成速度 |\n| module | sourcemap 生成时会关联每一步 loader 生成的 sourcemap，配合 sourcemap-loader 可以映射回最初的源码 |\n| inline |  |\n| hidden |  |\n| nosources | 不生成 sourceContent 内容，可以减小 sourcemap 文件的大小 |\n\n#### 原理\n\n#### 实战\n\n### code-splitting\n\n\n参考资料：\n\n[1] <a href=\"https://www.webpackjs.com/\">Webpack 官网</a><br>\n[2] <a href=\"https://gitmind.cn/app/docs/m1foeg1o\">Webpack 5 知识体系</a><br>\n[2] <a href=\"https://mp.weixin.qq.com/s/SbJNbSVzSPSKBe2YStn2Zw\">[万字总结] 一文吃透 Webpack 核心原理</a><br>\n\nhttps://mp.weixin.qq.com/s/E26Ll8-VGo4rnGeHdgNAVQ\n","tags":["PROJECT"],"categories":["web"]},{"title":"JS：浅析 Vue","url":"/2019/07/23/js-vue/","content":"\nVue 是一款**渐进式**的 Javascript 框架（Just a view library）。\n\n<!-- more -->\n\n<img src=\"/images/js-vue/vue.png\" alt=\"渐进式框架\" width=\"300\" height=\"300\" align=\"center\" />\n<!-- ![渐进式框架](/images/js-vue/vue.png) -->\n\n***\n\n接下来我们会从**数据响应**、**虚拟 DOM**、**模板编译**三个方面分析 Vue 源码。\n\n#### 数据响应\n\n核心点：**Object.defineProperty** 和 ES6 的 **Proxy**\n\n关键点：**收集依赖**（getter）和**触发依赖**（setter）\n\n源码：*vue/src/core/observer*\n\n##### Object\n\n1 响应式数据（data）\n\nVue 的核心是生成响应式数据，侦测数据的变化，利用 Object.defineProperty 可以侦测到对象的变化。\n\n```Javascript\n// 定义响应式数据\nfunction defineReactive(obj, key, val) {\n    Object.defineProperty(obj, key, {\n        enumerable: true,\n        configurable: true,\n        // important\n        get: function reactiveGetter () {\n            ... // do sth\n            return value\n        },\n        // important\n        set: function reactiveSetter(newVal) {\n            if (newVal === val) {\n                return\n            }\n\n            ... // do sth\n\n            val = newVal\n        }\n    })\n}\n```\n\n2 依赖收集（dep=>内置数组）\n\n观察数据，其目的是当数据的属性发生变化时，可以通知那些曾经使用了该数据的地方。**在 getter 中收集依赖，在 setter 中触发依赖。**\n\n```Javascript\n// 依赖收集\nfunction defineReactive(obj, key, val) {\n    const dep = new Dep() // 新增\n\n    Object.defineProperty(obj, key, {\n        get: function reactiveGetter () {\n            dep.depend() // 新增\n            return value\n        },\n        set: function reactiveSetter(newVal) {\n            if (newVal === val) {\n                return\n            }\n\n            val = newVal\n\n            // 新增\n            dep.notify()\n            // 循环 dep 以触发收集到的依赖\n            for (let i = 0; i < dep.length; i++) {\n                dep[i](newVal, val)\n            }\n        }\n    })\n}\n\n// 存储被收集的依赖\nclass Dep {\n    constructor () {\n        this.subs = []\n    }\n\n    addSub (sub: Watcher) {\n        this.subs.push(sub)\n    }\n\n    removeSub (sub: Watcher) {\n        remove(this.subs, sub)\n    }\n\n    depend () {\n        if (window.target) {\n            window.target.addDep(this)\n        }\n    }\n\n    notify () {\n        for (let i = 0, l = subs.length; i < l; i++) {\n            subs[i].update() // watcher.update\n        }\n    }\n}\n```\n\n3 依赖生成（watcher）\n\n数据相关的依赖是 watcher，被收集在 Dep。\n\n举例子：实现 vm.$watch('a.b. c', function(newVal, oldVal) {})\n\n```Javascript\n// Watcher 可能是模版，也可能是数据\nexport default class Watcher {\n    constructor (vm, expOrFn, cb) {\n        this.vm = vm\n        // 执行 this.getter()，可以读取观察值的内容\n        this.getter = parsePath(expOrFn) // parsePath\n        this.cb = cb\n        this.value = this.get()\n    }\n\n    get () {\n        window.target = this //  this 就是当前 watcher\n        let value = this.getter.call(this.vm, this.vm)\n        window.target = undefined\n        return value\n    }\n\n    update () {\n        const oldValue = this.value\n        this.value = this.get()\n        this.cb.call(this.vm, this.value, this.oldValue) // 触发回调\n    }\n}\n\n// 把 a.b.c 解析成 a[b][c]\nexport function parsePath (path: string): any {\n    if (bailRE.test(path)) {\n        return\n    }\n    const segments = path.split('.')\n    return function (obj) {\n        for (let i = 0; i < segments.length; i++) {\n            if (!obj) return\n            obj = obj[segments[i]]\n        }\n        return obj\n    }\n}\n```\n\n这段代码可以把自己主动添加到 data.a.b.c 的 dep 中。\n\n* new Watcher 的时候，① **constructor** 中的 **get()** 先把 **window.target** 设置成 this（当前 watcher 实例），② 然后调用 **this.getter.call(this.vm, this.vm)** 读取 data.a.b.c 的值时，就会触发对应 Object.defineProperty 的 **getter**。\n* **getter** 里触发了 **dep.depend()**，**depend()** 会把当前 **window.target**(watcher) 作为依赖添加到 dep 中。\n* 依赖 watcher 注入 dep 后，每当数据的值发生变化时，就会让 dep 依赖列表中的所有依赖（watcher）触发 **watcher.update()**。\n\n4 递归侦测 Object（Observer）\n\n前面的代码只能侦测数据中的某一个属性，我们希望能把数据中的所有属性（包括子属性）都侦测到，所以要封装一个 Observer 类。\n\n```JavaScript\nexport class Observer {\n    constructor(value: any) {\n        this.value = value\n\n        if (!Array.isArray(value)) {\n            this.walk(value)\n        }\n    }\n\n    walk (obj: Object) {\n        const keys = Object.keys(obj)\n        for (let i = 0; i < keys.length; i++) {\n            defineReactive(obj, keys[i])\n        }\n    }\n}\n\nfunction defineReactive(obj, key, val) {\n    // 新增 递归子属性\n    if (typeof val === 'object') {\n        new Observer(val) // 递归循环 defineReactive\n    }\n\n    Object.defineProperty(obj, key, {\n        ...\n    })\n}\n```\n\n5 总结图解\n\n![数据响应](/images/js-vue/data.png)\n\n* Data 通过 Observer 转换成了 gettter/setter 的形式来追踪变化。\n* 当外界通过 Watcher 读取数据时，会触发 getter 从而把 watcher 添加到依赖 dep 中。\n* 当数据发生了变化，会触发 setter，从而向 dep 中的依赖（watcher）发送通知。\n* watcher 接受到通知后，会通知外界，触发 update()，更新视图或触发回调。\n\n##### Array\n\n6 侦测 Array 的变化\n\n侦测 Array 的方式和 Object 的不同，需要拦截覆盖 Array.prototype 的原生方法。\n\n源码：*vue/src/core/observer/array.js*\n\n* 创建了变量 arrayMethods，用来覆盖 Array.prototype。\n\n```Javascript\nconst arrayProto = Array.prototype\nexport const arrayMethods = Object.create(arrayProto)\n\n;[\n  'push',\n  'pop',\n  'shift',\n  'unshift',\n  'splice',\n  'sort',\n  'reverse'\n].forEach(function (method) {\n  // 缓存原生方法\n  const original = arrayProto[method]\n  Object.defineProperty(arrayMethods, method, {\n    value: function mutator (...args) {\n        const ob = this.__ob__\n        let inserted\n        switch (method) {\n            case 'push':\n            case 'unshift':\n                inserted = args\n                break\n            case 'splice':\n                inserted = args.slice(2)\n                break\n        }\n        if (inserted) ob.observeArray(inserted)\n        // notify change\n        ob.dep.notify() // 触发依赖\n\n        return original.apply(this, args) // 调用原生方法\n    })\n})\n```\n\n* 再通过 Observer 生成响应式数组时，拦截器只会覆盖响应式数组的原型。\n\n```Javascript\nexport class Observer {\n    constructor (value: any) {\n        // 新增\n        this.dep = new Dep()\n\n        if (Array.isArray(value)) {\n            if (hasProto) {\n                protoAugment(value, arrayMethods)\n            } else {\n                copyAugment(value, arrayMethods, arrayKeys)\n            }\n        } else {\n            this.walk(value)\n        }\n    }\n}\n\n/**\n * Augment a target Object or Array by intercepting\n * the prototype chain using __proto__\n */\nfunction protoAugment (target, src: Object) {\n  /* eslint-disable no-proto */\n  target.__proto__ = src\n  /* eslint-enable no-proto */\n}\n\n/**\n * 直接暴力把 prototype 原生方法赋予属性 key-value\n */\nfunction copyAugment (target: Object, src: Object, keys: Array<string>) {\n  for (let i = 0, l = keys.length; i < l; i++) {\n    const key = keys[i]\n    def(target, key, src[key])\n  }\n}\n```\n\n* *Array 在 getter 中收集依赖，在拦截器中触发依赖。*\n\n* 依赖 dep 必须在 getter 和拦截器中都可以访问到，所以 Array 的依赖列表存在了  Observer 中，不是 defineReactive 里，此时 dep 在 getter 和拦截器中都可以访问到。\n\n##### $watch\n\n7 vm.$watch 的内部原理  \n\n* 执行 new Watcher 来实现 vm.$watch 的基本功能。\n\n```Javascript\nVue.prototype.$watch = function (\n    expOrFn: string | Function,\n    cb: any,\n    options?: Object\n): Function {\n    const vm: Component = this\n\n    // 关键\n    const watcher = new Watcher(vm, expOrFn, cb, options)\n\n    if (options.immediate) {\n        cb.call(vm, watcher.value)\n    }\n    return function unwatchFn () {\n        watcher.teardown()\n    }\n  }\n}\n```\n\n* **expOrFn** 是支持函数的，Watcher 会同时观察 **expOrFn** 函数中读取的所有 Vue.js 实例的**响应式数据**。 计算属性（**computed**）的实现原理与其有很大的关系，函数中的所有响应式数据的 dep 都会添加这个 watcher，一旦其中的某个数据发生变化，dep 都会通知 watcher 更新。\n\n```Javascript\nexport default class Watcher {\n    constructor (\n    vm: Component,\n    expOrFn: string | Function,\n    cb: Function,\n    options?: ?Object,\n    isRenderWatcher?: boolean\n) {\n    this.vm = vm\n\n    // 新增\n    if (typeof expOrFn === 'function') {\n        this.getter = expOrFn\n    } else {\n        this.getter = parsePath(expOrFn)\n    }\n\n    this.value = this.lazy\n      ? undefined\n      : this.get()\n  }\n}\n```\n\n* Watcher 中添加 addDep 方法，会记录自己都订阅过哪些依赖 dep，同时也会把watcher 添加到 dep 中。\n\n```Javascript\nexport default class Watcher {\n    constructor (\n        vm: Component,\n        expOrFn: string | Function,\n        cb: Function,\n        options?: ?Object,\n        isRenderWatcher?: boolean\n    ) {\n        this.vm = vm\n        this.deps = [] // 新增\n        this.depIds = new Set() // 新增\n        ...\n        this.value = this.lazy\n        ? undefined\n        : this.get()\n    }\n\n    // 记录 dep，同时把自己添加到 dep 中\n    addDep (dep: Dep) {\n        const id = dep.id\n        // 核心，双向绑定数据\n        if (!this.deps.has(id)) {\n            this.depIds.add(id)\n            this.deps.push(dep)\n            dep.addSub(this)\n        }\n  }\n}\n\nexport default class Dep {\n    depend () {\n        if (window.target) {\n            window.target.addDep(this) // 新增 window.target === watcher\n        }\n    }\n}\n```\n\nWatcher 和 Dep 的关系图：多对多\n\n![数据响应](/images/js-vue/watcher.png)\n\n举个例子：\n\n```Javascript\n    this.$watch(function me() {\n        return this.name + this.age\n    }, function(newVal, oldVal) {\n        console.log(newVal, oldVal)\n    })\n```\n\n观察的表达式是一个函数，函数中访问了 name 和 age 两个数据，这种情况下触发 name 和 age getter 的 **dep** 都会收集当前 **watcher** 实例，当前 **watcher** 也会记录 name 和 age 的 **dep**，这导致 name 和 age 中的任意一个数据发生变化（setter）时，**watcher** 都会收到通知。\n\n#### 虚拟DOM\n\n在 Vue 中，我们使用模板（template）来描述状态（data status）与 DOM 之间的映射关系。Vue 通过编译将模板转换成渲染函数（render），执行渲染函数就可以得到一个虚拟节点树（Vnode），使用这个虚拟节点树就可以渲染页面。\n\n模板转换成视图的过程：\n\n![虚拟 DOM](/images/js-vue/vnode.png)\n\n为了避免不必要的 DOM 操作，虚拟 DOM 在虚拟节点映射到视图的过程中，将虚拟节点与上一次渲染视图所使用的旧虚拟节点（oldVnode）作对比，找出真正需要更新的节点来进行 DOM 操作。\n\n虚拟 DOM 的执行流程：\n\n![patch](/images/js-vue/patch.png)\n\n##### VNode\n\n核心：VNode 本质就是一个节点(DOM)描述(JS)对象。\n\n源码：*vue/src/core/vdom/vnode.js*\n\n① Vue 中存在一个 VNode 类，使用它可以实例化不同类型的 vnode 实例，而不同类型的 vnode 实例各自表示不同类型的 DOM 元素。\n\n```Javascript\nexport default class VNode {\n  constructor (\n    tag?: string,\n    data?: VNodeData,\n    children?: ?Array<VNode>,\n    text?: string,\n    elm?: Node,\n    context?: Component,\n    componentOptions?: VNodeComponentOptions,\n    asyncFactory?: Function\n  ) {\n    this.tag = tag\n    this.data = data\n    this.children = children\n    this.text = text\n    this.elm = elm\n    this.ns = undefined\n    this.context = context\n    this.fnContext = undefined\n    this.fnOptions = undefined\n    this.fnScopeId = undefined\n    this.key = data && data.key\n    this.componentOptions = componentOptions\n    this.componentInstance = undefined\n    this.parent = undefined\n    this.raw = false\n    this.isStatic = false\n    this.isRootInsert = true\n    this.isComment = false\n    this.isCloned = false\n    this.isOnce = false\n    this.asyncFactory = asyncFactory\n    this.asyncMeta = undefined\n    this.isAsyncPlaceholder = false\n  }\n\n  get child (): Component | void {\n    return this.componentInstance\n  }\n}\n```\n\n② VNode 类型\n\n* 注释节点：createEmptyVNode(text)\n* 文本节点：createTextVNode(val)\n* 元素节点：createElement\n* 组件节点: createComponent\n* 函数式组件：createFunctionalComponent\n* 克隆节点：cloneVNode(vnode)\n\n##### Patch\n\n源码：*vue/src/core/vdom/patch.js*\n\n虚拟 DOM 最核心的部分是 patch，它可以将 Vnode 渲染成真实的 DOM。\n\npatch 对现有 DOM 进行修改需要做三件事：\n\n* 创建新增的节点（① document.createElement ② parentNode.appendChild）\n* 删除已经废弃的节点\n* 修改需要更新的节点\n\n**patch：当 oldVNode 不存在时，直接使用 vnode 渲染视图；当 oldVNode 和 vnode 都存在但不是同一个节点时，使用 vnode 创建的 DOM 元素替换旧的 DOM 元素；当 oldVnode 和 vnode 是同一个节点时，使用更详细的对比操作（diff）对真实的 DOM 节点进行更新。**\n\n具体的规则待续...\n\n#### 模版编译\n\n源码：*vue/src/core/compiler*\n\n**渲染函数是创建 HTML 最原始的方法。模板最终会通过编译转换成渲染函数，渲染函数执行后，会得到一份 vnode 用于虚拟 DOM 渲染。**\n\n![patch](/images/js-vue/render.png)\n\n模板编译成渲染函数可以分两个步骤：\n\n1. 先将模板解析成 AST（抽象语法树）\n2. 然后再使用 AST 生成渲染函数\n\n具体的模板编译分三部分内容：\n\n1. 将模板解析为 AST\n2. 遍历 AST 标记为静态节点\n3. 使用 AST 生成渲染函数\n\n这三部分内容又可以抽象为三个模块来实现各自的动能：\n\n1. 解析器：（HTML 解析器，文本解析器，过滤器解析器）\n2. 优化器：（遍历 AST，检测出所有的静态子树）\n3. 代码生成器 （生成代码字符串）\n\n模板编译的整体流程：\n\n![patch](/images/js-vue/render-part.png)\n\n##### 解析器\n\n源码：*vue/src/core/compiler/parser*\n\n解析器要实现的功能是将模板解析成 AST。\n\n* HTML 解析器（html-parser）\n* 文本解析器（text-parser）\n* 过滤器解析器（filter-parser）\n\n```Html\n<!--  模板 -->\n<div>\n    <p>{{name}}</p>\n</div>\n```\n\n```Javascript\n// AST\n{\n    tag: \"div\",\n    type: 1,\n    staticRoot: false,\n    static: false,\n    plain: true,\n    parent: undefined,\n    attrList: [],\n    attrsMap: {},\n    children: [\n        {\n            tag: \"p\",\n            type: 1,\n            staticRoot: false,\n            static: false,\n            plain: true,\n            parent: {tag: \"div\", ...},\n            attrList: [],\n            attrsMap: {},\n            children: [{\n                type: 2,\n                text: \"{{name}}\"\n                static: false,\n                expression: \"_s(name)\"\n            }]\n        }\n    ]\n}\n```\n\n##### 优化器\n\n源码：*vue/src/core/compiler/optimizer*\n\n优化器的作用是在 AST 中找出静态子树打上标记。\n\n标记静态子树的好处：\n\n* 每次重新渲染时，不需要为静态子树创建新节点\n* 在虚拟 DOM 中打补丁（patching）的过程可以跳过\n\nAST 新增 static（静态节点） 和 staticRoot（静态根节点） 两个属性：\n\n```Javascript\nexport function optimize (root: ?ASTElement, options: CompilerOptions) {\n    if (!root) return\n    ...\n    // first pass: mark all non-static nodes.\n    markStatic(root)\n    // second pass: mark static roots.\n    markStaticRoots(root, false)\n}\n```\n\n##### 代码生成器\n\n源码：*vue/src/core/compiler/codegen*\n\n代码生成器就是通过 AST 生成代码字符串。\n\n代码字符串格式如下：\n\n```Javascript\n‘with(this){return _c(\"div\", {attrs:{\"id\":\"el\"}}, [_v(\"hello \"+_s(name))])}’\n```\n\n钩子生成函数：\n\n```Javascript\n// _c\nexport function genElement (el: ASTElement, state: CodegenState): string {\n    let data\n    if (!el.plain || (el.pre && state.maybeComponent(el))) {\n        data = genData(el, state)\n    }\n\n    const children = el.inlineTemplate ? null : genChildren(el, state, true)\n    code = `_c('${el.tag}'${\n        data ? `,${data}` : '' // data\n    }${\n        children ? `,${children}` : '' // children\n    })`\n}\n\n// _v\nexport function genText (text: ASTText | ASTExpression): string {\n  return `_v(${text.type === 2\n    ? text.expression // no need for () because already wrapped in _s()\n    : transformSpecialNewlines(JSON.stringify(text.text))\n  })`\n}\n\n// _e\nexport function genComment (comment: ASTText): string {\n  return `_e(${JSON.stringify(comment.text)})`\n}\n```\n\n#### 挂载真实 DOM\n\n_update\n\n#### 全局篇\n\n![patch](/images/js-vue/new-vue.png)\n\n参考文章：\n\n[深入浅出 Vue.js-刘博文](.)\n","tags":["JavaScript"],"categories":["web"]},{"title":"WEB：浏览器渲染机制","url":"/2019/07/06/web-render/","content":"\n在不同浏览器下代码渲染的结果会存在一定的差异性，造成差异性的原因是**浏览器内核**的不同，浏览器内核决定了浏览器解释网页语法的方式。\n\n<!-- more -->\n\n而浏览器内核可以分为两部分：JS 引擎和**渲染引擎**（Layout Enfine 或 Rendering Engine）。\n\n本文主要介绍渲染引擎，渲染引擎包括了 `HTML 解释器`、`CSS 解释器`、布局、网络、存储、图形、音视频、图片解码器等等零部件。\n\n各浏览器对应的渲染引擎：\n\n* IE：Trident\n* Firefox：Gecko\n* Chrome & Safari：**Webkit**\n\n***\n\n### 渲染过程\n\n本文接下来会介绍 `webkit` 渲染引擎的渲染过程。\n\n渲染过程：渲染引擎根据 HTML 文件描述构建响应的数学模型，调用浏览器各个零部件，从而将网页资源代码转换为图像结果：\n\n![渲染过程](/images/web-render/render.png)\n\n浏览器呈现网页的渲染过程，是由内核内部的功能模块相互配合协同工作进行的，我们需要关注以下几大功能模块：\n\n* `HTML 解释器`：将 HTML 文档经过词法分析输出 `DOM` 树。\n* `CSS 解释器`：解析 CSS 文档，生成样式规则，输出 `CSSOM` 树。\n* `图层布局计算模块`：布局计算每个对象的精确位置和大小。\n* `视图绘制模块`：进行具体节点的图像绘制，将像素渲染到屏幕上。\n* `JavaScript 引擎`：编译执行 Javascript 代码。\n\n每个页面的**首次渲染**都经历如下阶段：\n\n![渲染过程解析](/images/web-render/parse.png)\n\n* **解析 HTML**\n\n在这一步浏览器执行了所有的加载解析逻辑，在解析 HTML 的过程中发出了页面渲染所需的各种外部资源请求。\n\n* **计算样式**\n\n浏览器将识别并加载所有的 CSS 样式信息与 DOM 树合并，最终生成页面 render 树（:after :before 这样的伪元素会在这个环节被构建到 DOM 树中）。\n\n* **计算图层布局**\n\n页面中所有元素的相对位置信息，大小等信息均在这一步得到计算。\n\n* **绘制图层**\n\n在这一步中浏览器会根据我们的 DOM 代码结果，把每一个页面图层转换为像素，并对所有的媒体文件进行解码。\n\n* **整合图层，得到页面**\n\n最后一步浏览器会合并合各个图层，将数据由 CPU 输出给 GPU 最终绘制在屏幕上。（复杂的视图层会给这个阶段的 GPU 计算带来一些压力，在实际应用中为了优化动画性能，我们有时会手动区分不同的图层）。\n\n![渲染过程解析](/images/web-render/tree.png)\n\n**总结**：\n\n基于上述流程，其实渲染过程就是： ① 首先基于 HTML 构建一个 DOM 树，② DOM 树与 CSS 解释器解析出的 CSSOM 相结合，③ 得到布局渲染树 Render Tree。④ 最后浏览器以布局渲染树（Layout）为蓝本，去计算布局并绘制（Paint）图像。\n\n**之后每当一个新元素加入到这个 DOM 树当中，浏览器便会通过 CSS 引擎查遍 CSS 样式表，找到符合该元素的样式规则应用到这个元素上，然后再重新去绘制它。**\n\n***\n\n### CSS 优化\n\n明白了浏览器的渲染过程后，就可以基于渲染流程对 CSS 做优化了。\n\n前置知识：**CSS 选择符是从右到左进行匹配的**。\n\n性能提升方案：\n\n* 避免使用通配符 `* {}`，只对需要用到的元素进行选择。\n* 少用标签选择器，尽量用类选择器替代。\n* 减少嵌套，后代选择器的开销是最高的。\n\n### 加载优化\n\nHTML、CSS 和 JS，都具有**阻塞渲染**的特性。因此，需要优化 CSS 和 JS 的加载顺序：\n\n* CSS：将 `css` 放在 `head` 标签里（尽早）和启用 `CDN` 实现静态资源加载速度的优化（尽快）\n* JS：给 `script` 标签添加 `async` / `defer` 标签\n\n### DOM 优化\n\n#### 减少 DOM 操作\n\n> 把 DOM 和 Javascript 各自想象成一个岛屿，它们之间用收费桥梁连接。\n\nJS 引擎和渲染引擎是**独立实现**的，当我们用 JS 去操作 DOM 时，本质上是 JS 引擎和渲染引擎之间进行了「`跨界交流`」。这跨界交流的实现依赖了桥接接口作为“桥梁”。\n\n![操作 DOM](/images/web-render/dom.png)\n\n每次操作 DOM （修改或是访问），都需要过桥收桥费。因此需要**减少操作 DOM**。（DOM Fragment）\n\n#### 减少 DOM 修改\n\n上述仅仅是「过桥」，过完桥，假如继续操作（修改 DOM），也是慢动作。\n\n一旦对 DOM 进行修改，会引发外观（样式）上的改变时，就会触发**回流**或**重绘**，本质上是对 DOM 修改触发了渲染树（Render Tree）的变化所导致的：\n\n![操作 DOM](/images/web-render/render-tree.png)\n\n* 回流：当我们对 DOM 的修改引发了 DOM 几何尺寸的变化（比如修改元素的宽、高或隐藏元素等）时，浏览器需要重新计算元素的几何属性（其他元素的几何属性和位置也会因此受到影响），然后再将计算的结果绘制出来。这个过程就是回流（也叫重排）。\n\n* 重绘：当我们对 DOM 的修改导致了样式的变化、却并未影响其几何属性（比如修改了颜色或背景色）时，浏览器不需重新计算元素的几何属性、直接为该元素绘制新的样式（跳过了上图所示的回流环节）。这个过程叫做重绘。\n\n总结：**重绘不一定导致回流，回流一定会导致重绘**。尽可能减少 DOM 修改。\n\n### 异步更新\n\n详见 Vue 异步更新策略。\n\n### 回流与重绘\n\n关于回流与重绘，可以回顾下 DOM 优化时的描述。\n\n避免回流和重绘的发生，最直接的做法就是**避免掉可能会引发回流与重绘的 DOM 操作**，首先找出可能会触发它们的**导火索**：\n\n* 重绘：修改 `background`、`color`、`visibility` 等样式属性。\n* 回流：① 修改 `width`、`height`、`padding`、`margin`、`left`、`top`、`border` 等几何属性。② 改变 DOM 树的结构：增删、移动节点。③ 获取一定特定属性的值：`offsetWidth`、`scrollWidth`、`clientWidth` 等，会触发**即时计算**。\n\n建议：\n\n* Transtion 动画：优先选择 `transform`，尽量不使用 height，width，padding，margin。\n* 使用 `visibility` 替换 `display: none` ，因为前者只会引起重绘，后者会引发回流（改变了布局）。\n* 不要把节点的属性值放在一个循环里当成循环里的变量。\n* 不要使用 `table` 布局，可能很小的一个小改动会造成整个 table 的重新布局。\n* 动画实现的速度的选择，动画速度越快，回流次数越多，也可以选择使用 `requestAnimationFrame`。\n* CSS 选择符从右往左匹配查找，避免节点层级过多。\n* 将频繁重绘或者回流的节点设置为图层，图层能够阻止该节点的渲染行为影响别的节点。比如对于 `video` 标签来说，浏览器会自动将该节点变为图层。`will-change` 属性和 `video`、`iframe` 标签都可以把节点为图层\n\n参考文章：\n\n[前端性能优化原理与实践](https://juejin.im/book/5b936540f265da0a9624b04b/section/5b936540f265da0aec223b5d)\n\n[浏览器渲染原理](https://juejin.im/book/5bdc715fe51d454e755f75ef/section/5bdc7207f265da613c09425d)\n"},{"title":"WEB：Event Loop 的样子","url":"/2019/06/13/event-loop/","content":"\nJS 是单线程的，异步编程已经是前端不可或缺的重要部分，Event Loop 执行顺序也是考核的一部分。\n\n<!-- more -->\n\n### Promise\n\nPromise 是异步编程的一种解决方案，Promise 对象代表一个异步操作。\n\n#### Promise 对象的特点\n\n1. 存在三种状态，且状态不受外界影响：\n\n* pending（进行中）：等待态\n* fulfilled（已成功）：执行态\n* rejected（已失败）：拒绝态\n\n2. 一旦状态改变，之后状态就不会再变，任何时候都可以得到这个结果。只要从 pending 转化为 fulfilled 或 rejected 其中一种，状态就凝固了， 不会再变了。\n\n#### Promise 的基本用法\n\n```JavaScript\n// Promise 是一个构造函数\n// resolve 和 reject 是两个函数参数，由 Javascript 引擎提供\nnew Promise((resolve, reject)=> {\n    const image = new Image()\n\n    image.onload = ()=> {\n        resolve(image)\n    }\n\n    image.onerror = ()=> {\n        reject(new Error(`Could not load image at ${url}`))\n    }\n\n    image.src = url\n}).then(res=> {\n    throw new Error('I am in purpose')\n}).catch(err=> {\n\n}).finally(()=> {\n    // 可以用作关闭加载弹框\n    wx.hideLoading()\n})\n```\n\n注意点：\n\n* Promise 在 new 后就会立即执行, then 会在 Promise 函数里的所有同步操作执行完后才执行。\n* Promise 状态改变为 resolved 后，再抛出错误是无效的。\n* Promise 内部的错误不会影响到外部的代码。\n\n其他方法：\n\n```JavaScript\n// 封装多个 Promise，返回所有 Promise 结果\nPromise.all([p1, p2, p3]).then(res=> {})\n\n// 首个改变状态的 Promise 会改变所有的状态\nPromise.race([p1, p2, p3]).then(res=> {})\n\n// 返回状态为 resolve 的 promise 对象\nPromise.resolve(res)\n\n// 返回状态为 reject 的 promise 对象\nPromise.reject(err)\n```\n\n训练题：**手写 Promise**\n\n```JavaScript\n// 简易版\nconst PENDING = 'pending'\nconst RESOLVED = 'resolved'\nconst REJECTED = 'rejected'\n\nfunction MyPromise(fn) {\n    const that = this\n    that.state = PENDING\n    that.value = null\n    that.resolvedCallbacks = []\n    that.rejectedCallbacks = []\n    // 待完善 resolve 和 reject 函数\n    function resolve(value) {\n        if (value instanceof MyPromise) {\n            return value.then(resolve, reject)\n        }\n        setTimeout(()=> {\n            if (that.state === PENDING) {\n                that.state = RESOLVED\n                that.value = value\n                that.resolvedCallbacks.map(cb => cb(that.value))\n            }\n        }, 0)\n    }\n\n    function reject(value) {\n        setTimeout(()=> {\n            if (that.state === PENDING) {\n                that.state = REJECTED\n                that.value = value\n                that.rejectedCallbacks.map(cb => cb(that.value))\n            }\n        }, 0)\n    }\n    // 待完善执行 fn 函数\n    try {\n        fn(resolve, reject)\n    } catch (e) {\n        reject(e)\n    }\n}\n\n// TODO: better\nMyPromise.prototype.then = function(onFulfilled, onRejected) {\n    const that = this\n    onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : v => v\n    onRejected =\n    typeof onRejected === 'function'\n        ? onRejected\n        : r => {\n            throw r\n        }\n    if (that.state === PENDING) {\n        that.resolvedCallbacks.push(onFulfilled)\n        that.rejectedCallbacks.push(onRejected)\n    }\n    if (that.state === RESOLVED) {\n        onFulfilled(that.value)\n    }\n    if (that.state === REJECTED) {\n        onRejected(that.value)\n    }\n}\n```\n\n### generator\n\nGenerator （生成器）函数是一个状态机，封装了多个内部状态，会返回遍历器对象。\n\n* function 关键字与函数名之间有个星号 *\n* 函数内部使用 yield 产出表达式标记\n* next() 遍历状态，惰性求值\n\n小插曲：有限状态机（statemachine）\n\n1. 状态总数（state）是有限的\n2. 任一时刻，只处于一种状态之中\n3. 某种条件下，会从一种状态转变另一种\n\n```JavaScript\n    function * happyDating() {\n        yield 'zeus';\n        yield 'dione';\n        return 'dating';\n    }\n\n    const hw = happyDating()\n\n    hw.next() // { value: 'zeus', done: false }\n    hw.next() // { value: 'dione', done: false }\n    hw.next() // { value: 'dating', done: true }\n    hw.next() // { value: undefined, done: true }\n```\n\n### async await\n\nAsync 函数是 Generator 函数的语法糖， async 相当于 *，await 相当于 yield。\n\n```JavaScript\n    async function haveDating() {\n        const isFull = await haveDinner()\n        const isHappy = await watchMovie()\n\n        return {\n            isFull,\n            isHappy\n        }\n    }\n\n    haveDating().then(res=> {\n        console.log('I love u')\n    })\n```\n\nasync 函数的实现原理，就是将 Generator 函数和自动执行器，包装在一个函数里。\n\n```JavaScript\n    async function fn(args) {\n\n    }\n\n    // 等同于\n\n    function fn(args) {\n        return spawn(function * () {\n\n        })\n    }\n```\n\n### Event loop\n\n执行 JS 代码是往执行栈（callback stack）中放入函数，一旦遇到异步代码，就把异步代码挂起并在需要执行的时候加入到 Task 队列中。一旦执行栈为空，**Event Loop** 就会从 Task 队列中拿出需要执行的代码并放入执行栈中执行。\n\nTask 任务源分为 微任务（microtask）和宏任务（macrotask），ES6中，microtask 称为 jobs，macrotask 称为 task。\n\n题目测试：\n\n```JavaScript\n    console.log('script start')\n\n    async function async1() {\n        await async2()\n        console.log('async1 end')\n    }\n\n    async function async2() {\n        console.log('async2 end')\n    }\n    async1()\n\n    setTimeout(function() {\n        console.log('setTimeout')\n    }, 0)\n\n    new Promise(resolve => {\n        console.log('Promise')\n        resolve()\n    })\n    .then(function() {\n        console.log('promise1')\n    })\n    .then(function() {\n        console.log('promise2')\n    })\n\n    console.log('script end')\n    // script start => async2 end => Promise => script end => promise1 => promise2 => async1 end => setTimeout\n\n```\n\nEvent Loop 执行顺序如下所示：\n\n* 首先执行同步代码，这属于宏任务\n* 当执行完所有同步代码后，执行栈为空，查询是否有异步代码需要执行\n* 执行所有微任务\n* 当执行完所有微任务后，如有必要会渲染页面\n* 然后开始下一轮 Event Loop，执行宏任务中的异步代码，也就是 setTimeout 中的回调函数\n\n微任务包括 [`process.nextTick`](https://nodejs.dev/understanding-process-nexttick/) ，`promise` ，[`MutationObserver`](https://developer.mozilla.org/zh-CN/docs/Web/API/MutationObserver)，其中 process.nextTick 为 Node 独有。\n\n宏任务包括 `script` ， `setTimeout` `，setInterval` ，`setImmediate` ，`I/O` ，`UI rendering`。\n"},{"title":"WEB：躲不了的前端跨域","url":"/2019/06/12/web-cors/","content":"\n> 同源策略限制了从同一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的重要安全机制。\n\n引用自 MDN <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy\">浏览器的同源策略</a>。\n<!-- more -->\n\n### 跨域概述\n\n基于浏览器安全考虑，浏览器实行了__跨域安全策略（同源策略）__，保证用户信息的安全，防止恶意的网站窃取数据，因而会限制了不同域之间的资源共享。\n\n#### 同源策略(same-origin policy)\n\n如果 A 与 B 网页不同源，B 网页不能直接访问 A 网页的资源。\n\n同源的定义（三要素须同时相同）：\n\n1. 协议相同（https | http）\n2. 域名相同（zeus.com | zeus.cn）\n3. 端口相同（80 | 8080）\n\n非同源的限制：\n\n1. Cookie、LocalStorage 和 IndexDB 无法读取。\n2. DOM 无法获得。\n3. AJAX 请求不能发送。\n\n### 跨域解决方案\n\n* 图像 Ping\n\n通过使用 <img\\> 标签的 src 属性发出请求加载图像。动态创建图像 Image，可以使用 onload 和 onerror 来确定是否接收到了相应。（也常用于跟踪用户点击页面或动态广告曝光次数，__无痕埋点应用__）\n\n```JavaScript\n    const img = new Image()\n\n    img.onload = img.onerror = () => {\n        console.log('Done')\n    }\n\n    // 传递 name 等 query 参数\n    img.src = 'https://zeuscoder.github.io/2019/06/12/web-cors/?name=zeus'\n```\n\n缺点：\n\n1. 只能发送 GET 请求\n2. 无法访问服务端的响应文本\n\n* JSONP(JSON with padding)\n\nJSONP 利用 <script\\> 标签的 src 属性指定跨域 URL。JSONP 由回调函数和数据两部分组成：<font color=\"#0000dd\">callback({name: 'zesu'})</font>\n\n```JavaScript\n    // 前端\n    function handleResponse(response) {\n        console.log(response)\n    }\n\n    const script = document.createElement('script')\n\n    script.src = 'https://zeuscoder.github.io/2019/06/12/web-cors/?callback=handleResponse'\n    document.boby.insertBefore(script, document.body.firstChild)\n\n    // 服务端返回数据，由于在 script 标签访问，返回数据会直接作为代码运行\n    handleResponse({name: 'zesu'})\n```\n\n不足：\n\n1. 跨域加载代码运行，需要确保该域安全，否则会在响应中夹杂恶意代码，此时只能完全放弃 JSONP 调用。\n2. 不能确认 JSONP 请求是否失败，script 标签的 onerror 未得到浏览器支持。\n\n* CORS(Cross-origin resource sharing)\n\n预检请求（）\n\n* 代理服务器\n\n* document.domain\n\n* postMessage\n\n参考文章：\n\n[1] <a href=\"http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html\">浏览器同源政策及其规避方法</a><br>\n[2] <a href=\"https://segmentfault.com/a/1190000012469713#articleHeader9\">ajax跨域，这应该是最全的解决方案了</a><br>\n[3] <a href=\"https://zhuanlan.zhihu.com/p/27290218\">3分钟弄明白顶级域名|二级域名|子域名|父域名的区别</a><br>\n[4] <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy\">浏览器的同源策略</a>\n","categories":["web"]},{"title":"WEB：浅谈前端模块化","url":"/2019/06/09/web-module/","content":"\n前端模块化设计，其目的和组件化相似，是为了提高代码复用性和维护性。\n\n<!-- more -->\n\n### 模块化设计\n\n模块化设计（Modular Design）的历史进程主要有以下方式：\n\n1. IIFE\n2. CommonJS\n3. AMD & CMD\n4. ES6 Module\n\n#### IIFE\n\nIIFE：立即执行的匿名函数，不会污染全局变量。\n\n```JavaScript\n    (function() {\n        const name = 'zeus'\n        const age = 26\n\n        console.log('try your best')\n    })()\n```\n\n#### CommonJS\n\nCommonJs：模块即对象，运行时加载，只有在允许时才能加载对象。\n\n```JavaScript\n    // 导出模块\n    exports.name = 'zeus'\n\n    // 等同于\n    module.exports = {\n        name: 'zeus'\n    }\n\n    // 引入模块\n    require('person')\n```\n\nCommonJS 依赖于 Node.js 的环境变量 module exports reqiure global，仅适用于 Node.js 的规范。\n\n#### AMD && CMD\n\nAMD（Asynchronous Module Definition）：异步的模块管理。<br>\n具体实现： Requirejs\n\n```JavaScript\n    requirejs(['person'], function() {\n        // 加载完 person 模块后使用\n        person.run()\n    })\n\n    // 依赖其他模块定义自己的模块\n    define(['./car', './house'], function(car, house) {\n        console.log(house.price)\n        car.drive()\n        return {\n            name: 'zeus',\n            age: 26,\n            car,\n            house\n        }\n    })\n```\n\nCMD（Common Module Definition）：优化的 AMD，崇依赖就近 + 延迟执行。<br>\n具体实现：Seajs\n\n```JavaScript\n    define(function(car, house) {\n        if (***) {\n            require('house')\n            console.log(house.price)\n        }\n\n        if (***) {\n            require('car')\n            car.drive()\n        }\n\n        return {\n            name: 'zeus',\n            age: 26,\n            car,\n            house\n        }\n    })\n```\n\nAMD 和 CMD 只适用浏览器的规范。\n\n#### ES6 Module\n\nES6 Module: 浏览器和服务器通用的模块化解决方案。\n\n* 与 CommonJS相似，对循环依赖以及单个 exports 的支持。\n* 与 AMD 相似，直接支持异步加载和可配置模块加载。\n* 结构可以静态分析。\n* script 标签加载：\\<script type=\"module\">\\</script>\n\n```JavaScript\n    export const name = 'zeus'\n    export default {\n        name,\n        age: 26\n    }\n\n    // 如果多次重复执行同一句import语句，那么只会执行一次，而不会执行多次。\n    // 因此不同的脚本加载同个模块，得到的是同一个实例。（重点）\n    // 按需加载使用 import()，返回 Promise 对象。\n    // import * as Zeus from 'person'\n    import Zeus from 'person'\n```\n\n*注意*：不同的脚本加载同个模块，得到的是同一个实例。\n\n### 模块加载差异\n\n比较 ES6 Module 与 CommonJS 的差异。\n\n#### 导出值\n\nCommonJS：运行时加载，导出的是值的拷贝。\n\n```JavaScript\n    // person.js\n    const name = 'zeus'\n    let age = 26\n    function grow() {\n        age++\n    }\n\n    module.exports = {\n        age,\n        grow\n    };\n\n    // main.js\n    const Zeus = require('./person')\n    consle.log(Zeus.age) // 26\n    // 内部方法改变了 age，age 是原始类型的值，引用后会被缓存，因此值不变\n    Zeus.grow()\n    consle.log(Zeus.age) // 26\n```\n\nES6 Module：编译时输出接口，导出的是值的引用，实时绑定。\n\n```JavaScript\n    // person.js\n    const name = 'zeus'\n    let age = 26\n    function grow() {\n        age++\n    }\n\n    export default {\n        age,\n        grow\n    };\n\n    // main.js\n    import Zeus from './person'\n    consle.log(Zeus.age) // 26\n    // import 只是对值的引用，动态地去被加载的模块取值\n    Zeus.grow()\n    consle.log(Zeus.age) // 27\n```\n\n#### 循环加载\n\n循环加载：a 脚本的执行依赖 b 脚本，而 b 脚本的执行又依赖 a 脚本。\n\nCommonJS 的加载原理：CommonJS 模块无论加载多少次，都只会在第一次加载时运行一次，以后再加载，就返回第一次运行的结果，除非手动清除系统缓存。\n\nCommonJS 的循环加载：一旦出现某个模块被\"循环加载\"，就只输出已经执行的部分，还未执行的部分不会输出。\n\n```JavaScript\n    // a.js\n    // 引用 b.js，等待 b.js 执行完毕。\n    exports.done = false\n    var b = require('./b.js')\n    console.log('在 a.js 之中，b.done = %j', b.done)\n    exports.done = true\n    console.log('a.js 执行完毕')\n\n    // b.js\n    // 此时 a.js 只 执行到 exports.done = false\n    // 只输出已执行的部分，a.done = false\n    exports.done = false\n    var a = require('./a.js')\n    console.log('在 b.js 之中，a.done = %j', a.done)\n    exports.done = true\n    console.log('b.js 执行完毕')\n\n    // main.js\n    // 加载 a.js 时也加载了 b.js，输出了两个模块的日志\n    var a = require('./a.js')\n    // 谨记：此时加载 b.js 没有再次输出日志，说明没有再次加载 b.js，只是输出缓存 b.js 的执行结果\n    var b = require('./b.js')\n    console.log('在 main.js 之中, a.done=%j, b.done=%j', a.done, b.done)\n\n    $ node main.js\n\n    在 b.js 之中，a.done = false\n    b.js 执行完毕\n    在 a.js 之中，b.done = true\n    a.js 执行完毕\n    在 main.js 之中, a.done=true, b.done=true\n```\n\nES6 Module 的循环加载：先默认 import 的引用存在，使用时再获取对应的值。\n\n```JavaScript\n    // even.js\n    import { odd } from './odd'\n    export let counter = 0\n    export function even(n) {\n        counter++;\n        return n === 0 || odd(n - 1)\n    }\n\n    // odd.js\n    import { even } from './even'\n    export function odd(n) {\n        return n !== 0 && even(n - 1)\n    }\n\n    $ babel-node\n    > import * as m from './even.js'\n    > m.even(10)\n    true\n    > m.counter\n    6\n    > m.even(20)\n    true\n    > m.counter\n    17\n```\n\n### 扩展\n\nUMD(Universal Module Definition)：提供一个前后端跨平台的解决方案(支持AMD与CommonJS模块方式)。\n\nUMD的实现：\n\n1. 先判断是否支持Node.js模块格式（exports是否存在），存在则使用Node.js模块格式。\n2. 再判断是否支持AMD（define是否存在），存在则使用AMD方式加载模块。\n3. 前两个都不存在，则将模块公开到全局（window或global）。\n\n```JavaScript\n    // if the module has no dependencies, the above pattern can be simplified to\n    (function (root, factory) {\n        if (typeof define === 'function' && define.amd) {\n            // AMD. Register as an anonymous module.\n            define([], factory);\n        } else if (typeof exports === 'object') {\n            // Node. Does not work with strict CommonJS, but\n            // only CommonJS-like environments that support module.exports,\n            // like Node.\n            module.exports = factory();\n        } else {\n            // Browser globals (root is window)\n            root.returnExports = factory();\n    }\n    }(this, function () {\n\n        // Just return a value to define the module export.\n        // This example returns an object, but the module\n        // can return a function as the exported value.\n        return {};\n    }));\n```\n\n参考文章：\n\n[1] <a href=\"https://mp.weixin.qq.com/s/a_mI5w5bCxrvHrhogRkKVQ\">从 IIFE 聊到 Babel 带你深入了解前端模块化发展体系</a>\n\n[2] <a href=\"http://es6.ruanyifeng.com/#docs/module-loader\">Module 的加载实现</a>\n","tags":["WEB"],"categories":["web"]},{"title":"JS：简述原型与原型链","url":"/2019/06/02/js-prototype/","content":"\n搞懂**原型（prototype）和原型链**，从 *JavaScript 面向对象的程序设计* 思想开始可能会比较容易入手。\n<!-- more -->\n\n1. 了解原型和原型链的概念（What）\n2. 使用原型和原型链的方式（How）\n3. 明白原型和原型链的用处（Why）\n\n### 浓缩版知识点\n\n* **原型（prototype）是函数（Function）的一个属性（property）**，*原型（prototype）的值是对象（object instance）*，原型实际就是对象内存地址指针（pointer），重写原型相当于改变对象内存地址指针的指向。\n  \n```JavaScript\n// 构造函数\nfunction Person() {\n    this.name = 'zeus'\n}\n\n// 修改原型对象的值，原型默认的构造函数指向自己\n// Person.prototype.construcor = Person\nPerson.prototype.age = 26\n\n// 修改原型对象的指针，同时修改原型默认的构造函数\n// Person.prototype.construcor = Object\nPerson.prototype = {\n    age: 26\n}\n```\n\n* **原型**：① prototype【函数属性】② \\__proto__【实例属性，可直接访问】③ [[prototype]]【实例内部属性，不可直接访问】\n\n```JavaScript\n// 构造函数\nfunction Person() {\n    this.name = 'zeus'\n}\n\n// 实例\nconst person = new Person()\n\n// 实例的构造函数\nperson.constructor === Person\n\n// 全文最关键的地方\n// 原型 Object.getPrototypeOf(person) 相当于访问 person[[prototype]]\nperson.__proto__ === person.constructor.prototype ==== Person.prototype ==== Object.getPrototypeOf(person)\n```\n\n* **原型链**就是构造函数（Function）的原型（prototype）指向（=）另一个实例化对象（instance），形成了原型链。\n\n```JavaScript\n    function Super() {\n        this.property = true\n    }\n\n    function Sub() {\n        this.subProperty = false\n    }\n\n    // 父类的实例化对象\n    const super = new Super()\n\n    // 子类的原型指向父类的实例化对象\n    Sub.prototype = super\n\n    const sub = new Sub()\n\n    // 可以引用查找父类实例的属性\n    sub.property === true\n```\n\n* **原型和原型链**相关的函数\n\n```JavaScript\n    // 获取实例的原型对象，相当于访问 instance[[prototype]]\n    Object.getPrototypeOf(instance)\n\n    // 定义对象的属性值，Vue 的知识点之一\n    Object.defineProperty(instance, property, propertyDesc)\n\n    // 根据返回的描述符数组值区分数据属性还是访问器属性\n    Object.getOwnPropertyDescriptor(instance, property)\n```\n\n### 详解版知识点\n\n> * 只要创建一个新函数（Function），就会根据一组特定的规则为该函数创建一个 prototype 属性，这个属性指向函数的原型对象（object）。<br>\n> * 原型对象会默认自动获得 constructor (构造函数) 属性，这个属性包含一个指向 prototype 属性所在函数（Function）的指针。<br>\n> * Person.prototype.constructor === Person\n\n注意：ECMAScript 没有类的概念\n\n#### 理解对象\n\n对象有两种**属性类型**：数据属性和访问器属性。\n\n<table>\n    <tr>\n        <td>数据属性</td>\n        <td>访问器属性</td>\n        <td>描述符解释</td>\n    </tr>\n    <tr>\n        <td>[[configurable]]</td>\n        <td>[[configurable]]</td>\n        <td>能否通过 delete 删除属性，默认值 true</td>\n    </tr>\n    <tr>\n        <td>[[Enumberable]]</td>\n        <td>[[Enumberable]]</td>\n        <td>能否通过 for-in 访问属性，默认值 true</td>\n    </tr>\n    <tr>\n        <td>[[Writable]]</td>\n        <td>[[get]]</td>\n        <td>\n            ① [Writable]] 能否修改属性的值，默认值 true<br>\n            ② [[get]] 读取属性时调用的函数，默认值 undeined\n        </td>\n    </tr>\n    <tr>\n        <td>[[value]]</td>\n        <td>[[set]]</td>\n        <td>\n            ① [[value]] 包含这个属性的数据值，默认值 undeined<br>\n            ② [[set]] 写入属性时调用的函数，默认值 undeined\n        </td>\n    </tr>\n</table>\n\n① 数据属性：通过 this.*** 直接定义；\n\n② 访问器属性：必须通过 Object.defineProperty() 定义。\n\n区分：通过 Object.getOwnPropertyDescriptor(instance, property) 来区分。\n\n定义：必须使用 Object.defineProperty(instance, property, propertyDesc) 来修改默认属性。\n\n> Object.defineProperty，getter， setter 是 Vue 框架要点之一。\n\n#### 创建对象\n\n1. 工厂模式\n\n```JavaScript\n    // 工厂模式，根据接受参数调用函数，返回相似的对象，但是无法识别对象的类型\n    function createPerson(name) {\n        const o = new Object()\n        o.name = name\n        return o\n    }\n\n    const zeus = createPerson('zeus')\n    const boss = createPerson('boss')\n```\n\n2. 构造函数模式\n\n```JavaScript\n    // 自定义构造函数，创建特定类型的对象，自定义对象类型的属性和方法\n    function Person(name) {\n        this.name = name\n    }\n\n    // new 操作符的流程：\n    // 1. 创建一个对象\n    // 2. this指向这个对象\n    // 3. 指向函数的代码\n    // 4. 返回这个对象\n    const zeus = new Person('zeus')\n    const boss = new Person('boss')\n\n    // person instanceof Person === true\n    // person.constructor === Person\n```\n\n用 instanceof 检测对象类型，比 constructor(构造函数) 检测靠谱。\n\n3. **原型模式（文章重点）**\n\n关键字： **共享**\n\n```JavaScript\n    function Person() {\n    }\n\n    Person.prototype.name = 'zeus'\n    Person.prototype.friends = ['dione', 'chloe']\n    Person.prototype.sayName = function() {\n        console.log(this.name)\n    }\n\n    // 所有实例共享原型模式定义的属性和方法\n    const zeus = new Person()\n    const boss = new Person()\n\n    // 缺点：一旦原型属性值是对象或者数组，一个实例更改了，另外一个实例也会跟着一起改变。\n    zeus.friends.push('atom')\n\n    zeus.friends === ['dione', 'chloe', 'atom']\n    boss.friends === ['dione', 'chloe', 'atom']\n```\n\n> * 只要创建一个新函数（Function），就会根据一组特定的规则为该函数创建一个 prototype 属性，这个属性指向函数的原型对象（object）。<br>\n> * 原型对象会默认自动获得 constructor (构造函数) 属性，这个属性包含一个指向 prototype 属性所在函数的指针。<br>\n> * Person.prototype.constructor === Person\n\n![prototype](https://cloud-minapp-11144.cloud.ifanrusercontent.com/1hYBRP8Cwpq1G7ZK.png)\n\n代码读取对象的属性时，搜索顺序：对象本身的属性 -> 原型对象的属性；对象本身的属性会屏蔽原型对象的同名属性，而不是删除，一旦在对象属性搜索到目标属性的话，就不会往下搜索了。还有对象实例可以访问到原型中的值，却不能通过对象实例重写原型中的值。<br>\n可以通过 instance.hasOwnProperty(propertyName) 来判断是否是对象属性。\n*注意：person 的 [[prototype]] 内部属性不能直接访问，可以通过 Object.getPrototypeof(person) 访问。*\n\n4. 组合使用构造函数模式和原型模式（广泛使用的默认模式）\n\n```JavaScript\n    function Person(name) {\n        this.name= name\n        this.friends = ['dione', 'chloe']\n    }\n\n    Person.prototype.sayName = function() {\n        console.log(this.name)\n    }\n\n    const zeus = new Person('zeus')\n    const boss = new Person('dione')\n\n    zeus.friends.push('atom')\n\n    zeus.friends === ['dione', 'chloe', 'atom']\n    boss.friends === ['dione', 'chloe']\n```\n\n5. 动态原型模式\n\n```JavaScript\n    // 想把原型声明封装在构造函数里面\n    function Person(name) {\n        this.name= name\n        this.friends = ['dione', 'chloe']\n\n        if (typeof this.sayname === 'function') {\n            Person.prototype.sayName = function() {\n                console.log(this.name)\n            }\n\n            // 可以继续定义其他原型方法\n            Person.prototype.dating = function() {\n                console.log('I love u')\n            }\n        }\n    }\n\n    const zeus = new Person('zeus')\n    const boss = new Person('dione')\n\n    zeus.friends.push('atom')\n\n    zeus.friends === ['dione', 'chloe', 'atom']\n    boss.friends === ['dione', 'chloe']\n```\n\n#### 继承\n\n面向对象有两种继承方式：接口继承和实现继承。ECMAScript 只支持实现继承，其实现继承主要依靠**原型链**来实现的。\n\n1. **原型链（文章重点）**\n\n继承的基本思想：利用原型（桥梁中介）让一个引用类型（子类）继承另一个引用类型（父类）的属性和方法。<br>\n继承的本质：重写覆盖引用类型的原型对象（prototype）。<br>\n继承的缺点：1. 会共享对象值的属性 2. 不能向超类型的构造函数传递参数\n\n```JavaScript\n    function Super() {\n        this.property = true\n    }\n\n    Super.prototype.getVal = function() {\n        console,log(this.property)\n    }\n\n    function Sub() {\n        this.subProperty = false\n    }\n\n    // 原型指向父类对象，继承了 Super\n    Sub.prototype = new Super()\n\n    Sub.prototype.getSubVal = function() {\n        console,log(this.subProperty)\n    }\n\n    const instance = new Sub()\n\n    instance.getVal() // getVal 是 Super 的原型方法\n\n    // 所有的引用类型都继承了 Object\n```\n\n2. 借用构造函数（经典继承）\n\n```JavaScript\n    function Super(name) {\n        this.name = name\n        this.friends = ['dione', 'chloe']\n    }\n\n    Super.prototype.dating = function() {\n        console.log('I love u')\n    }\n\n    function Sub(name, age) {\n        // 借调（call 或 apply）了超类型的构造函数，继承了 Super 的属性和方法（Super 中的 this 指向为 Sub）\n        Super.call(this, name)\n        this.age = age\n    }\n\n    const zeus = new Sub('zeus', 26)\n    const boss = new Sub('boss', 25)\n\n    zeus.friends.push('atom')\n\n    zeus.friends === ['dione', 'chloe', 'atom']\n    boss.friends === ['dione', 'chloe']\n\n    // 每次创建对象，都会声明所有新的属性和方法，无法函数复用\n```\n\n3. 组合继承（伪经典继承，常用模式）\n\n原理：使用**原型链**实现对原型（prototype）属性和方法的继承，借用**构造函数**实现对实例（instance）属性的继承。\n\n```JavaScript\n    function Super(name) {\n        this.name = name\n        this.friends = ['dione', 'chloe']\n    }\n\n    Super.prototype.dating = function() {\n        console.log('I love u')\n    }\n\n    function Sub(name, age) {\n        // 继承属性\n        Super.call(this, name)\n        this.age = age\n    }\n\n    // 继承方法\n    Sub.prototype = new Super()\n    Sub.prototype.sayAge = function() {\n        console.log(this.age)\n    }\n\n    const zeus = new Sub('zeus', 26)\n    const boss = new Sub('boss', 25)\n\n    zeus.friends.push('atom')\n\n    zeus.friends === ['dione', 'chloe', 'atom']\n    boss.friends === ['dione', 'chloe']\n\n    // happy dating\n    zeus.dating === boss.dating\n```\n\n#### 扩展点\n\n1. new\n\n* 创建一个空对象，这个对象将作为执行 new 构造函数（）之后，之后返回的对象实例\n* 将上面创建的空对象的原型（__proto__），指向构造函数的 prototype 属性\n* 将上面创建的空对象赋值给构造函数内部的 this，并执行构造函数逻辑\n* 根据构造函数执行逻辑，返回第一步创建的对象或者构造函数的显式返回值\n\n2. Object.create\n\n```JavaScript\n    // Object.create 是继承中的原型式继承模式的规范写法\n    // 以一个对象作为基础，创建一个新对象\n    function create(o) {\n        function F() {}\n        F.prototype = 0\n        return new F()\n    }\n\n    create == Object.create\n```\n\n3. Class(ES6)\n\nClass 只是语法糖，其语法与 JAVA 类的语法相似，更像面向对象编程。（JS 越来越像 JAVA 了）\n\n```JavaScript\n    // ES6 的 class\n    class Person {\n        constructor(name) {\n            this.name = name\n        }\n\n        dating() {\n            console.log('I love u')\n        }\n    }\n\n    // typeof Person === 'function'，Person 实际上就是构造函数\n    // Person.prototype.constructor === Person\n    // class 的 methods 都是定义在 class 的 prototype 上\n```\n\n* super: 调用父类的方法，this 指向子类或子类对象。\n* static：类的静态方法。\n* extends：类的继承。\n* #： 私有属性。\n* new.target: new 的声明对象。\n\n4. 手写 call、apply 和 bind 函数\n\n两个关键点：\n\n* 不传入第一个参数，那么上下文默认为 window\n* 改变了 this 指向，让新的对象可以执行该函数，并能接受参数\n\ncall 函数\n\ncall() 方法使用一个指定的 this 值和单独给出的一个或多个参数来调用一个函数。\n\n```JavaScript\n    Function.prototype.mycall = function(context) {\n        if (typeof this !== 'function') {\n            throw new TypeError('Error')\n        }\n\n        // 指定为 null 和 undefined 的 context 值会自动指向全局对象\n        context = context || window\n        context.fn = this\n\n        const args = [...arguments].slice(1)\n        const result = context.fn(...args)\n\n        delete context.fn\n        return result\n    }\n\n    // 实现分析\n    // 首先 context 为可选参数，如果不传的话默认上下文为 window\n    // 接下来给 context 创建一个 fn 属性，并将值设置为需要调用的函数\n    // 因为 call 可以传入多个参数作为调用函数的参数，所以需要将参数剥离出来\n    // 然后调用函数并将对象上的函数删除\n    // KEY：本质就是用传入的对象调用这个函数\n```\n\napply 函数\n\napply() 方法调用一个具有给定this值的函数，以及作为一个数组（或类似数组对象）提供的参数。\n\n```JavaScript\n    Function.prototype.mycall = function(context) {\n        if (typeof this !== 'function') {\n            throw new TypeError('Error')\n        }\n\n        // 指定为 null 和 undefined 的 context 值会自动指向全局对象\n        context = context || window\n        context.fn = this\n\n        let result\n        // 处理参数和 call 有区别\n        if (arguments[1]) {\n            result = context.fn(...arguments[1])\n        } else {\n            result = context.fn()\n        }\n\n        delete context.fn\n        return result\n    }\n```\n\nbind 函数\n\nbind()方法创建一个新的函数，在调用时设置this关键字为提供的值。并在调用新函数时，将给定参数列表作为原函数的参数序列的前若干项。\n\n```JavaScript\n    Function.prototype.mybind = function(context) {\n        if (typeof this !== 'function') {\n            throw new TypeError('Error')\n        }\n\n        const _this = this\n        const args = [...arguments].slice(1)\n  \n        // 返回一个函数\n        return function F() {\n            // 因为返回了一个函数，我们可以 new F()，所以需要判断\n            if (this instanceof F) {\n                return new _this(...args, ...arguments)\n            }\n\n            return _this.apply(context, args.concat(...arguments))\n        }\n    }\n\n    // bind 返回了一个函数，对于函数来说有两种方式调用，一种是直接调用，一种是通过 new 的方式，\n    // 对于直接调用来说，这里选择了 apply 的方式实现，但是对于参数需要注意以下情况：因为 bind 可以实现类似这样的代码 f.bind(obj, 1)(2)，所以我们需要将两边的参数拼接起来，于是就有了这样的实现 args.concat(...arguments)\n    // 最后来说通过 new 的方式，在之前的章节中我们学习过如何判断 this，对于 new 的情况来说，不会被任何方式改变 this，所以对于这种情况我们需要忽略传入的 this\n```\n\n### 小结\n\n参考文章：\n\n《Javascript高级程序设计》第六章：面向对象的程序设计 P138-P172\n\n<a href=\"https://juejin.im/book/5bdc715fe51d454e755f75ef/section/5bdd0d8e6fb9a04a044073fe\">手写 call、apply 及 bind 函数</a>\n","tags":["JavaScript"],"categories":["web"]},{"title":"JS：倒计时","url":"/2018/05/01/web-countdown/","content":"\n实现一个简单的倒计时显示。\n\n<!-- more -->\n\n### 倒计时设计\n\n#### 基础版\n\n倒计时一般使用定时器 ___setInterval___ 函数，以 1000 毫秒（1 秒）为单位，定时更新倒计时剩余时间。\n\n```JavaScript\n  var seconds = 600   // 10 分钟\n  function secondsCounter(timer) {\n    var counterInterval = setInterval(function() {\n      var seconds = timer - 1\n      if (seconds <= 0) {\n        clearInterval(counterInterval)\n      }\n      showTimer(seconds)\n    }, 1000)\n  }\n```\n\n#### 准确版\n\n由于 ___setInterval___ 函数实际的延迟时间会长一点，所以每次在设置剩余时间可以通过 Date 对象，设备时间相对是准确的。\n\n#### 安全版\n\n服务器时间\n\n### 倒计时显示\n\n关于倒计时的显示，采取以秒为单位，一分钟 = 60 秒，转换成 xx:xx 的显示形式。(注：显示逻辑要与倒计时解耦)\n\n```JavaScript\n  function showTimer(timer) {\n    var minutes = formatTime(Math.floor(timer / 60))\n    var seconds = formatTime(timer % 60)\n    return minutes + ':' + seconds\n  }\n\n  function formatTime(time) {\n    return time < 10 ? '0' + time : time\n  }\n```\n","tags":["JavaScript"],"categories":["web"]},{"title":"HTTP：HTTP缓存的那些事","url":"/2017/06/30/http-cache/","content":"\n> 重用已经获取的资源能够有效的提升网站与应用的性能。Web 缓存能够减少延迟与网络阻塞，进而减少显示某个资源所用的时间。借助 HTTP 缓存，Web 站点变得更具有响应性。\n\n引用自 [MDN](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Caching_FAQ) 的一段话。\n<!-- more -->\n\n***\n\n划重点：1.0 的 `Expires`、1.1 的 `Cache-Control` 和协商缓存的两对`[Etag, If-None-Match]`、`[Last-Modified, If-Modified-Since]`\n\n***\n\n## HTTP缓存\n\n缓存：① 是指**代理服务器（from http）** 或 **客户端本地磁盘（from memory）** 内保存的资源副本（拷贝），并在下次请求该资源时提供该资源副本的__技术__。② 当 web 缓存发现请求的资源已经被存储，它会拦截请求，返回该资源的拷贝，而不会去源服务器重新下载。\n\n作用：利用缓存可减少对源服务器的访问，因此节省了通信流量和通信时间。\n\n那问题来了：\n\n+ 缓存的目标是什么?\n+ 缓存的方法有哪些？\n\n## HTTP报文\n\n小插曲：在下一步介绍HTTP缓存之前，先做一下知识铺垫，简单介绍下HTTP报文。\n\n### 报文概念\n\nHTTP报文就是浏览器和服务器间通信时发送及响应的数据块。\n\n### 报文分类\n\n浏览器向服务器请求数据，发送请求（request）报文；\n\n服务器向浏览器返回数据，返回响应（response）报文。\n\n### 报文构成\n\n报文信息主要分为两部分：\n\n1 Header：包含属性的__首部__，附加信息（cookie，缓存信息）与缓存相关的规则信息，均包含在header中。\n\n2 Body：包含数据的__主体__，HTTP请求真正想要传输的部分。\n\n小总结：缓存的内容是主体，缓存的方法在首部。\n\n## 缓存操作的目标\n\n常见的HTTP缓存只能存储GET响应，缓存的关键主要包括 request method 和目标URI。\n\n普遍的缓存案例：\n\n+ 一个检索请求的成功响应: 状态码：200，一个包含例如HTML文档，图片，或者文件的响应\n+ 不变的重定向: 响应状态码：301\n+ 错误响应: 响应状态码：404 的一个页面\n+ 不完全的响应: 响应状态码 206，只返回局部的信息\n+ 除了 GET 请求外，如果匹配到作为一个已被定义的cache键名的响应\n\n## 缓存策略分类\n\n在讲述如何控制缓存之前，先看看缓存策略大致有哪些类型。在已存在缓存数据的前提下，根据是否需要重新向服务器发起请求分类，这里主要分为__强制缓存__和__对比缓存__两大类。\n\n### 强制缓存\n\n强制缓存：如果缓存生效，则不需要再与服务器发生交互。\n\n![cache-force](/images/http-cache/cache-force.png)\n\n### 对比缓存\n\n对比缓存：不管缓存是否生效，都需要与服务端发生交互。\n\n![cache-compair](/images/http-cache/cache-compair.png)\n\n服务端在进行标识比较后，只返回header部分，通过状态码告知客户端使用缓存，不需要将报文主体部分返回客户端。\n\n小总结：两类缓存规则可以同时存在，强制缓存优先级高于对比缓存，也就是说，当执行强制缓存的规则时，如果缓存生效，直接使用缓存，不再执行对比缓存规则。\n\n## 缓存控制策略\n\n关键词：`Cache-Control` `Last-Modified|If-Modified-Since` `Etag|If-None-Match`\n\n### Cache-Control头\n\nHTTP/1.1定义的 Cache-Control 头用来区分对缓存机制的支持情况，请求头和响应头都支持这个属性。通过它提供的不同的值来定义缓存策略。\n\n<span style=\"color: red\">注意：在__请求__和__响应__报文的首部都支持 Cache-Control ，要学会区分 Cache-Control 的缓存策略是定义在请求还是响应。</span>\n\n![cache-control-request](/images/http-cache/cache-control-request.png)\n\n![cache-control-response](/images/http-cache/cache-control-response.png)\n\n#### 控制可执行缓存的对象的指令\n\n##### no-store指令（请求&响应）\n\n```Javascript\nCache-Control：no-store\n```\n\n完全不支持缓存，所有内容不得缓存。一旦开启，强制缓存和对比缓存都不会生效。\n\n#### 表示是否能缓存的指令\n\n##### public指令（响应）\n\n```Javascript\nCache-Control：public\n```\n\n响应可以被任何请求来源缓存，客户端和服务器都可缓存。\n\n##### private指令（响应）\n\n```Javascript\nCache-Control：private\n```\n\n响应只能被唯一的用户缓存，客户端可以缓存。\n\n##### no-cache指令（请求&响应）---对比缓存\n\n```Javascript\nCache-Control：no-cache\n```\n\n在释放缓存服务器的缓存内容前向服务端源地址发送请求以验证缓存是否有效。使用 no-cache 指令的目的是为了防止从缓存中返回过期的资源。\n\n请求包含 no-cache：客户端将不会接收缓存过的响应，过程参照对比缓存。\n响应包含 no-cache：缓存服务器不能对资源进行缓存。\n\n#### 指定缓存期限和认证的指令\n\n##### max-age指令（请求&响应）---响应Date\n\n```Javascript\nCache-Control: max-age=604800 // 一周\n```\n\n请求包含 max-age：缓存资源的缓存时间 < max-age指定时间 ? 直接获取缓存资源 : 缓存服务器将请求转发给服务器。\n响应包含 max-age：响应的 must-revalidate 和 Expires 将失效，max-age指定时间 = 资源缓存的期限。一旦超过时间，资源将从缓存服务器移除。\n\n##### min-fresh指令（请求）\n\n```Javascript\nCache-Control: min-fresh=60 // 一分钟\n```\n\nmin-fresh指令：缓存资源的能缓存剩余时间(新鲜度) > min-fresh指定时间 ? 直接获取缓存资源 : 缓存服务器将请求转发给服务器。\n\n##### max-stale指令（请求）\n\n```Javascript\nCache-Control: max-stale=60 // 一分钟\n```\n\nmax-stale指令：缓存资源的过期时间 < max-stale指定时间 ? 直接获取缓存资源 : 缓存服务器将请求转发给服务器。\n\n##### only-if-cached指令（请求）\n\n```Javascript\nCache-Control: only-if-cached\n```\n\nonly-if-cached指令：客户端仅在缓存服务器本地缓存目标资源的情况下才会要求返回。即缓存服务器有缓存就直接拿缓存，没缓存就访问源服务器。\n\n##### must-revalidate指令（响应）---对比缓存\n\n```Javascript\nCache-Control：must-revalidate\n```\n\nmust-revalidate指令：代理会向源服务器再次验证即将返回的响应缓存目前是否仍然有效。同时会忽略请求的max-stale指令。\n\n##### no-transform指令（请求&响应）\n\n```Javascript\nCache-Control: no-transform\n```\n\nno-transform指令：缓存都不能改变实体主体的媒体类型，防止缓存或代理压缩图片等类似操作。\n\n### 对比缓存\n\n#### Last-Modified（响应）| If-Modified-Since（请求）\n\n1. Last-Modified：服务器在响应请求时，告诉浏览器资源的最后修改时间。\n2. If-Modified-Since：上一次请求资源的修改时间。\n3. Last-Modified > If-Modified-Since ? 200重新访问资源 : 304使用缓存资源\n\n#### Etag（响应）| If-None-Match（请求）\n\n1. Etag：服务器响应请求时，告诉浏览器当前资源在服务器的唯一标识（生成规则由服务器决定）。\n2. If-None-Match：再次请求服务器时，通过此字段通知服务器客户段缓存数据的唯一标识。\n3. Etag === If-None-Match ? 304使用缓存资源 : 200重新访问资源\n\n**缓存优先级**：`Cache-Control` > `Expires` > `ETag` > `Last-Modified`\n\n## 缓存决策指南\n\n源自于 Chrome 官方给出的缓存决策建议：\n\n![cache-order](/images/http-cache/cache-order.png)\n\n+ 当资源内容不可以复用时，直接设置 `Cache-Control` 为 `no-store`，拒绝一切形式的缓存\n+ 假如每次都需要向服务器进行缓存有效确认时，设置 `Cache-Control` 为 `no-cache`\n+ 考虑是否可以被代理服务器缓存，是的话设置为 `public`，否的话则设置为 `private`\n+ 然后考虑资源的过期时间：配置 `max-age` 、`Etag`、`Last-Modified` 等参数\n\n参考文章：\n\n[MDN HTTP缓存](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Caching_FAQ)\n\n[图解HTTP](https://book.douban.com/subject/25863515/)\n\n[彻底弄懂HTTP缓存机制及原理](http://www.cnblogs.com/chenqf/p/6386163.html)\n\n[彻底弄懂 HTTP 缓存机制](http://www.tuicool.com/articles/zUZnUre)\n\n掌握 HTTP 缓存——从请求到响应过程的一切（上）\n\n掌握 HTTP 缓存——从请求到响应过程的一切（下）\n","tags":["HTTP"],"categories":["web"]},{"title":"WEB：我所理解的REST","url":"/2017/06/11/web-rest/","content":"\nREST：REpresentational State Transfer，表现层状态转换，是浏览器和服务器通信方式的一种__设计风格__。\n <!-- more -->\n\n### 概念\n\n表现层状态转换 = 表现层 + 状态转换。<br>\n表现层：其实指的就是“__资源__”的具体表现形式<br>\n状态转换：“__资源__”操作（动词）\n\n### 核心\n\n核心概念：__资源__（REST 以资源为核心展开）\n\n+ 互联网所有可以访问的内容，都是__资源__\n+ 服务器保存__资源__，客户端请求__资源__\n+ 同一个__资源__，有多种表现形式\n+ 协议本身不带有状态，通信时客户端必须通过参数表示请求不同状态的__资源__\n+ 状态转换通过 HTTP 动词表示\n\n### 设计\n\nURL 是__资源__的唯一标识符。<br>\nURL 定位资源，用 HTTP 动词（GET, POST，PUT， DELETE）描述操作。<br>\nURL 只使用__名词__来指定资源，原则上不使用动词。\n\n![boxModel](/images/web-rest/rest-transfer.png)\n\n### RESTful\n\nRESTful架构：符合 REST 风格的设计\n","categories":["web"]},{"title":"CSS：Position Float Clear属性略解","url":"/2017/06/07/css-position/","content":"\n在<a> CSS：Normal Flow 标准流布局 </a>一文中提及：想要让一个元素脱离标准的文档流，方法是让该元素成为定位元素或浮动元素。其相关 css 属性就是 position 和 float 属性，另外 clear 属性则可以清除之前浮动元素对该元素的影响。\n <!-- more -->  \n\n本文将介绍 position & float & clear 属性及其之间的联系：  \n1 [Position](#position)  \n2 [Float](#float)  \n3 [Float && Position](#floatAndPosition)  \n4 [Clear](#clear)\n\n## <span id=\"position\">Position</span>\n\n定位的整个想法是允许我们覆盖标准的文档流行为，以产生特殊的效果。position 属性的作用就是可以指定元素遵循特定类型的定位活动，而可以不处于标准流中。\n\n```CSS\n.element {\n  position: static | relative | absolute | fixed; /* 默认为static */\n}\n```\n\n### 静态定位 static\n\n静态定位是每个元素 position 属性的默认值，它只是意味着“将元素放入它在文档布局流中的正常位置”，也就是处于标准文档流中，不会有特殊行为，也没什么特别意义。\n\n```CSS\n.element {\n  position: static;\n}\n```\n\n### 相对定位 relative\n\n相对定位与静态定位相似，元素先放置在未添加定位时的位置，不同的是可以相对于其正常位置进行定位，修改其最终位置，包括使其与页面上的其他元素重叠。\n\n```CSS\n.element {\n  position: relative;\n  top: 10px; bottom: 20px; left: 30px; right: 40px; /* 可选 */\n}\n```\n\n辅助属性：top | bottom | left | right  \n用于设置元素与其正常位置四周的距离，可以为负值。\n\n### 绝对定位 absolute\n\n不为元素在布局中预留空间位置，通过指定元素__相对于最近的非 static 定位祖先元素__的偏移，来确定元素位置。绝对定位的元素可以设置外边距（margin），且不会与其他边距合并，也就是不会出现外边距塌陷（margin-collapsing）的情况。\n\n```CSS\n.element {\n  position: absolute;\n  top: 10px; bottom: 20px; left: 30px; right: 40px; /* 可选 */\n}\n```\n\n> 定位上下文：最近的非 static 定位祖先元素。\n\n那么，如果其祖先元素都为 static 元素又怎么定位呢？\n\n### 固定定位 fixed\n\nfixed 和 absolute 相似：\n1 使元素脱离正常文档流，不占据布局空间；  \n2 默认会覆盖在非定位元素上；\n区别是 absolute 的“根元素”是可以被设置的，而 fixed 则其“根元素”固定为__浏览器窗口(viewport)__ ，当滚动网页时，其元素与浏览器窗口之间的位置距离是恒定不变的。\n\n```CSS\n.element {\n  position: fixed;\n}\n```\n\n小插曲：z-index属性用于指定元素重叠时的显示位置，值越大，显示就在越上层。\n> 其实使元素脱离正常文档流的属性值只有 absolute | fixed，static | relative 元素仍处于正常文档流中。\n\n## <span id=\"float\">Float</span>\n\n要么向左，要么向右，要么正常。\n\n```CSS\n.element {\n  float: left | right | none; /* 默认为none */\n}\n```\n\n> 浮动元素是 float 属性值不是 none 的元素。\n\n+ 只有横向浮动，没有纵向浮动\n+ 设置 float 属性后，将脱离标准流，其容器元素将得不到脱离标准流的子元素高度。\n+ 会让元素的 display 属性变更为 block\n+ 浮动元素的后一个元素会围绕浮动元素（典型：文字围绕图片）\n+ 浮动元素的前一个元素不会收到任何影响\n\n## <span id=\"floatAndPosition\">Float && Position</span>\n\n当 float 遇上 position，又会有什么意想不到的火花呢？\n\n### float & position: relative\n\n元素同时应用了 position：relative 和 float 属性后，元素先会浮动到相应的位置，再根据 top | bottom | left | right 所设置的距离发生偏移。\n> 先浮动后定位\n\n### float & position：absolute\n\n元素同时应用了 position：absolute 和 float 属性后，__则 float 属性会失效__。\n\n### float vs position\n\n前面的元素应用了 position 之后会覆盖接下来应用  float 的元素（假如两个元素位置发生了重叠）.\n> 如果你不将 float 的元素的 position 设置成 relative 的话，你想通过设置 float 元素的 z-index 来的达到覆盖 position:absolute 是无效的。同理， float 元素下面存在 position: absolute 的子元素，如果你不将 float 的元素的 position 设置成 relative 的话，absolute 元素是不会定位到 float 元素的。\n\n## <span id=\"clear\">Clear</span>\n\nclear 属性指定一个元素是否可以在它之前的浮动元素旁边，或者必须向下移动（清除浮动）在它下面。\n\n```CSS\n.element {\n  clear: none | left | right | both; /* 默认为none */\n}\n```\n\nnone: 元素不会向下移动清除之前的浮动。  \nleft: 元素被向下移动用于清除之前的左浮动。  \nright: 元素被向下移动用于清除之前的右浮动。  \nboth: 元素被向下移动用于清除之前的左右浮动。\n> 总结：设置 clear 属性只是设置自身会不会受前面的浮动元素的影响，而不会影响其他元素的布局。如果需要清除浮动，一般设置 clear：both 就解决问题了。\n","tags":["CSS"],"categories":["web"]},{"title":"CSS：Normal Flow 标准流布局","url":"/2017/05/24/css-normalflow/","content":"\n标准流：其实就是网页默认的元素排列方式，是指不使用其他的与__排列和定位__相关的__特殊CSS规则__时，网页各元素的排列规则。\n<!-- more -->\n  \n> 在标准流中，__块级元素__ 在水平方向上会自动伸展，直到包含它的元素的边界，垂直方向上和兄弟元素依次排列，__行级元素__ 则在水平方向上与兄弟元素依次排列。其元素的float属性默认为none，也就是标准流通常的情况。\n\n```CSS\n .element {\n   float: none;\n }\n```\n\n因此，想要让一个元素不处于标准流中，方法可以是让该元素成为__浮动元素__或__定位元素__，也就是上文提及的__特殊CSS规则__。\n\n```CSS\n.element {\n  float: left | right;\n  position: absolute | fixed;\n}\n```\n\n***\n\n本文将主要介绍以下两部分：  \n一 [盒模型](#boxModel)  \n二 [外边距合并](#marginCollapsing)\n\n***\n\n### 盒模型 Box Model\n\n在一个文档中，每个元素都被表示为一个矩形的盒子。在CSS中，则使用标准盒模型来描述这些矩形盒子。  \n这个模型描述了元素所占空间的内容。每个盒子有四个边：__外边距边__，__边框边__，__内填充边__与__内容边__。\n\n![box-model](/images/css-normalflow/box-model.png)\n\n其中元素的 __box-sizing__ 属性决定了该元素宽度和高度的计算方式。\n\n```CSS\n.box {\n  box-sizing: content-box; /* box-sizing默认值 */\n}\n```\n\n计算公式：  \nwidth = 内容width；  \nheight = 内容height。  \n> 注意：元素的宽度和高度都不包含内容的边框(border)和内边距(padding)。\n\n```CSS\n.box {\n  -moz-box-sizing: border-box;\n  box-sizing: border-box;\n}\n```\n\n计算公式：  \nwidth = border + padding + 内容width；  \nheight = border + padding + 内容height。\n\n### 外边距合并 Margin Collapsing\n\n标准流布局中，块元素的顶部外边距和底部外边距在特殊情况时会被组合（折叠）为单个外边距，其大小是组合到其中的最大外边距，这种布局行为称为外边距塌陷(margin collapsing)，也译为外边距合并。  \n出现外边距合并的三种基本情况：\n\n#### 相邻的兄弟块级元素\n\n毗邻的两个兄弟块级元素之间的外边距会出现合并。  \n即：上下两个盒子之间的距离，不是上盒子的 margin-bottom 与下盒子的 margin-top 之和，而是两者中的较大者。\n\n```HTML\n/* CSS */\n<style>\n.top { margin-bottom: 30px; }\n.bottom {margin-top: 20px; }\n</style>\n/* HTML */\n<div class=\"top\"></div>\n<div class=\"bottom\"></div>\n```\n\n![css-margin-1](/images/css-normalflow/css-margin-1.png)\n\n#### 块级父元素与其第一个／最后一个子元素\n\n如果块级元素中，不存在 __padding-top__ | __border-top__ | __inline content__ | __清除浮动__ 这四个属性，那么这个块级元素和其第一个子元素就会发生上边距合并现象。  \n> 上边距合并：子元素的 margin-top 不起作用，父元素的 margin-top 直接变成父元素和其第一个子元素的 margin-top 的较大者。  \n\n类似，块级父元素的 margin-bottom 与最后一个子元素的 margin-bottom 也会在特定情况发生下边距合并现象。\n\n```HTML\n/* CSS */\n<style>\n.father { margin-top: 30px; }\n.son { margin-top: 50px; }\n</style>\n/* HTML */\n<div class=\"father\">\n   <div class=\"son\">\n</div>\n```\n\n![css-margin-2](/images/css-normalflow/css-margin-2.png)\n\n#### 空块元素\n\n如果存在一个空的块级元素，其 border | padding | inline-content | height | min-height 都不存在时，此时元素的上下边距中间没有任何间隔，该元素上下边距 margin-top 与 margin-bottom 将会合并。\n","tags":["CSS"],"categories":["web"]},{"title":"CSS3：Flex Box 弹性盒子模型","url":"/2017/05/22/css-flexbox/","content":"\nFlex Box：弹性盒子模型，是CSS3的一种新的布局模式。习惯上称之为flex布局，也就是弹性布局。顾名思义，当页面适应不同的屏幕大小以及设备类型时确保布局内的元素仍拥有恰当的行为。其目的是提供一种更加有效的方式对一个容器中的子元素进行排列、对齐和分配空白空间。\n<!-- more -->\n\n***\n\n### Flex Box 弹性盒子\n\n任何一个容器(元素)都可以指定为Flex布局，对于弹性盒子的介绍主要为：\n\n* 弹性盒子(Flex Box)由__弹性容器__(Flex Container)和__弹性子元素__(Flex Item)组成。\n* 弹性容器通过设置display属性的值为flex或inline-flex将其定义为弹性容器。\n* 弹性容器包含一个或多个弹性子元素。\n\n> 注意：弹性盒子只定义了弹性子元素如何在弹性容器中布局，弹性容器外及弹性子元素内是正常渲染的，\n\n### Flex Container 弹性容器\n\n容器也就是用来包裹子元素的父级元素，只要该元素的display属性声明为flex或inline-flex就成为__弹性容器__了。\n设置为 flex 的容器被渲染为块级元素：\n\n```css\n.box {\n  display: flex;\n}\n```\n\n设置为 inline-flex 的容器则渲染为行内元素：\n\n```css\n .box {\n    display: inline-flex;\n }\n```\n\nWebkit内核的浏览器，必须加上-webkit前缀:\n\n```css\n.box {\n  display: -webkit-flex; /* Safari */\n  display: flex;\n}\n```\n\n容器的6个可用属性设置（可选）:\n\n+ flex-direction\n+ flex-wrap\n+ flex-flow\n+ justify-content\n+ align-items\n+ align-content\n\n#### flex-direction属性\n\nflex-direction属性指定了弹性子元素在父容器中的排列方向。\n\n```css\n.box {\n  flex-direction: row | row-reverse | column | column-reverse;\n}\n```\n\n#### flex-wrap属性\n\nflex-wrap属性指定弹性盒子的子元素换行方式。默认情况下，项目都排在一条线（主轴线）。\n\n```css\n.box {\n  flex-wrap: nowrap | wrap | wrap-reverse;\n}\n```\n\n#### flex-flow属性\n\nflex-flow 属性是 flex-direction 和 flex-wrap 属性的复合属性。\n\n```css\n.box {\n  flex-flow: <flex-direction> || <flex-wrap>;\n}\n```\n\n#### justify-content属性\n\njustify-content属性指定子元素在主轴上的对齐方式。\n\n```css\n.box {\n  justify-content: flex-start | flex-end | center | space-between | space-around;\n}\n```\n\n#### align-items属性\n\nalign-items属性指定子元素在交叉轴上的对齐方式。\n\n```css\n.box {\n  align-items: flex-start | flex-end | center | baseline | stretch;\n}\n```\n\n#### align-content属性\n\nalign-content属性定义了多根轴线（多行排列）的对齐方式。如果子元素排列只有一根轴线，该属性不起作用。\n\n```css\n.box {\n  align-content: flex-start | flex-end | center | space-between | space-around | stretch;\n}\n```\n\n### Flex Item 弹性元素\n\n各个子元素存在于声明为flex或inline-flex的父级容器中。\n元素的6个可用属性设置（可选）：\n\n+ order\n+ flex-grow\n+ flex-shrink\n+ flex-basis\n+ flex\n+ align-self\n\n#### order属性\n\norder属性指定项目的排列顺序。数值越小，排列越靠前，默认为0，可以为负数。类似于z-index.\n\n```css\n.item {\n  order: <integer>;\n}\n```\n\n#### flex-grow属性\n\nflex-grow属性定义项目的扩展比率，默认为0，即如果存在剩余空间，也不放大。\n\n```css\n.item {\n  flex-grow: <number>; /* default 0 */\n}\n```\n\n#### flex-shrink属性\n\nflex-shrink属性定义了项目的收缩比率，默认为1，负值对该属性无效。即如果空间不足，该项目将缩小。\n\n```css\n.item {\n  flex-shrink: <number>; /* default 1 */\n}\n```\n\n#### flex-basis属性\n\nflex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。\n\n```css\n.item {\n  flex-basis: <length> | auto; /* default auto */\n}\n```\n\n#### flex属性\n\nflex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。\n\n```css\n.item {\n  flex: none | [ <'flex-grow'> ||  <'flex-shrink'> || <'flex-basis'> ]\n}\n```\n\n#### align-self属性\n\nalign-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。\n\n```css\n.item {\n  align-self: auto | flex-start | flex-end | center | baseline | stretch;\n}\n```\n","tags":["CSS","LAYOUT"],"categories":["web"]},{"title":"前端学习目标","url":"/2017/05/10/web-roadMap/","content":"\n偶然在 GitHub 看到的一个关于前端开发者的成长路线，记录下来，以此自勉。\n<!-- more -->\n\n![2021-road-map](/images/web-roadMap/2022.png)\n<center>\n本图片转载自 2022 [kamranahmedse](https://roadmap.sh/frontend)\n</center>\n\n***\n\n![2021-road-map](/images/web-roadMap/2021.png)\n<center>\n本图片转载自 2021 [kamranahmedse](https://github.com/kamranahmedse/developer-roadmap)\n</center>\n\n***\n\n![2019-road-map](/images/web-roadMap/2019.png)\n<center>\n本图片转载自 2019 [kamranahmedse](https://github.com/kamranahmedse/developer-roadmap)\n</center>\n\n***\n\n![2017-road-map](/images/web-roadMap/2017.png)\n<center>\n本图片转载自 2017 [kamranahmedse](https://github.com/kamranahmedse/developer-roadmap)\n</center>","categories":["web"]}]